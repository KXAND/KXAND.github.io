{"meta":{"title":"LeeKa 的酒馆","subtitle":"欢迎，旅人！坐下来享受一下暖烘烘的炉火吧。","description":"代码、音乐和游戏，一起来聊聊吧","author":"LeeKa","url":"http://example.com","root":"/"},"pages":[{"title":"关于我","date":"2021-01-19T16:25:11.000Z","updated":"2024-01-03T05:42:54.302Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欢迎来到 LeeKa Pub！ 这个不定期更新的页面提供网站和作者的一些信息。 关于作者 一个即将毕业的某大学数字媒体技术专业学生。 我对 Unity 游戏开发很感兴趣，也在朋友的帮衬下做过一些小玩意。也有些许 UE 的使用经验。此外，我也对区块链有一定的兴趣，但是并没有很深入的了解。 除开技术，我喜欢音乐，特别是电子音乐（EDM，techno等）。我也喜欢玩游戏，主要是各种 AAA 游戏，但是也有些独立游戏，不过很缺乏网络游戏的经历。此外，我对中世纪史、语言学等也有一定兴趣。 不过这些内容并不能都指望在这个博客看见，因为很多真的就仅仅是感兴趣。 这里的作用 这是一个基于 hexo 搭建的个人博客，使用 NexT 主题。 虽然名字有个 Pub，就本质而言，不过是个静态博客。所以除了阅读外还是不要期待有更多的功能。 网站主要是作为一个个人写文章总结心得的地方所使用，因此学到什么写什么。我对主题的分划大概是一下三块：计算机技术、电子游戏、音乐。但是目前基本只能看见技术内容了。 关于计算机技术：学习笔记，实验报告，一些配置经历分享等。 关于电子游戏：设想主要分游戏鉴赏和游戏制作两块。游戏鉴赏是对玩过游戏的评价；游戏制作则是独立游戏制作过程中的一些经验总结。 关于音乐：歌曲分享，音乐方面的学习。 反馈 我会尽力逐步完善这个 Pub。 如果你在浏览过程中发现问题 / 可改善之处，欢迎通过邮件(leeka.pub@outlook.com)告诉我。"},{"title":"标签页","date":"2020-10-22T06:24:10.000Z","updated":"2023-06-09T01:22:46.387Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"目录","date":"2020-10-22T06:35:37.000Z","updated":"2023-06-09T01:22:46.385Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2014-12-22T04:39:04.000Z","updated":"2024-01-06T20:38:38.105Z","comments":false,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""}],"posts":[{"title":"毕业设计（2）：维纳攻击论文翻译","slug":"毕业设计/毕业设计2：维纳攻击","date":"2024-01-02T14:35:17.000Z","updated":"2024-01-08T08:20:51.154Z","comments":true,"path":"post/20240102223517.html","permalink":"http://example.com/post/20240102223517.html","excerpt":"前言 1989年，人们在 MICHAEL J. WIENER 的手稿中发现了一篇题为 Cryptanalysis of Short RSA Secret Exponents 的论文。此文中，Wiener 介绍了一种使用续分数算法对 RSA 短密钥的攻击方法。出于毕业设计的要求，下面是我对这篇论文的翻译。请注意，此翻译未经校对，仅作存档用。","text":"前言 1989年，人们在 MICHAEL J. WIENER 的手稿中发现了一篇题为 Cryptanalysis of Short RSA Secret Exponents 的论文。此文中，Wiener 介绍了一种使用续分数算法对 RSA 短密钥的攻击方法。出于毕业设计的要求，下面是我对这篇论文的翻译。请注意，此翻译未经校对，仅作存档用。 下面是一些可能会让人感到疑惑的用词： 位长：通常原文是 size of,bits of number of 等，指的应该是指数的二进制位长度； 秘密指数，公共指数：指的是密钥和公钥中，在加解密时充当指数的数字，即 eee 和 ddd； 续分数：continued fraction； 分数：本文中，有可能其实是分式。 下面是翻译正文。 I. 概要 本文介绍了一种在使用短密钥的 RSA 时的密码分析攻击。该攻击使用了一种基于续分数的算法，当知道了分数的足够近的估值，该算法能在多项式时间内找到分数的分子和分母。含有秘密指数 ddd 的分式的估值可以用公共指数 eee 和模数 pqpqpq 来创建。此基于续分数的算法可以使用此估值可以充分地找到短秘密指数。典型情况是 e&lt;pqe &lt; pqe&lt;pq 、 gcd⁡(p−1,q−1)\\gcd( p - 1, q - 1)gcd(p−1,q−1) 较小且 p 和 q 的位长大致相同，则这种攻击可以发现位长最大约为模数四分之一的秘密指数。本文介绍了使用这种攻击的方法、改进方法和两个悬而未决的问题。这种攻击对 RSA 的正常情况，即秘密指数的大小与模数大致相同的情况，不构成威胁。这是因为这种攻击使用的是公共指数提供的信息，而在正常情况下，公共指数的选择几乎可以与模数无关。 II. 介绍 在 RSA 公钥系统中的所有密钥对集合中[5]，有一些密钥的特性使其可以被多种密码分析攻击所利用。有些攻击利用了模数的弱点，还有的攻击则利用了公共指数或秘密指数的弱点。这里讨论的&quot;弱点&quot;，是那些使得针对 RSA 的攻击可以在模数长度的多项式时间内完成的特性。 针对 RSA 模数的攻击旨在发现模数的两个质数因子（ppp 和 qqq）。在 p−1p-1p−1 和 q−1q-1q−1 的质因子都足够小的时候，有一种攻击可以分解模数[3]。当 p+1p+1p+1 和 q+1q+1q+1 的质因子都很小的时候，也存在一种攻击可以分解模数[6]。当两个质数的差小于 p(log⁡p)k\\sqrt{p}(\\log p)^kp​(logp)k ，其中 kkk 是某些常量，此时存在一个分解模数的简单算法。此算法基于下面的特征。 (p+q2)2−pq=(p−q2)2\\left(\\frac{p+q}{2}\\right)^2-pq=\\left(\\frac{p-q}{2}\\right)^2 (2p+q​)2−pq=(2p−q​)2 通过寻找 p+q2\\frac{p+q}{2}2p+q​ 和 p−q2\\frac{p-q}{2}2p−q​ 就可以分解模数。(p+q2)2(\\frac{p+q}{2})^2(2p+q​)2 可以在从模数开始的完全平方线性搜索中找到。当模数与其平方之差恰为完全平方数时，就可以找到正确的平方。 还有很多 RSA 攻击除了其它条件外，还要求公共指数或秘密指数足够短。某些情况下，使用短公共指数或秘密指数很有吸引力，因为这可以减少加密或解密操作的执行时间。这是因为在模数固定的情况下，RSA 的加解密时间大致与指数位长成正比。使用短指数特别有优势的一种情况是，双方的通信设备算力差距悬殊。例如在智能卡和大型计算机之间的通信中使用 RSA 。在这个例子中，让智能卡掌握短秘密指数而大型计算机掌握短公共指数，以减智能卡需要做的处理是很有吸引力的选择。但是，我们必须警惕对 RSA 的短指数攻击。 当向多方广播同一信息时，短公共指数就有可乘之机[1]。为了描述此种攻击，假设将一条消息 mmm 广播给三方，且公共指数为 e1=e2=33=3e_1=e_2=3_3=3e1​=e2​=33​=3 ，模数为 n1,n2,n3n1,n2,n3n1,n2,n3 ，那么加密消息为： m3mod n1,m3mod n2,m3mod n3m^3\\mod{n_1},\\quad m^3\\mod{n_2},\\quad m^3\\mod{n_3} m3modn1​,m3modn2​,m3modn3​ 使用中国剩余定理，我们可以找出 m3mod n1n2n3m^3\\mod{n_1n_2n_3}m3modn1​n2​n3​ 。但是，由于 m&lt;n1,n2,n3m&lt;n_1,n_2,n_3m&lt;n1​,n2​,n3​，所以 m3&lt;n1n2n3m^3&lt;n_1n_2n_3m3&lt;n1​n2​n3​ 。因此，m3m^3m3 不会因对 n1n1n2n3n_1n_1n_2n_3n1​n1​n2​n3​ 取模而减小。消息可以通过对 m3m^3m3 求立方根而得到。在本论文中描述了一种对短秘密指数的攻击。这种攻击基于续分数。 II. 续分数背景 当已知分数的估计值足够接近时，就可以使用续分数求出分数的分子和分母。这将与第四节中的 RSA 有关，在第 IV 节中，公共指数和模数将用于构建一个含有秘密指数的分数估计值。 根据给定的分数的估计值，利用续分数求分子和分母的算法在此称为续分数算法。该算法将在第 III 节中介绍。 本 节将为讨论连续分数算法提供必要的背景。关于连分数的进一步讨论， 可参阅 [2] 。 续分数的表达式为 \\begin{equation} \\begin{aligned} &amp;\\frac{a_1}{q_1+\\frac{a_2}{q_2+\\frac{a_3}{\\cdots\\frac{\\ }{q_{m-1}+\\frac{a_m}{q_m}}}}}\\\\ &amp;=a_1/(q_1+a_2/(q_2+a_3/(\\cdots/q_{m-1}+a_m/q_m)\\cdots)) \\end{aligned} \\end{equation} 而我们感兴趣的是，上式中所有 aia_iai​ 均为 111 的情况。方便起见，我们定义 \\begin{equation} &lt;q_0,q_1,\\cdots,q_m&gt;=q_0+1/(q_1+1/(q_2+1/(\\cdots/q_{m-1}+1/q_m)\\cdots)) \\end{equation} 例如，&lt;0,2,1,3&gt;=0+1/(2+1/(1+1/3))=4/11&lt;0,2,1,3&gt; =0+1/(2+1/(1+1/3))=4/11&lt;0,2,1,3&gt;=0+1/(2+1/(1+1/3))=4/11 。称 &lt;0,2,1,3&gt;&lt;0,2,1,3&gt;&lt;0,2,1,3&gt; 为 411\\frac{4}{11}114​ 的续分数展开式 正有理数 fff 的续分数展开式是通过减去 fff 的整数部分，然后不断对余下部分取倒数再减去整数部分，直到小数部分为零为止。设 qiqiqi 为整数商，rrr 为第 iii 步余下的小数，mmm 为反转的步数： \\begin{equation} \\begin{aligned} &amp;q_0=\\lfloor f\\rfloor, \\quad r_0=f-q_0, 且\\\\ &amp;q_i=\\lfloor \\frac{1}{r_{i-1}}\\rfloor,\\quad r_i=\\frac{1}{r_{i-1}}-q_i,\\quad (i=1,2,\\cdots,m) \\end{aligned} \\end{equation} 因为 rm=0r_m=0rm​=0，我们有 f=⟨q0,q1,⋯ ,qm⟩f=\\langle q_0,q_1,\\cdots,q_m\\ranglef=⟨q0​,q1​,⋯,qm​⟩ 。此处可以得出两点结论，它们稍后会很有用的。第一， qm≥2q_m\\geq2qm​≥2。若 qm=1q_m=1qm​=1 会推出 rm−1=1r_{m-1}=1rm−1​=1 ，这是不可能的，故得证。第二个结论是，对任意 x&gt;0x&gt;0x&gt;0： \\begin{equation} \\begin{aligned} \\langle q_0,q_1,\\cdots,q_m\\rangle &lt;\\langle q_0,q_1,\\cdots,q_m+x\\rangle,\\\\ &amp;若 m 是偶数,\\\\ \\langle q_0,q_1,\\cdots,q_m\\rangle &gt;\\langle q_0,q_1,\\cdots,q_m+x\\rangle,\\\\ &amp;若 m 是奇数. \\end{aligned} \\end{equation} 这可以通过查看 (2) 式中分数嵌套的层数看出。 现在我们开始思考如何通过 fff 的续分数展开式构造出 fff 。利用 (2) 式，可以从 qmq_mqm​ 开始，每步不断加和求倒数，直到回到 q0q_0q0​ ，以得到 fff。不过，要是能从 q0q_0q0​ , 开始重建 fff 就很好了。设 nin_ini​ 和 did_idi​ （其中 i=0,1,⋯ ,mi=0,1,\\cdots,mi=0,1,⋯,m）分别为一系列被定义为如下形式的分子和分母： \\begin{equation} \\begin{aligned} \\frac{n_i}{d_i}=\\langle q_0,q_1,\\cdots,q_i\\rangle,\\quad \\gcd(n_i,d_i)=1\\\\ &amp;i=0,1,\\cdots,m\\\\ \\end{aligned} \\end{equation} 可以写成如下形式： \\begin{equation} \\begin{aligned} &amp;n_0=q_0, &amp;&amp;d_0=1,\\\\ &amp;n_1=q_0q_1+1, &amp;&amp;d_1=q_1,\\\\ &amp;n_i=q_in_{i-1}+n_{i-2}, &amp;&amp;d_i=q_id_{i-1}+d_{i-2},\\\\ &amp;&amp;&amp;\\qquad i=2,3,\\cdots,m. \\end{aligned} \\end{equation} 这样，通过分式 f=nmdmf=\\frac{n_m}{d_m}f=dm​nm​​ 就可以构造出 fff 来了。 上述的分子分母 n,dn,dn,d 之间有下列在后面很有用的关系，可以证明： \\begin{equation} n_id_{i-1}-n_{i-1}d_i=-(-1)^i,\\quad i=1,2,\\cdots,m \\end{equation} 现在，我们已经介绍了足够的连分数背景知识，以供讨论连分数算法。 III. 续分数算法 设 f′f&#x27;f′ 是 fff 的低估值： \\begin{equation} f&#039;=f(1-\\delta), \\quad\\delta \\geq 0 \\end{equation} 设 qiq_iqi​，rir_iri​，和 qi′q&#x27;_iqi′​，ri′r&#x27;_iri′​，分别是 fff 和 f′f&#x27;f′ 的第 i 个商和因数。若 δ\\deltaδ 足够小，那么可以下面的算法求出 fff 的分子和分母。重复以下步骤，直到找到 fff 为止： 生成 f′f&#x27;f′ 的续分数展开式的下一个商（qi′q_i&#x27;qi′​）。 用 (6) 式构造分式使之等于⟨q0′,q1′,⋯ ,qi−1′,qi′+1,⟩,i为偶数,⟨q0′,q1′,⋯ ,qi−1′,qi′,⟩,i为奇数.\\begin{aligned} &amp;\\langle q_0&#x27;,q_1&#x27;,\\cdots, q_{i-1}&#x27;,q_i&#x27;+1,\\rangle, \\qquad&amp;i 为偶数,\\\\ &amp;\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_{i-1}&#x27;,q_i&#x27;,\\rangle, \\qquad&amp;i 为奇数. \\end{aligned} ​⟨q0′​,q1′​,⋯,qi−1′​,qi′​+1,⟩,⟨q0′​,q1′​,⋯,qi−1′​,qi′​,⟩,​i为偶数,i为奇数.​ 检查构造的分式是否等于 fff 。 在第偶数个商的值上加 111 的原因是，fff 的猜测值应该大于 f′f&#x27;f′ ，因为 f≥f′f \\geq f&#x27;f≥f′。这点可以在 (4) 式中由 ⟨q0′,q1′,⋯ ,qi−1′,qi′⟩\\langle q&#x27;_0,q&#x27;_1,\\cdots,q&#x27;_{i-1},q_i&#x27;\\rangle⟨q0′​,q1′​,⋯,qi−1′​,qi′​⟩ 小于 ⟨q0′,q1′,⋯ ,qi−1′,qi′+ri′⟩\\langle q&#x27;_0,q&#x27;_1,\\cdots,q&#x27;_{i-1},q_i&#x27;+r&#x27;_i\\rangle⟨q0′​,q1′​,⋯,qi−1′​,qi′​+ri′​⟩ 看出。注意为了确定 fff 的猜测值是否正确，必须对其进行检验。 若 \\begin{equation} \\begin{aligned} &amp;\\langle q_0,q_1,\\cdots, q_{m-1},q_m-1,\\rangle&lt;f&#039;\\leq \\langle q_0,q_1,\\cdots, q_m\\rangle, \\qquad&amp;i 为偶数,\\\\ &amp;\\langle q_0,q_1,\\cdots,q_{m-1},q_m+1,\\rangle&lt;f&#039;\\leq \\langle q_0,q_1,\\cdots, q_m\\rangle, \\qquad&amp;i 为奇数. \\end{aligned} \\end{equation} 成立，那么续分数算法就是正确的。 现在考虑 (9) 式关于 δ\\deltaδ 的大小的推论。在 (8) 式解得 \\begin{equation} \\delta =1-\\frac{f&#039;}{f} \\end{equation} 分别分析以下的几种情况：m=0m=0m=0， m=1m=1m=1 ，mmm 为大于等于 222 的偶数，mmm 为大于等于 333 的奇数。 情况 1：m=0m=0m=0。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0-1\\rangle}{\\langle q_0\\rangle} \\end{equation} 利用 (2) 式，可将其简化为 δ&lt;1/q0\\delta &lt; 1/q_0δ&lt;1/q0​，并可重写为（请注意 n0=q0n_0 = q_0n0​=q0​ 和 d0=1d_0 = 1d0​=1） \\begin{equation} \\delta&lt;\\frac{1}{n_0d_0} \\end{equation} 情况 2：m=1m=1m=1。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0,q_1+1\\rangle}{\\langle q_0,q_1\\rangle} \\end{equation} 利用 (2) 式，可以有： \\begin{equation} \\delta&lt;\\frac{1}{(q_0q_1+1)(q_1+1)} \\end{equation} 前面已经证明 qm≥2q_m \\geq 2qm​≥2 ，这意味着此时 32q1≥q1+1\\frac{3}{2}q_1\\geq q_1+123​q1​≥q1​+1。结合 (14) 式以及 (6)式中的 n1n_1n1​ 和 d1d_1d1​ 表达式，有： \\begin{equation} \\delta=\\frac{1}{\\frac{3}{2}n_1d_1} \\end{equation} 足以保证续分数算法的成功。 情况 3：mmm 为大于等于 222 的偶数。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0,q_1,\\cdots,q_{m-1},q_m-1\\rangle}{\\langle q_0,q_1,\\cdots,q_m\\rangle} \\end{equation} 利用 (6) 式，有： \\begin{equation} \\begin{aligned} \\langle q_0,q_1,\\cdots,q_{m-1},q_m-1\\rangle&amp;=\\frac{(q_{m}-1)n_{m-1}+n_{m-2}}{(q_{m}-1)d_{m-1}+d_{m-2}}\\\\ \\langle q_0,q_1,\\cdots,q_m\\rangle&amp;=\\frac{q_{m}n_{m-1}+n_{m-2}}{q_{m}d_{m-1}+d_{m-2}} \\end{aligned} \\end{equation} 将上面的表达式代入到 (16) 式： \\begin{equation} \\delta&lt;\\frac{n_{m-1}d_{m-2}-n_{m-2}d_{m-1}}{(q_mn_{m-1}+n_{m-2})(q_md_{m-1}+d_{m-2}-d_m-1)} \\end{equation} 利用 (7) 式及 (6) 式中 nmnmnm 和 dmd_mdm​ 的表达式，得： \\begin{equation} \\delta&lt;\\frac{1}{n_m(d_m-d_{m-1})} \\end{equation} 因此 \\begin{equation} \\delta&lt;\\frac{1}{n_md_m} \\end{equation} 足以保证续分数算法的成功。 情况 4：mmm 为大于等于 333 的奇数。 和情况 3 中进行类似的分析，得 \\begin{equation} \\delta&lt;\\frac{1}{n_m(d_m+d_m-1)} \\end{equation} 由 dm=qmdm−1+dm−2d_m=q_md_{m-1}+d_{m-2}dm​=qm​dm−1​+dm−2​ 且 qm≥2q_m\\geq2qm​≥2 ，有 dm+dm−1≤32dmd_m+d_{m-1}\\leq \\frac{3}{2}d_mdm​+dm−1​≤23​dm​ 。因此， \\begin{equation} \\delta&lt;\\frac{1}{\\frac{3}{2}n_md_m} \\end{equation} 足以保证续分数算法的成功。 综合考虑上面提到的四种情况： \\begin{equation} \\delta &lt;\\frac{1}{\\frac{3}{2}n_md_m} \\end{equation} 足以保证续分数算法的成功。这里的 nm,dmn_m,d_mnm​,dm​ 就是前面提到过的 fff 的分子和分母。 现在考虑续分数算法执行的花费时间。设 x=max⁡(nm,dm)x=\\max(n_m,d_m)x=max(nm​,dm​) ，fff 的续分数展开式中除计算的数量可被表示为 O(log⁡x)O(\\log x)O(logx) 。每次除计算后，会得到并检验一个 fff 的猜测值。算式要求每次得到的 fff 的猜测值是 log⁡x\\log xlogx 的多项式。因此，假设 fff 的检验在 log⁡x\\log xlogx 的多项式中是正确的，那么续分数算法执行花费的时间就是 log⁡x\\log xlogx 的多项式。 IV. 在 RSA 上应用续分数算法 在 [5] 中给出了公共指数 eee 和秘密指数 ddd 的关系： \\begin{equation} ed\\equiv1\\mod LCM(p-1,q-1) \\end{equation} 这种关系对于公开指数和秘密指数互为倒数的指数运算来说是必要的。根据 (24)，必定存在一个整数 K，使 \\begin{equation} ed=K\\cdot LCM(p-1,q-1)+1 \\end{equation} 若令 G=gcd⁡(p−1,q−1)G=\\gcd(p-1,q-1)G=gcd(p−1,q−1) ，由 lcm(p−1,q−1)=(p−1)(q−1)Glcm(p-1,q-1)=\\frac{(p-1)(q-1)}{G}lcm(p−1,q−1)=G(p−1)(q−1)​ 得 \\begin{equation} ed=\\frac{K}{G}(p-1)(q-1)+1 \\end{equation} KKK 和 GGG 有可能有共同的因子。我们定义 k=Kgcd⁡(K，G)k = \\frac{K}{\\gcd(K，G)}k=gcd(K，G)K​ 和 g=Ggcd⁡(K,G)g=\\frac{G}{\\gcd(K,G)}g=gcd(K,G)G​。那么有 \\begin{equation} ed=\\frac{k}{g}(p-1)(q-1)+1 \\end{equation} 把 (27) 式同时除以 dpqdpqdpq： \\begin{equation} \\frac{e}{pq}=\\frac{k}{dg}(1-\\delta),\\qquad 其中\\ \\delta=\\frac{p+q-1-\\frac{g}{k}}{pq} \\end{equation} 需要注意 epq\\frac{e}{pq}pqe​ 是完全由公开信息构成的，且是对 kdg\\frac{k}{dg}dgk​ 的近似低估。在使用续分算法之前，我们必须记住这种算法总是能找到最小项的分数。由 (25) 可知，gcd⁡(K,d)=1\\gcd(K, d) = 1gcd(K,d)=1。因为 kkk 整除 KKK，所以 gcd⁡(k,d)=1\\gcd(k, d) = 1gcd(k,d)=1。根据定义，gcd⁡(k，g)=1\\gcd(k，g)= 1gcd(k，g)=1。因此，gcd(k，dg)=1gcd(k，dg)= 1gcd(k，dg)=1 ，故而只要 δ\\deltaδ 足够小就可以使用续分数算法求出 kkk 和 dgdgdg。 通过 (28) 式中的 δ\\deltaδ 表达式和 (23) 式对 δ\\deltaδ 的限制，可以证明 \\begin{equation} kdg&lt;\\frac{pq}{\\frac{3}{2}(p+q)} \\end{equation} 对求出 kkk 和 dgdgdg 是充分的。注意 (−1−gk)(-1-\\frac{g}{k})(−1−kg​) 在 δ\\deltaδ 的表达式中被舍弃了，因为其相对于 (p+q)(p+q)(p+q) 是很小的。这不会影响 (29) 式的有效性，因为 −1−gk-1-\\frac{g}{k}−1−kg​ 在算式中只会减小 δ\\deltaδ 的大小。 现在，我们将考虑如何检验 kkk 和 dgdgdg 的猜测是正确的。为了简化测试，我们假设 ed&gt;pqed &gt; pqed&gt;pq。这并不是一个特别严格的假设，因为当 eee 或 ddd 固定时，另一个的期望值约为 pq/Gpq / Gpq/G（回顾 G=gcd⁡(p−1,q−1)G = \\gcd(p - 1, q - 1)G=gcd(p−1,q−1)。除非 G 选得很大，否则 ed&gt;pqed&gt;pqed&gt;pq 的可能性很大。根据 (27) 式，ed&gt;pqed &gt; pqed&gt;pq 的结果是 k&gt;gk&gt;gk&gt;g 。重写(27)式成： \\begin{equation} edg=k(p-1)(q-1)+g \\end{equation} 可以看到，只要 k&gt;gk&gt;gk&gt;g ,那么用 kkk 除 edgedgedg 就有商 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 余 ggg 。这就给了我们一个 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 和 ggg 的猜测。如果 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 是 000，那么 kkk 和 dgdgdg 的值都是错误的。这种情况必须被过滤掉，不然该测试就会把 pqpqpq 分解为 111 和 pqpqpq。通过下列等式，我们可以用 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的猜测值来猜测 p+q2\\frac{p+q}{2}2p+q​ ： \\begin{equation} \\frac{pq-(p-1)(q-1)+1}{2}=\\frac{p+q}{2} \\end{equation} 若 p+q2\\frac{p+q}{2}2p+q​ 的值不是整数，则 kkk 和 dgdgdg 的值都是错误的。通过下式，可以用 p+q2\\frac{p+q}{2}2p+q​ 的猜测值来猜测 (p−q2)2(\\frac{p-q}{2})^2(2p−q​)2： \\begin{equation} (\\frac{p+q}{2})^2-pq=(\\frac{p-q}{2})^2 \\end{equation} 若 ((p−q)/2)(( p - q)/2)((p−q)/2) 的猜测是完全平方，那么原来对 kkk 和 dgdgdg 的猜测就是正确的。用 dgdgdg 除以 ggg 可以求出秘密指数 ddd 。如前所述，ggg 是 edgedgedg 除以 kkk 的余数。我们也能通过 (p+q)2\\frac{(p+q)}{2}2(p+q)​ 和 (p−q)2\\frac{(p-q)}{2}2(p−q)​ 轻松地算出 ppp 和 qqq 的值。 如果不采取任何措施对抗这种 RSA 上的续分数攻击，那么就可以期望 ggg 很小且 g&lt;dgg&lt;dgg&lt;dg。在这种条件下，由 (29) 式可知，二进制位数不大于大约模数四分之一比特位数的秘密指数可以在多项式时间内找到。这种攻击无法扩展到秘密指数与模的大小大致相同的正常情况，因为它依赖于公共指数提供信息来对模数进行因数分解，而在正常情况下，公共指数的选择几乎与模无关。 V. 例子 在这一部分，我们给续分数算法中放入一组很小的 RSA 密钥对： pq=8927e=2621pq=8927\\quad e= 2621 pq=8927e=2621 epq=26218927\\frac{e}{pq}=\\frac{2621}{8927}pqe​=89272621​ 的续分数展开式如表 I。 需要求的量 计算方法 i=0i=0i=0 i=1i=1i=1 i=2i=2i=2 qi′q&#x27;_iqi′​ 见 (3) 式 000 333 222 ri′r_i&#x27;ri′​ 见 (3) 式 26218927\\frac{2621}{8927}89272621​ 10642621\\frac{1064}{2621}26211064​ 4931064\\frac{493}{1064}1064493​ ni′di′=⟨q0′,q1′,⋯ ,qi′⟩\\frac{n_i&#x27;}{d_i&#x27;}=\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_i&#x27;\\rangledi′​ni′​​=⟨q0′​,q1′​,⋯,qi′​⟩ 见 (6) 式 01\\frac{0}{1}10​ 13\\frac{1}{3}31​ 27\\frac{2}{7}72​ kdg\\frac{k}{dg}dgk​ 的估值 ⟨q0′,q1′,⋯ ,qi−1′,qi′+1⟩(偶数)⟨q0′,q1′,⋯ ,qi′⟩(奇数)\\langle q_0&#x27;,q_1&#x27;,\\cdots,q&#x27;_{i-1},q_i&#x27;+1\\rangle\\quad(偶数)\\\\\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_i&#x27;\\rangle\\quad(奇数)⟨q0′​,q1′​,⋯,qi−1′​,qi′​+1⟩(偶数)⟨q0′​,q1′​,⋯,qi′​⟩(奇数) 11\\frac{1}{1}11​ 13\\frac{1}{3}31​ 310\\frac{3}{10}103​ edgedgedg 的估值 e⋅dge\\cdot dge⋅dg 262126212621 786378637863 262102621026210 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的估值 ⌊edgk⌋\\lfloor\\frac{edg}{k}\\rfloor⌊kedg​⌋ 262126212621 786378637863 888 ggg 的估值 edgmod kedg\\mod kedgmodk 000 000 222 p+q2\\frac{p+q}{2}2p+q​ 的估值 见 (31) 式 3153.53153.53153.5 532.5532.5532.5 969696 (p−q2)2(\\frac{p-q}{2})^2(2p−q​)2 见 (32) 式 退出 退出 289=172289=17^2289=172 ddd dgg\\frac{dg}{g}gdg​ 555 在本例中，RSA 续分数攻击的结果是： d=8927,p=113,q=79,k=3,g=2.d=8927\\quad, p=113\\quad,q=79\\quad, k=3\\quad, g=2\\quad. d=8927,p=113,q=79,k=3,g=2. 通过将值代入 (27) 式验证，可以知道 d=5d=5d=5 就是 e=2621e=2621e=2621 对应的密钥。还可以验证，算法成功的充分条件 (29) 式得到了满足。 这个例子展现了对 RSA 进行续分数攻击的细节，但考虑一个更现实的情况也很有用。假设在 RSA 算法中用了一个 102410241024 比特（bit）的模数，那么 p,qp, qp,q 的大小约为 25122^{512}2512。假设 g=2g=2g=2，且 e≈pqe\\approx pqe≈pq，则 k≈dgk\\approx dgk≈dg（见(28) 式）。那么利用 (29) 式，可以看到续分数攻击可以找到最大约为 22552^{255}2255 的密钥。 VI. 对抗 RSA 的续分数攻击 有两种方法可以减少可以使用 RSA 续分数攻击找到的秘密指数的最大值。由 (29) 式可知，这两种方法就是让 kkk 变大或让 ggg 变大。 要使 kkk 增大，就必须让公共指数 eee 增大（见 (27)式）。这可以通过在 eee 上添加 lcm(p−1，q−1)lcm (p-1，q-1)lcm(p−1，q−1) 的倍数来实现。假设 e&gt;(pq)1.5e&gt;(pq) ^{1.5}e&gt;(pq)1.5 ,可以推出 kdg&gt;(pq)0.5\\frac{k}{dg}&gt;(pq)^{0.5}dgk​&gt;(pq)0.5 （见 (28) 式）。将 k=dg(pq)0.5k=dg(pq)^{0.5}k=dg(pq)0.5 代入到 (29) 式，得到 d&lt;1d&lt;1d&lt;1 。因此，若 e&gt;(pq)1.5e&gt;(pq) ^{1.5}e&gt;(pq)1.5 ，续分数算法就不能保证对任意大小的秘密指数均有效了。增大 eee 的大小有其弊端，这会导致公钥加密花费的时间增多。但是这在一些系统中是可以接受的。 要使 ggg 更大，必须选择 p 和 q 使得 gcd⁡(p−1，q−1)\\gcd (p-1，q-1)gcd(p−1，q−1) 很大。但是，我们稍后可以看到，在特定条件下有些方法可以找出 ggg 或 ggg 的因子。 VII. 改善攻击算法 在这一节，我们讨论四种针对短秘密指数攻击的可能改善方法。第一个改善是允许续分数算法稍微越过 (29) 式的限制持续搜寻 ddd。算法只能保证在限制内一定有效，但是略微超出限制也可能有效。这能让找到的（最大）秘密指数位长增加一位左右。 第二种改善基于下面的观察：kdg\\frac{k}{dg}dgk​ 的低估值 epq\\frac{e}{pq}pqe​ ，其分母就是对 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的高估值。一个更贴近 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的估值是： ⌊(pq−1)2⌋\\lfloor(\\sqrt{pq}-1)^2\\rfloor ⌊(pq​−1)2⌋ 使用此估值，(29) 式变成 kdg&lt;23(pq−1p−q)2.kdg&lt;\\frac{2}{3}(\\frac{\\sqrt{pq}-1}{\\sqrt{p}-\\sqrt{q}})^2. kdg&lt;32​(p​−q​pq​−1​)2. 这可以提高可以找到的秘密指数大小。此项改进提高的量随 ∣p−q∣|p-q|∣p−q∣ 的减小而提高。 第三个 RSA 上的续分数攻击改善方法是，对 kdg\\frac{k}{dg}dgk​ 的多个猜测值执行该算法。我们可以从某个猜测值开始，然后逐步尝试更大的猜测值。这样一来，我们就等于对 kdg\\frac{k}{dg}dgk​ 进行了线性搜索。对于最大为 (29) 式中限制大小的秘密指数，此算法消耗多项式时间。而当秘密指数的位长增长超过限制，算法执行的次数就呈指数增长。 第四个改善是尝试寻找 ggg 或 ggg 的因子。假设 ttt 是 ggg 的一个已知因子，那么我们可以用 t(epq)作为kd(gt)的低估值。t\\left(\\frac{e}{pq}\\right) 作为\\frac{k}{d(\\frac{g}{t})}的低估值。 t(pqe​)作为d(tg​)k​的低估值。 这种情况下，(29) 式就变成了 kd(gt)&lt;pq32(p+q)kd\\left(\\frac{g}{t}\\right)&lt;\\frac{pq}{\\frac{3}{2}(p+q)} kd(tg​)&lt;23​(p+q)pq​ ddd 的大小的增加可以通过 ttt 的一个因子找到。我们需要一种方法找到 g 的所有因子。因为 ggg 整除 gcd⁡(p−1)(q−1)\\gcd(p-1)(q-1)gcd(p−1)(q−1), 且 ggg 也整除 p−1p-1p−1 和 q−1q-1q−1，那么 g 也整除 pq−1pq-1pq−1，因为 pq−1=(p−1)(q−1)+(p−1)+(q−1)pq-1=(p-1)(q-1)+(p-1)+(q-1) pq−1=(p−1)(q−1)+(p−1)+(q−1) 一种可能的寻找 ggg 的所有因数的办法是因数分解 pq−1pq-1pq−1。如果 ggg 选择得很大且 ggg 的所有质因子都很大，那么通过分解 pq−1pq-1pq−1 寻找 ggg 的因数可能会很困难。但是，如果 ggg 足够大，从而使 p−1g\\frac{p-1}{g}gp−1​ 和 q−1g\\frac{q-1}{g}gq−1​ 很小，我们就可以通过寻找 p−1g\\frac{p-1}{g}gp−1​ 和 q−1g\\frac{q-1}{g}gq−1​ 的可能值来找到 ggg。 VIII. 悬而未决的问题 使用短秘密指数的主要原因是减少密钥做指数时（消耗）的时间。要减少密钥做指数消耗的时间，一种有效的办法是利用 ppp 和 qqq（而不仅仅是乘积 pqpqpq）的知识 [4]。利用这种方法，需要执行两次一半位长的指数计算。第一次指数计算使用指数 dp=dmod p−1d_p=d\\mod{p-1}dp​=dmodp−1，得出模 ppp 后的结果。第二次则使用指数 dq=dmod q−1d_q=d\\mod{q-1}dq​=dmodq−1 得出模 qqq 的结果。这两个结果结合在一起，可以通过中国剩余定理轻松地得到最终的模 pqpqpq 的结果。我们可以通过选择 ddd 使得 dpd_pdp​ 和 dqd_qdq​ 都很短，从而进一步的减少密钥指数运算的时间。一个有趣的公开问题是，在 dpd_pdp​ 和 dqd_qdq​ 都很短但是不相等的时候，是否存在一种 RSA 攻击。 另一个未解决的问题是于公共指数的位长有关。本论文前面描述的攻击在选择的公共指数至少比模数 pqpqpq 长 50%50\\%50% 时会无效。对某些系统而言，为了快速的密钥计算，这是可以承担的小代价。一个有趣的问题是，当秘密指数很小但是公共指数比模数还大时，是否存在一种 RSA 攻击。 IX. 结论 续分数算法可以在多项式时间内找到足够短的 RSA 秘密指数。一种典型的情况是，e&lt;pqe&lt;pqe&lt;pq，gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 很小，且 ppp 和 qqq 位长大致相等，此算法就可以找到位长最大约为模数的四分之一的秘密指数。 有很多种办法对抗 RSA 上的续分数攻击。如果 e&gt;(pq)1.5e&gt;(pq)^{1.5}e&gt;(pq)1.5 ，那么续分数算法对任何位长的秘密指数都无法保证有效。同时我们也可以选择让 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 很大，因为能找到的秘密指数长度与 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 成反比。不过，让 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 变大可能会导致其它的问题。 我们还讨论了若干 RSA 上的续分数攻击的改善方法。但是，在多项式时间内搜寻时，它们只能让能找到的最大秘密指数长度增加些许几位。因为当秘密指数的长度增长到超过最大限度时，寻找秘密指数的时间需求会呈指数增长。此攻击无法拓展到通常的情况，即秘密指数与模数大致有一样的位长。 参考文献 J. Hastad. “On using RSA with low exponent in a public key network,” Lecture Notes in Computer Science: Advances in Cryptology-CRYPT0 ’85 Proceedings. New York: Springer-Verlag, pp.403-408. D. E. Knuth, Art of Computer Programming Vol. 2/Seminumerical algorithms. New York: Addison Wesley, 1969. J. M. Pollard. “Theorems on factorization and primality testing,”Proc. Cambridge Philos. Soc., vol. 76, 1974, pp. 521-528. J. J. Quisquater and C. Couvreur, “Fast decipherment algorithm for RSA public-key cryptosystem,” Electron. Lett., vol. 18, no. 21,pp. 905-907, Oct. 1982. R. L. Rivest, A. Shamir, and L. Adleman, “A method for obtaining digital signatures and public key cryptosystems.” Commun. ACM.vol. 21, no. 2, pp. 158-164, Feb. 1978. H. C. Williams, “A p + 1 method of factoring,” Muthemutics of Computation, vol. 39, no. 159, pp. 225-234, July 1982.","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"毕业设计（1）：RSA密码与其数学原理","slug":"毕业设计/毕业设计1：RSA密码","date":"2023-12-13T14:09:26.000Z","updated":"2024-01-06T16:34:14.674Z","comments":true,"path":"post/20231213220926.html","permalink":"http://example.com/post/20231213220926.html","excerpt":"前言 什么是 RSA 算法及其数学原理。毕业设计笔记。","text":"前言 什么是 RSA 算法及其数学原理。毕业设计笔记。 RSA 算法的步骤 这里先不加数学原理解释，直接给出 RSA 的基本工作步骤，如下。 密钥的生成 选择两个素数 ppp，qqq； 记 n=p×qφ(n)=(p−1)×(q−1)n = p \\times q \\\\ \\varphi(n) = (p-1)\\times(q-1) n=p×qφ(n)=(p−1)×(q−1) 求公钥：任意选择 eee 使得： {0&lt;e&lt;φ(n)gcd(φ(n),e)=1\\left\\{ \\begin{aligned} &amp;0&lt;e&lt;\\varphi(n) \\\\ &amp;gcd(\\varphi(n),e)=1 \\end{aligned} \\right. {​0&lt;e&lt;φ(n)gcd(φ(n),e)=1​ 即 eee 小于 φ(n)\\varphi(n)φ(n)，且与 φ(n)\\varphi(n)φ(n) 互质； 求私钥：计算 ddd，其满足 d⋅e≡1mod (φ(n))d\\cdot e \\equiv 1 \\mod(\\varphi(n))d⋅e≡1mod(φ(n))。或者说，d⋅e+c⋅φ(n)=1d\\cdot e+ c\\cdot\\varphi(n)=1d⋅e+c⋅φ(n)=1，其中 ccc 不确定，求 ddd； {e,n}为公钥，{d，n}为私钥，p，q丢弃。 发现自己连第四步中的 d⋅e+c⋅φ(n)=1d\\cdot e+ c\\cdot\\varphi(n)=1d⋅e+c⋅φ(n)=1 都不会推了，简单记一下。 d⋅e≡1mod (φ(n))d⋅e−1=k⋅φ(n)d⋅e+c⋅φ(n)=1\\begin{aligned} d\\cdot e &amp;\\equiv 1 \\mod(\\varphi(n))\\\\ d\\cdot e-1&amp;=k\\cdot\\varphi(n)\\\\ d\\cdot e+ c\\cdot\\varphi(n)&amp;= 1 \\end{aligned} d⋅ed⋅e−1d⋅e+c⋅φ(n)​≡1mod(φ(n))=k⋅φ(n)=1​ 加密 对于明文 m，密文为c： c≡memod (n)c\\equiv m^e \\mod(n) c≡memod(n) 也就是说，我们对 mmm 进行幂运算同时进行模运算即可加密。 解密 对于密文 ccc，明文 mmm： m≡cdmod (n)m\\equiv c^d \\mod(n) m≡cdmod(n) 也就是说，我们对 ccc 进行幂运算同时进行模运算即可解密。 RSA 的数学基础 乘法逆元与扩展欧几里得算法 裴蜀定理（不证） 裴蜀定理（Bézout's lemma）指出，关于 aaa，bbb 的方程： ax+by=max+by=m ax+by=m 仅在 mmm 为 aaa，bbb 的最大公约数的倍数时，有整数解。 通过裴蜀定理，我们就可以把 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 转化成 ax+by=max+by=max+by=m。其中 m 是最大公因数的倍数。 特别地，当 m=1m=1m=1，这个时候 x,yx,yx,y 分别被叫做 aaa关于模 bbb 的模逆元 xxx 和 bbb关于模 aaa 的模逆元 yyy。 乘法逆元 ab≡1mod (n)ab\\equiv 1 \\mod(n) ab≡1mod(n) 则 a,ba,ba,b 互为乘法逆元（模逆元、模倒数）。此时有： ab+kn=1ab+kn=1 ab+kn=1 乘法逆元存在的充要条件是 a,na,na,n 互质，换句话说，右边的 1 其实是 gcd(a,n)gcd(a,n)gcd(a,n)。若 gcd(a,n)≠1gcd(a,n) \\neq 1gcd(a,n)=1，那么 xxx 就不是逆元。 求乘法逆元我们可以使用下面介绍的扩展欧几里得算法，在求 gcd(a,n)gcd(a,n)gcd(a,n) 的过程中，将逆元 bbb 求出。 在 RSA 中，私钥 ddd 实际上就是公钥 eee 的乘法逆元。 欧几里得算法与其证明 欧几里得算法即辗转相除法，用于求两个数的最大公因数。在密钥生成的第三步，我们可以用欧几里得算法检查 gcd(φ(n),e)gcd(\\varphi(n),e)gcd(φ(n),e) 是否为 1。其算法逻辑如下： 123456789int gcd(int a, int b)&#123; if (b == 0) &#123; return a; &#125; int d = gcd(b, a % b); return d;&#125; 比较简单就只写代码了。 下面是该算法有效性的证明： 设 a&gt;ba&gt;ba&gt;b （否则，代码结果会等价于做一次交换）： 在带余除法下，我们设 q=⌊ab⌋q=\\displaystyle\\left\\lfloor\\frac{a}{b}\\right\\rfloorq=⌊ba​⌋：商 r=a mod br=a\\bmod br=amodb：余 d1=gcd⁡(a,b)d_1=\\gcd(a,b)d1​=gcd(a,b)：最大公因数 d2=gcd⁡(b,r)d_2=\\gcd(b,r)d2​=gcd(b,r)：与余的最大公因数 那么，对于 d1d_1d1​： 由于 bbb 是最大公因数 d1d_1d1​ 的倍数，那么 qbqbqb 也是 d1d_1d1​ 的倍数； 又 aaa 是最大公因数 d1d_1d1​ 的倍数，那么 a−qba-qba−qb 也是 d1d_1d1​ 的倍数； 又 r=a−qbr=a-qbr=a−qb ，所以 rrr 也是 d1d_1d1​ 的倍数。 d1d_1d1​同时为 bbb 和 rrr 因数，即 d1d_1d1​ 是 bbb 和 rrr 的公因数。 由于 d2=gcd⁡(b,r)d_2=\\gcd(b,r)d2​=gcd(b,r) 数，根据性质“最大公因数是所有公因数的倍数”，可知 d1d_1d1​ 是 d2d_2d2​ 的因数。 另一方面，对于 d2d_2d2​： 由于 bbb 是最大公因数 d2d_2d2​ 的倍数，那么 qbqbqb 也是 d2d_2d2​ 的倍数； 又 rrr 是最大公因数 d2d_2d2​ 的倍数，那么 r+qbr+qbr+qb 也是 d2d_2d2​ 的倍数； 由于 a=qb+ra=qb+ra=qb+r ，所以 aaa 也是 d2d_2d2​ 的倍数。 所以 d2d_2d2​ 是 aaa 和 bbb 的公因数。 由于 d1=gcd⁡(a,b)d_1=\\gcd(a,b)d1​=gcd(a,b) ，根据性质“最大公因数是所有公因数的倍数”，所以 d2d_2d2​ 是 d1d_1d1​ 的因数。 d1d_1d1​ 是 d2d_2d2​ 的因数， d2d_2d2​ 也是 d1d_1d1​ 的因数，这说明 d1=d2d_1=d_2d1​=d2​ ，即 gcd⁡(a,b)=gcd⁡(b,a mod b)\\gcd(a,b)=\\gcd(b,a\\bmod b)gcd(a,b)=gcd(b,amodb) 。因此辗转相除法是正确的。 最大公因数是所有公因数的倍数的证明： 设 g=gcd(a,b)g= gcd(a,b)g=gcd(a,b)，ddd 是所有形如 ax+byax+byax+by 的正整数中最小的。 由于正整数 d=ax+by=xk1g+yk2g=g(xk1+yk2)&gt;0d=ax+by=xk_1g+yk_2g=g(xk_1+yk_2)&gt;0d=ax+by=xk1​g+yk2​g=g(xk1​+yk2​)&gt;0，那么 ggg 整除 ddd 且 g⩽dg\\leqslant dg⩽d； 设 d=ax0+by0d=ax_0+by_0d=ax0​+by0​，用 ddd 带余除任意形如 ax+byax+byax+by 的数，设为 ax+by=dq+rax+by=dq+rax+by=dq+r，那么 r=ax+by−d=a(x−qx0)+b(y−qy0)r=ax+by-d=a(x-qx_0)+b(y-qy_0)r=ax+by−d=a(x−qx0​)+b(y−qy0​)。即 rrr 也是一个形如 ax+byax+byax+by 的数。 由余数的定义，可知 0⩽r&lt;d0\\leqslant r&lt; d0⩽r&lt;d；若 r&gt;0r&gt;0r&gt;0 那么这与前述“ddd 是所有形如 ax+byax+byax+by 的正整数中最小的”相矛盾，所以 r=0r=0r=0。 即： ddd 整除任意形如 ax+byax+byax+by 的数。 因此，ddd 整除 aaa，bbb，即 ddd 是 aaa，bbb的公因数。那么， d⩽gd\\leqslant gd⩽g。 综合 g⩽dg\\leqslant dg⩽d 和 d⩽gd\\leqslant gd⩽g 有 g=d=ax+byg=d=ax+byg=d=ax+by。 可以看出 ax+byax+byax+by 可以被 aaa，bbb 的每一个公因数整除，因此，最大公因数是所有公因数的倍数。 得证。 扩展欧几里得算法与其证明 欧拉函数与欧拉定理 欧拉函数 如果两个正整数，除了 1 以外，没有其他公因数，我们就称这两个数是互质关系。两个数互质，不说明两个数是质数。 给定一个数 nnn，求出在小于 nnn 的数中有多少个与 nnn 互质，这就是欧拉函数 φ(n)\\varphi (n)φ(n)。 在欧拉函数的第一步中，我们就计算了 nnn 的欧拉函数值 φ(n)=(p−1)(q−1)\\varphi (n)=(p-1)(q-1)φ(n)=(p−1)(q−1)。 欧拉函数函数式的推导： 分情况讨论： n=1：φ(1)=1\\varphi(1) =1φ(1)=1。1 与任何数都互质。 n 为质数：φ(n)=n−1\\varphi(n) =n-1φ(n)=n−1。不难想到，互质的两个数中，若大的为质数，那么二者必然互质，因为质数只有两个因数。 n=pk (k&gt;0)n = p^k\\ (k&gt;0)n=pk (k&gt;0)，即 nnn 是一质数 ppp 的某一次方幂： φ(n)=pk−pk−1=pk(1−1p)\\begin{aligned} \\varphi(n) &amp;=p^k-p^{k-1}\\\\ &amp;= p^k(1-\\frac{1}{p}) \\end{aligned} φ(n)​=pk−pk−1=pk(1−p1​)​ 这是因为小于 pkp^kpk 的数中，1×p,2×p…pk−1×p1\\times p,2\\times p\\dots p^{k-1}\\times p1×p,2×p…pk−1×p 共计 pk−1p^{k-1}pk−1 个数都有质数 ppp 做因数，需要剔除。 第二种情况是第三种情况的特殊情况。 n=p1×p2n = p_1\\times p_2n=p1​×p2​，即 nnn 是两互质整数的积： φ(n)=φ(p1)φ(p2)\\varphi(n) =\\varphi(p_1)\\varphi(p_2) φ(n)=φ(p1​)φ(p2​) 证明需要用到中国剩余定理。 nnn 是一般的正整数，通过质因数分解，其可以化为 n=p1k1p2k2p3k3…pmkmn=p_1^{k_1}p_2^{k_2}p_3^{k_3}\\dots p_m^{k_m}n=p1k1​​p2k2​​p3k3​​…pmkm​​。那么有： φ(n)=φ(p1)φ(p2)⋯φ(pm) (情况4)=p1k1p2k2…pmkm×(1−1p1)(1−1p2)⋯(1−1pm) (情况3)=n(1−1p1)(1−1p2)⋯(1−1pm)\\begin{aligned} \\varphi(n) &amp;= \\varphi(p_1)\\varphi(p_2)\\cdots\\varphi(p_m)\\ (情况4)\\\\ &amp;= p_1^{k_1}p_2^{k_2}\\dots p_m^{k_m}\\times(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m})\\ (情况3)\\\\ &amp;=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m}) \\end{aligned} φ(n)​=φ(p1​)φ(p2​)⋯φ(pm​) (情况4)=p1k1​​p2k2​​…pmkm​​×(1−p1​1​)(1−p2​1​)⋯(1−pm​1​) (情况3)=n(1−p1​1​)(1−p2​1​)⋯(1−pm​1​)​ 欧拉定理（不证） 有了欧拉函数，我们可以有欧拉定理，对于互质的两个数 a,na,na,n： aφ(n)≡1mod (n)a^{\\varphi(n)}\\equiv 1\\mod(n) aφ(n)≡1mod(n) 若 a,pa,pa,p 互质，那么有 ap−1≡1mod (n)a^{p-1}\\equiv 1\\mod(n) ap−1≡1mod(n) 这就是费马小定理 欧拉定理这里不证。 RSA 的有效性证明 为什么 RSA 这样进行加密可以保证解密后一定是原文？下面给出证明。 根据【加密】一节，可以知道，密文 ccc 和mem^eme 之间差距为若干个 nnn: c=me+knc= m^e+kn c=me+kn 代入【解密】中的公式，有： (me+kn)d≡mmod (n)(m^e+kn)^d\\equiv m \\mod(n) (me+kn)d≡mmod(n) 左侧多项式展开后，所有含 knknkn 的项都可被 nnn 整除，不影响余数。于是等价为： med≡mmod (n)m^{ed}\\equiv m\\mod(n) med≡mmod(n) 根据【密钥生成】中第四步的公式 d⋅e+k⋅φ(n)=1d\\cdot e+ k\\cdot\\varphi(n)=1d⋅e+k⋅φ(n)=1 （为避免歧义，将 φ(n)\\varphi(n)φ(n) 的系数换了字母）代换： m1−kφ(n)≡mmod (n) ⟹ m⋅mφ(n)−k≡mmod (n)\\begin{aligned} m^{1-k\\varphi (n)}&amp;\\equiv m\\mod(n)\\\\ \\implies m\\cdot {m^{\\varphi (n)}}^{-k}&amp;\\equiv m\\mod(n) \\end{aligned} m1−kφ(n)⟹m⋅mφ(n)−k​≡mmod(n)≡mmod(n)​ 此时分情况讨论： m,nm,nm,n 互质，根据欧拉定理就有 mφ(n)≡1mod (n)m^{\\varphi(n)}\\equiv 1\\mod(n)mφ(n)≡1mod(n)，将 mφ(n)m^{\\varphi(n)}mφ(n) 代入就得证。 m,nm,nm,n 不互质。而 nnn 是两大素数的乘积，那么 mmm 的因子中必然有 p,qp,qp,q 中的一个而与另一个互质。假设 m,nm,nm,n 公因子为 ppp，mmm 与 qqq 互质，有： 两个素数不可能同时为公因子，这意味着 mmm 不小于 nnn，那么就无法正确【解密】了。 根据费马小定理： mφ(q)≡1mod (q)m^{\\varphi(q)}\\equiv 1\\mod(q) mφ(q)≡1mod(q) 于是根据欧拉函数以及前面提到的 d⋅e+k⋅φ(n)=1d\\cdot e+ k\\cdot\\varphi(n)=1d⋅e+k⋅φ(n)=1 推出： mφ(q)≡1mod (q)mq−1≡1mod (q)(mq−1)−k(p−1)≡1mod (q)m−kφ(n)≡1mod (q)med−1≡1mod (q)\\begin{aligned} m^{\\varphi(q)}&amp;\\equiv 1\\mod(q)\\\\ m^{q-1}&amp;\\equiv 1\\mod(q)\\\\ {(m^{q-1})}^{-k(p-1)}&amp;\\equiv 1\\mod(q)\\\\ {m^{-k\\varphi(n)}}&amp;\\equiv 1\\mod(q)\\\\ m^{ed-1}&amp;\\equiv 1\\mod(q)\\\\ \\end{aligned} mφ(q)mq−1(mq−1)−k(p−1)m−kφ(n)med−1​≡1mod(q)≡1mod(q)≡1mod(q)≡1mod(q)≡1mod(q)​ 于是设 m=r⋅pmed−1=t⋅q+1m = r\\cdot p\\\\ m^{ed-1}=t\\cdot q+1 m=r⋅pmed−1=t⋅q+1 那么 med−1=tq+1med=tq⋅m+mmed=tq⋅(r⋅p)+mmed=tr⋅pq+mmed=tr⋅n+m ⟹ med≡mmod (n)\\begin{aligned} m^{ed-1}&amp;= tq+1\\\\ m^{ed}&amp;= tq\\cdot m+m\\\\ m^{ed}&amp;= tq\\cdot (r\\cdot p)+m\\\\ m^{ed}&amp;= tr\\cdot pq+m\\\\ m^{ed}&amp;= tr\\cdot n+m\\\\ \\implies m^{ed}&amp;\\equiv m \\mod(n)\\\\ \\end{aligned} med−1medmedmedmed⟹med​=tq+1=tq⋅m+m=tq⋅(r⋅p)+m=tr⋅pq+m=tr⋅n+m≡mmod(n)​ 得证。","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"}]},{"title":"配置 WSL 与 WSA","slug":"配置WSL与WSA","date":"2023-12-10T09:40:37.000Z","updated":"2024-01-05T20:03:15.190Z","comments":true,"path":"post/20231210174037.html","permalink":"http://example.com/post/20231210174037.html","excerpt":"前言 其实很久之前配过，但是有奇奇怪怪的问题，也没有完全搞懂，干脆重新配了一遍。","text":"前言 其实很久之前配过，但是有奇奇怪怪的问题，也没有完全搞懂，干脆重新配了一遍。 WSL 的配置 首先为啥要搞 WSL： 好玩； 一个更方便也更有更强性能的 linux 系统，例如可以使用 Terminal 应用统一管理 shell。 我会使用目前最新的 Windows 11 配置 WSL 2，这也是目前主流的 WSL，如果你想了解 WSL 1，请参考官方文档。 下面是具体步骤。 安装 WSL 打开Terminal，使用命令 wsl --install 安装默认最新的 Ubuntu，或者直接的 Microsoft Store 搜索对应发行版安装需要的版本即可。 如果是想要安装其它的发行版本，使用 wsl --list --online 检查可用的官方发行版，然后用 wsl --install -d &lt;DistroName&gt; 安装对应的发行版。 如果有之前搞崩的了的版本需要卸载，需要使用 wsl --unregister &lt;DistributionName&gt;，才能清楚所有个人信息，直接在 windows 中卸载是不会删除个人数据的。 然后你就得到了一个崭新的 Ubuntu。输入账号密码即可创建你的账户。 Terminal 启动会自动登录该账户，所以我不建议你设一个巨复杂的密码。毕竟如果是不常用很容易忘，而且要安全你应该首先就不应该让别人接触到你的 Windows 账户。 此后，Terminal 中输入 WSL/Ubuntu或直接在开始菜单中输入上述字符串都可以直接启动 WSL 了。 配置 WSL 使用 sudo apt update &amp;&amp; sudo apt upgrade 更新包； 使用 git --version 检查是否有 git，现在应该是自带的； VSCode“远程”连接到WSL：在 VSCode 中安装 Remote Development 扩展包，然后在 VSC 命令面板选择连接到 WSL，即可在 VSC 中打开 WSL 文件夹进行开发等操作。也可以在 WSL 的对应路径下输入 code .，VSC 会自动启动并连接到 WSL 定位到该目录下。把后面的 . 换成对应的相对路径也是可行的。 安装一些 GUI 应用： 文本编辑器 gnome-text-editor：sudo apt install gnome-text-editor -y 文件管理器 nautilus：sudo apt install nautilus -y 火狐浏览器：sudo apt install firefox 安装后可能会出现闪屏的现象，一开始以为是驱动的问题，不过驱动实际上是不需要动或者说动不了的，重启一下就好了。 安装中文字体，不然无法显示: sudo apt-get install fonts-wqy-microhei # 安装文泉驿微米黑字体 sudo apt-get install fonts-wqy-zenhei # 安装文泉驿正黑字体 sudo apt-get install xfonts-wqy # 安装文泉驿点阵宋体 设置代理，也许你能参考为 WSL2 一键设置代理 - 知乎，但是我使用 Clash 是目前没有配成功。 基本上你可以完全参考 适用于 Linux 的 Windows 子系统文档 | Microsoft Learn 中从“概述”到“教程”这几节的东西完成配置，只不过中文本地化的问题会有些麻烦。而且我目前没找到中文输入的手段，只不过由于能直接 Windows 复制粘贴到 WSL，这也就是一个麻烦，不至于成为无法完成的事情。 WSA 的配置 WSA 使用 Amazon Appstore （而不是Google Play）作为官方应用商店，直接在 Microsoft Store 中搜索 Amazon Appstore 进行下载即可自动安装。 由于 Amazon Appstore 相当垃圾，不仅需要美区 Amazon 号还 app 数量少，所以可以考虑下面的方法启动侧载。 首先在 Windows Subsystem for Android 中高级设置中启用开发者模式，点击管理开发者选项启用USB 调试。在 Windows Terminal中输入adb devices 检查现在是否有被 adb 连接的设备。你也可以直接通过 adb 安装 app，但是更方便的办法是通过软件完成。在 Microsoft Store 中下载 WSATools 或者其它类似的软件，启动并选择对应的应用 apk 就可以进行安装了。这样的安装本质也是通过 adb 的，因此你可能需要在弹窗中授予权限。 这部分写得很简略是因为我 WSA 重新配置的过程比较简单，如果你想要更细致的教程，这里是我参考的文章： 【微软官方】如何安装WSA（附通过ADB安装应用） - 知乎 此外，你也许也需要下面两个文档： 适用于 Android™️ 的 Windows 子系统 | Microsoft Learn Android 调试桥 (adb) | Android 开发者 | Android Developers 我不是 Android 开发者，WSA 对我最主要的应用是游戏挂机，现在手游的空间对对我的 128G 千元机实在有些艰巨。几个月前，WSA 出现了奇妙的问题导致游戏无法正常更新，于是催生我一口气干脆把 WSA 和 WSL 重新配了一遍。其实不难，但是我还是了一点感悟，那就是重装是真有用啊。WSA 游戏无法正常更新（但是网易云app 可以正常联网）的 bug 在重装 WSA 后就轻松消失了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"WSA","slug":"WSA","permalink":"http://example.com/tags/WSA/"},{"name":"配置环境","slug":"配置环境","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"给Obsidian搭建自己的云同步服务","slug":"给Obsidian搭建自己的云同步服务","date":"2023-12-03T09:33:12.000Z","updated":"2024-01-04T08:28:56.051Z","comments":true,"path":"post/20231203173312.html","permalink":"http://example.com/post/20231203173312.html","excerpt":"前言 阿里云服务器 + docker + self-hosted Sync 插件给 Obsidian 搭建实时同步服务。","text":"前言 阿里云服务器 + docker + self-hosted Sync 插件给 Obsidian 搭建实时同步服务。 前几天准备给自己的武汉之旅写一篇很————长————的回忆记，但是这篇后来发现超过 5000 字的文章要是用手机码就麻烦了。原先 Obsidian 在我手里的定位就是手机便签加强版，根本没有考虑过同步的功能，现在为了写这个游记，只好开始想办法进行同步了。于是最后我就找到了博主&quot;吕楪&quot;的这一篇：Obsidian免费的实时同步服务。 很不幸，由于 fly.io 的政策改动，现在（2023年12月3日）它必须要求你有一个信用卡（而且非双币卡我怀疑不能认可），而且根据评论区消息，他们需要 $2/月 购买 IPv4 地址才能提供服务。既然如此，那么就不如自己在国内搞一个服务器了。 阿里云的学生福利允许通过任务最高领取 7 个月的免费 2 核 2G 服务器，即使不是学生，现在（2023年12月3日）腾讯云和阿里云也都有 100 元左右的 2 核 2G 服务器可以优惠购买。尽管这个价格和官方服务是差不多价格的，但是同步服务占用不大，因此性价比会比官方服务高很多。毕竟还可以跑其他的小东西玩呢。因此，我最后决定使用阿里云的云服务器部署同步服务，实现了 Windows + 安卓的实时同步功能。 下面正式开始论述步骤。 在开始配置同步前，最好将其它的同步插件（含官方插件），以及 Onedrive 等同步方式关闭，避免冲突问题。 配置服务器 我们的目标是在服务器上运行一个 CouchDB 数据库。 CouchDB 是 Apache 开发的一个开源 NoSQL 数据库，它使用 JSON 文档存储数据，通过 web 访问，使用JavaScript查询、合并和转换文档。 首先，你需要有一个服务器。我的意思是，像腾讯云 Cloudbase 云开发这样的 Serverless 产品，后台是腾讯云内建的数据库，需要通过 API 读写，就应该是不行的。（为什么我会知道这个呢） 参考云服务器的官方文档（可参见文末参考部分），连接到服务器，我这里使用的是 Workbench，主要是这个连接方式支持复制粘贴并且无需下载客户端。 随后参考另一篇云服务器官方文档（下述文档等均可参见文末参考部分），安装 Docker 和 docker-compose。 在 livesync 的官方文档中说道，“设置 CouchDB 的最简单方法是使用 CouchDB docker image”，并且推荐使用同时启动 Caddy 和 CouchDB 的另一方法。因此，这里安装了 Docker 和 docker-compose。 在服务器上，使用 mkdir 命令在合适的地方创建一个文件作为 CouchDB 容器的数据文件夹。在该文件夹下，使用 touch 命令创建一个名为 local.ini 的文件，这是要修改数据库以让它可以用于 Self-hosted LiveSync。使用 vim 或任何其他编辑器打开并粘贴以下内容： 12345678910111213141516171819202122[couchdb]single_node=truemax_document_size = 50000000[chttpd]require_valid_user = truemax_http_request_size = 4294967296[chttpd_auth]require_valid_user = trueauthentication_redirect = /_utils/session.html[httpd]WWW-Authenticate = Basic realm=&quot;couchdb&quot;enable_cors = true[cors]origins = app://obsidian.md,capacitor://localhost,http://localhostcredentials = trueheaders = accept, authorization, content-type, origin, referermethods = GET, PUT, POST, HEAD, DELETEmax_age = 3600 再在该文件夹下创建一个 docker-compose.yml 文件，打开，贴入以下内容 123456789101112131415version: &quot;2.1&quot;services: couchdb: image: couchdb container_name: obsidian-livesync user: 1000:1000 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=password volumes: - ./data:/opt/couchdb/data - ./local.ini:/opt/couchdb/etc/local.ini ports: - 5984:5984 restart: unless-stopped ❗请根据需要修改文中 ./local.ini 、environment 以及 container_name ，的值。 运行下面这个命令 1docker compose up -d docker 就会自动拉取 couchDB 镜像并配置好。 运行下面这个命令，检查容器是否已经开始运行 1docker ps 如果看到了前面设置的 container_name ，那么容器已经在运行了。由于服务器没有图形化窗口，这里需要转到阿里云的实例的安全组中， 给“入方向”添加 5984 端口，允许外界访问服务器的 5984 端口。 下面转到本地操作。 在网页端创建数据库 在 PC 上访问 http://[你的服务器公网IP]:5984/_utils。你应该就能看见图形化界面了。 如果拒绝访问，你可能需要写成这种形式http://[你的用户名]:[你的密码]@[你的服务器公网IP]:5984/_utils。这里的用户名和密码都是前面的 docker-compose.yml 中设置的。 点击网页右上角的 Create Database，创建一个数据库，其中 Database name 为数据库名字，Partitioned 不应该被勾选，然后点 Create 创建。 接着点开图标为扳手🔧的 Setup 选项卡，依次填入上述配置的管理员姓名和密码凭据，Bind address 一栏应保持为 0.0.0.0 才能允许所有的 IP 访问，最后，端口写 5984。 最后，点开齿轮⚙️图标的 Config 选项卡，点选 CORS，启用，允许直接从浏览器连接到远程服务器并与 CouchDB 对话以加载数据。 页面可能会提示报错，你需要刷新页面检查确实是启用并设置为 All domains 的就可以。 配置 Obsidian 在 Obsidian 本体软件中关闭安全模式，安装插件 Self-hosted LiveSync 并启用。 打开卫星图标🛰️的 Remote Database configuration 选项卡。输入自己的数据库网址、用户名、密码与数据库名。数据库网址形如：http://[你的服务器IP地址]:5984，用户名、密码与数据库名都是在上一节数据库网页设定的。 点击 Test Database Connection，若连接成功，则会提示 connected，否则，会提示那些步骤存在问题，按描述检查即可。 打开循环图标🔁的 Sync Settings 选项卡，将 Sync Mode 调整为 Live Sync，这样就是实时的同步，而非定时或定节点的保存。 一些建议设置： 在 Sync Settings 选项卡中启用 Use Trash for deleted files，启用回收站而非直接删除； 在齿轮图标⚙️的 General Settings中，检查启用 Show staus inside editor 💤：表示目前一切就绪 ⚡：表示正在同步 ⚠️：同步出现错误 ↑和↓：表示本次启动以来上传和下载了多少数据 其它的图标感觉都不大容易碰到，这里略过。 在卫星图标🛰️的 Remote Database configuration 选项卡中的 Confidentiality 启用端到端加密和路径混淆（Path Obfuscation）并配置加密密码，保护数据。（可能会导致重建数据库） 配置第二台设备 继续在上述已经配好的设备的 LiveSync插件上，点选魔法师图标的🧙 Setup Wizard选项卡，点选Copy Setup URI，输入一个加密密码，生成口令。将其发送到我们需要设置的另一设备。 在第二台设备（例如安卓手机）上，打开同样的选项卡，点击Open Setup URI，依次输入口令和加密码进行解密。选择“将其设置为第二或后续设备”，最后同样点击 Test Database Connection 检查确实已经连接成功即可。 接下来就可以通过创建文件，打几段话试试同步效果，最后继续写作之旅了。 参考和推荐阅读 本文的主要参考对象，吕楪的博客，有一些细节比本文更丰富（毕竟中译中就没意思了）：Obsidian 免费的实时同步服务 插件官方提供的设置 CouchDB 教程（顺便一提官方的其它中文文档也值得一看）：obsidian-livesync/docs/setup_own_server_cn.md at main · vrtmrz/obsidian-livesync 如果你想了解其它的同步方式，同样是吕楪大佬的：Obsidian 各种同步方式体验 另一篇关于 Obsidian 不同同步方式的文章：Obsidian 免费同步方案 - 知乎 了解如何连接到服务器（阿里云）：云服务器ECS连接方式介绍与对比_云服务器 ECS-阿里云帮助中心 在阿里云（CentOS 或 Alibaba Cloud Linux）云服务器上安装 Docker：安装Docker并使用_云服务器 ECS-阿里云帮助中心","categories":[],"tags":[{"name":"Obsidian","slug":"Obsidian","permalink":"http://example.com/tags/Obsidian/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"数据库大作业：公交管理系统","slug":"课程报告/数据库大作业：公交管理系统","date":"2023-11-12T10:13:07.000Z","updated":"2024-01-03T17:08:23.886Z","comments":true,"path":"post/20231112181307.html","permalink":"http://example.com/post/20231112181307.html","excerpt":"前言 因为在复习数据库，整理下大三数据库大作业。","text":"前言 因为在复习数据库，整理下大三数据库大作业。 环境配置 需要一个简单的前端，这里使用的是 python38 + Flask(简单的 web 框架) + psycopg2(PostgreSQL 数据库适配器) ，这就没什么好说的了。对应有一小段 python 代码和 html，css 代码，我前端苦手，这些前端功能是直接拿的同学的，因此这里也不多谈。python 代码可以见后。 当然需要一个数据库软件，我们选择的是 PostgreSQL。参考 Windows 10平台安装PostgreSQL 14.2详细教程 - 知乎 就行。在我重新完善这个实验的时候，使用的版本是 16。下面阐述一些细节。 安装过程中我遇到了上述链接阐述的初始化失败的问题，可以安装上述博主提供的命令行代码手动初始化即可。 在网上的教程中，往往是使用 psql 命令行交互，不过，事实上 PostgreSQL 包含一个名为 pgAdmin 的可视化窗口，因此我就直接使用了可视化操作进行了。 在我的电脑上，PostgreSQL 服务器不会自启动，也无法在 service 中找到，因此我需要通过命令手动启动服务器： 1./bin/pg_ctl.exe -D &quot;C:\\\\PostgreSQLDataArea&quot; start 其中，第一个地址是指定软件安装目录下的 pg_tcl.exe, 第二个目录则是指明服务器数据的存放地址，默认是安装目录下 data 文件夹，但是我给它改了。如果你的 pg_ctl 被包含在了环境目录中，那么第一串就可以直接写成 pg_ctl。 启动服务器后就可以在 pgAdmin 中去连接服务器，创建数据库了。 设计数据库 显然这一步才是整个作业的关键 首先回顾作业的要求： 公交车公司架构如下： 公交公司有若干个【车队】，每个【车队】下有若干条【线路】; 公交公司有若干辆【汽车】，每辆【车】属于一条【线路】; 每个【车队】有一名【队长】，他只有管理工作，不开车; 每条【线路】有若干名【司机】；每名【司机】只在一条【线路】上开车; 【司机】开车时会产生【违章】，包含: 闯红灯、未礼让斑马线、压线、违章停车等; 【队长】、【路队长】负责将司机的违章信息输入到系统，包含: 司机、车辆、车队、线路、站点、时间、违章等 公交公司管理系统要求功能如下： 录入司机信息 录入汽车信息 录入违章信息 查询车队拥有的司机 查询时间段内实际信息 查询车队违章信息 对此，数据库的结构大体思路如下： 有车队、线路、站点、汽车、员工等表存储信息，有“违章类型表”和“违章信息表”表示违章信息。特别地，线路和站点之间是多对多的关系，而且有顺序要求，因此我们还要建立一个“线路-站点”关联表。具体的 SQL 语句见后。 接下来对数据库进行范式分析： 1NF：属性不可被分解。不满足 1NF 就不是数据库，因此我们的数据库显然是满足的； 2NF：非主属性完全依赖主键。满足。 3NF：非主属性不存在传递依赖。满足。 BC范式：主属性没有传递依赖和部分依赖。满足。 代码 建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109-- 汽车表CREATE TABLE &quot;buses&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;number&quot; varchar(16) UNIQUE, &quot;route_id&quot; int4, &quot;capacity&quot; int4 NOT NULL, CHECK (number SIMILAR TO &#x27;[京津冀晋蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][A-HJ-NP-Z][A-HJ-NP-Z0-9]&#123;5,6&#125;&#x27;) -- 检查车牌号格式);-- 车队表CREATE TABLE &quot;fleets&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;leader_id&quot; int4 NOT NULL);-- 违章类型表CREATE TABLE &quot;offence_types&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;type&quot; varchar(255) NOT NULL UNIQUE);-- 路线表CREATE TABLE &quot;routes&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;leader_id&quot; int4 UNIQUE, &quot;fleet_id&quot; int4);-- 站点表CREATE TABLE &quot;stops&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;name&quot; varchar(255) NOT NULL UNIQUE);-- 路线-站点表CREATE TABLE &quot;route-stops&quot; ( &quot;route_id&quot; int4 NOT NULL, &quot;order&quot; int4 NOT NULL, &quot;stop_id&quot; int4 NOT NULL, PRIMARY KEY (&quot;route_id&quot;, &quot;order&quot;));-- 员工表CREATE TABLE &quot;workers&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;name&quot; varchar(255) NOT NULL, &quot;gender&quot; varchar(2) NOT NULL, &quot;is_driver&quot; bool NOT NULL DEFAULT false, &quot;route_id&quot; int4, CHECK (gender = &#x27;男&#x27; or gender = &#x27;女&#x27;));-- 违章表CREATE TABLE &quot;offences&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;driver_id&quot; int4 NOT NULL, &quot;time&quot; timestamp NOT NULL, &quot;bus_id&quot; int4 NOT NULL, &quot;stop_id&quot; int4 DEFAULT NULL, &quot;offence_type_id&quot; int4 NOT NULL);-- 外键ALTER TABLE buses ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE fleets ADD FOREIGN KEY (leader_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (offence_type_id) REFERENCES offence_types (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (driver_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (bus_id) REFERENCES buses (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (stop_id) REFERENCES stops (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE routes ADD FOREIGN KEY (leader_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE routes ADD FOREIGN KEY (fleet_id) REFERENCES fleets (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE &quot;route-stops&quot; ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE SET NULL;ALTER TABLE &quot;route-stops&quot; ADD FOREIGN KEY (stop_id) REFERENCES stops (id) ON DELETE SET NULL ON UPDATE SET NULL;ALTER TABLE workers ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE CASCADE;-------- 视图 ---------- 不同车队的驾驶员基本信息CREATE VIEW &quot;fleet-driver&quot;(fleet_id, driver_id, driver_name, driver_gender)ASSELECT fleets.id, workers.id, workers.name, workers.genderFROM fleets INNER JOIN routes ON fleets.id = routes.fleet_id INNER JOIN workers ON routes.id = workers.route_idWHERE workers.is_driver;-- 不同驾驶员的违章信息CREATE VIEW &quot;driver-offence&quot;(driver_id, offence_time, bus_number, stop_name, offence_type, offence_id)ASSELECT offences.driver_id, offences.time, buses.number, stops.name, offence_types.type, offences.idFROM offences INNER JOIN buses ON offences.bus_id = buses.id INNER JOIN stops ON offences.stop_id = stops.id INNER JOIN offence_types ON offences.offence_type_id = offence_types.id;-- 不同车队的违章信息CREATE VIEW &quot;fleet-offence&quot;(fleet_id, offence_time, offence_type)ASSELECT &quot;fleet-driver&quot;.fleet_id, offences.time, offence_types.typeFROM offences INNER JOIN offence_types ON offences.offence_type_id = offence_types.id INNER JOIN &quot;fleet-driver&quot; ON offences.driver_id = &quot;fleet-driver&quot;.driver_id; python 前端 访问 localhost:5000/BusCompanyManage 网站即可，注意修改 python 代码中的数据库用户名、密码等信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#! python3.8import tracebackfrom flask import Flask, render_template, requestimport psycopg2# 连接数据库conn = psycopg2.connect( database=&#x27;bus_company_db&#x27;, user=&#x27;postgres&#x27;, password=&#x27;password&#x27;, host=&#x27;127.0.0.1&#x27;, port=&#x27;5432&#x27;)# 数据库操作游标cur = conn.cursor()def queryDb(sql: str): &#x27;&#x27;&#x27; 通过SQL语句查询数据库，返回查询结果。 &#x27;&#x27;&#x27; cur.execute(sql) conn.commit() return cur.fetchall()def modifyDb(sql: str): &#x27;&#x27;&#x27; 通过SQL语句修改数据库。 &#x27;&#x27;&#x27; cur.execute(sql) conn.commit() def insertDriver(form): &#x27;&#x27;&#x27; 录入司机基本信息，如工号、姓名、性别等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO workers(name, gender, is_driver, route_id) VALUES(&#x27;&#123;form[&#x27;name&#x27;]&#125;&#x27;, &#x27;&#123;form[&#x27;gender&#x27;]&#125;&#x27;, TRUE, &#123;form[&#x27;route_id&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM workers ORDER BY id DESC;&#x27; return queryDb(sql)def insertBus(form): &#x27;&#x27;&#x27; 录入汽车基本信息，如车牌号、座数等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO buses(number, route_id, capacity) VALUES(&#x27;&#123;form[&#x27;number&#x27;]&#125;&#x27;, &#123;form[&#x27;route_id&#x27;]&#125;, &#123;form[&#x27;capacity&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM buses ORDER BY id DESC;&#x27; return queryDb(sql)def insertOffence(form): &#x27;&#x27;&#x27; 录入司机的违章信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO offences(driver_id, time, bus_id, stop_id, offence_type_id) VALUES(&#x27;&#123;form[&#x27;driver_id&#x27;]&#125;&#x27;, &#x27;&#123;form[&#x27;time&#x27;]&#125;&#x27;, &#123;form[&#x27;bus_id&#x27;]&#125;, &#123;form[&#x27;stop_id&#x27;] or &#x27;NONE&#x27;&#125;, &#123;form[&#x27;offence_type_id&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM offences ORDER BY id DESC;&#x27; return queryDb(sql)def queryFleetDrivers(form): &#x27;&#x27;&#x27; 查询某个车队下的司机基本信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT driver_id, driver_name, driver_gender FROM &quot;fleet-driver&quot; WHERE fleet_id = &#123;form[&#x27;fleet_id&#x27;]&#125;;&#x27;&#x27;&#x27; return queryDb(sql)def queryDriverOffences(form): &#x27;&#x27;&#x27; 查询某名司机在某个时间段的违章详细信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT offence_time, bus_number, stop_name, offence_type, offence_id FROM &quot;driver-offence&quot; WHERE driver_id = &#123;form[&#x27;driver_id&#x27;]&#125; AND offence_time BETWEEN &#x27;&#123;form[&#x27;start_time&#x27;]&#125;&#x27; AND &#x27;&#123;form[&#x27;end_time&#x27;]&#125;&#x27;;&#x27;&#x27;&#x27; return queryDb(sql)def queryFleetOffences(form): &#x27;&#x27;&#x27; 查询某个车队在某个时间段的违章统计信息，如：2次闯红灯、4次未礼让斑马线等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT offence_type, COUNT(*) FROM &quot;fleet-offence&quot; WHERE fleet_id = &#123;form[&#x27;fleet_id&#x27;]&#125; AND offence_time BETWEEN &#x27;&#123;form[&#x27;start_time&#x27;]&#125;&#x27; AND &#x27;&#123;form[&#x27;end_time&#x27;]&#125;&#x27; GROUP BY offence_type;&#x27;&#x27;&#x27; return queryDb(sql)actionTypes = &#123; &#x27;ins-driver&#x27;: [insertDriver, [&#x27;编号&#x27;, &#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;是否为司机&#x27;, &#x27;路线编号&#x27;]], &#x27;ins-bus&#x27;: [insertBus, [&#x27;编号&#x27;, &#x27;车牌号&#x27;, &#x27;路线编号&#x27;, &#x27;载客量&#x27;]], &#x27;ins-offence&#x27;: [insertOffence, [&#x27;司机编号&#x27;, &#x27;时间&#x27;, &#x27;车辆编号&#x27;, &#x27;站点编号&#x27;, &#x27;违章类型号&#x27;, &#x27;违章编号&#x27;]], &#x27;qry-fleet-driver&#x27;: [queryFleetDrivers, [&#x27;编号&#x27;, &#x27;姓名&#x27;, &#x27;年龄&#x27;]], &#x27;qry-driver-offence&#x27;: [queryDriverOffences, [&#x27;违章时间&#x27;, &#x27;车牌号&#x27;, &#x27;站点&#x27;, &#x27;违章类型&#x27;, &#x27;编号&#x27;]], &#x27;qry-fleet-offence&#x27;: [queryFleetOffences, [&#x27;类型&#x27;, &#x27;次数&#x27;]]&#125;app = Flask(__name__)@app.route(&#x27;/BusCompanyManage&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def manage(): msg = None thead = None tbody = None try: if request.method == &#x27;GET&#x27;: msg = &#x27;欢迎来到公交安全管理系统。&#x27; elif request.method == &#x27;POST&#x27;: msg = &#x27;提交成功！&#x27; form = request.form action = form[&#x27;type&#x27;] tbody = actionTypes[action][0](form) thead = actionTypes[action][1] except Exception: msg = traceback.format_exc() return render_template( &#x27;index.html&#x27;, msg=msg, thead=thead, tbody=tbody )if __name__ == &#x27;__main__&#x27;: app.run(debug=True)","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大作业","slug":"大作业","permalink":"http://example.com/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"A 测实验：湿度测控系统仿真 / 嵌入式","slug":"课程报告/A测：湿度测控仿真","date":"2023-10-05T15:35:20.000Z","updated":"2024-01-03T17:08:04.652Z","comments":true,"path":"post/20231005233520.html","permalink":"http://example.com/post/20231005233520.html","excerpt":"前言 A 测实验报告，实现一个根据湿度控制电机转动的简单嵌入式系统的仿真。此前没有接触过嵌入式，这也是我对嵌入式的初步认识。","text":"前言 A 测实验报告，实现一个根据湿度控制电机转动的简单嵌入式系统的仿真。此前没有接触过嵌入式，这也是我对嵌入式的初步认识。 实验要求 使用 Arduino UNO 微控制器，搭建一个 PC 上位机远程湿度检测控制系统。 具体来说功能可以分为如下两部分： 通信：串口和 Arduino UNO 系统双工通信。我们操作通过串口向仿真系统发送学号。同时，我们还可以从串口读取当前湿度。 反馈：当环境湿度低于等于预定的湿度时， Arduino UNO 启动直流电机转动；当环境湿度高于预定的湿度时，直流电机停止转动。 Arduino UNO 还会在 LCD 屏上显示之前输入的学号和湿度。 上述预定湿度的值为百分之“30+学号末位数”。 软件环境：推荐采用 Proteus 8.9 SP2 及以上仿真软件，Arduino IDE，串口调试助手软件，虚拟串口驱动软件 Virtual Serial Port Driver（VSPD）。 所谓微控制器，是一个高度集成的芯片，内部有 CPU 、内存等等，对外则提供各类接口，单片机也是一种微控制器，而 Arduino UNO 微控制器的核心是一个 Atmega328P 单片机。 Arduino 平台也有对应的软件开发工具，例如官方的 Arduino IDE。采用 VSC 等当然也可以，不过我们只是做一次作业，也就不花心思在如何配环境了。总之，透过这些软件，我们可以编写代码输送到开发板（此处是 Arduino UNO）中去执行。 而上述提到的串口则是“串行端口”的意思，具体来说，我们这里指的是 COM 口，即 Commuinication Port。串口通信较为简单而稳定。 整体系统框图如下： 实验环境 Windows 11 个人电脑 Proteus 8.9 SP2：仿真软件，老师提供的电路就是 Proteus 工程文件。 XCOM 2.0：用来在串口上进行通信的； VSPD 7.2.308：Virtual Serial Port Dirver，用来创建虚拟一对端口的，因为我们的微控制器是虚拟的，所以与之通信的串口也是虚拟的； Arduino 1.8.19：给 Arduino 开发板编写程序的 IDE；这里需要注意版本问题，官网的 2.x 版本似乎是无法看到 VSPD 创建的虚拟端口的； DHT 11 库：DHT 11 数字温湿度传感器配套的库，因为我们是在 Arduino 平台进行开发，因此需要对应的在 Arduino 平台的库，在这里我采用的是 Github 上找的 adidax/dht11: DHT11 library for Arduino。 操作步骤 环境配置，安装上述软件，并将 DHT 11 库添加到 Arduino IDE 中。其中 Proteus 需要安装在 C 盘根目录下，不然会识别不到库。 通过 VSPD 添加一对虚拟串口 COM1 和 COM2 进行虚拟串联。 XCOM 设置波特率为 9600，测试虚拟端口之间能否正常通信；并保持 COM1 为打开状态。 我们没有可以上传的真实开发板，而验证本身并不会传到开发板中，所以我们设置 Arduino IDE 的首选项（Preference），将编译和上传勾选。随后在 Arduino IDE 内编写程序并&quot;验证&quot;（程序代码见后文）。控制台会告诉我们在appdata 下的一个文件下下生成了编译文件，其中该目录下的 *.ino.hex 就是验证后编译生成的机器码文件，它就是我们要的。（注意这是临时文件，每次验证目录都会变化）。 在 Proteus U1 里指定编译生成的 .HEX 文件，P1 指定端口为 COM1。 运行仿真工程，输入学号，调节湿度，观察电机状态和 LCD 显示信息。 仿真结果 我的学号尾号为2，因此预定的湿度值是 32%。 初始状态只显示湿度值： 此时通过 XCOM（COM2） 发送学号，可以看到 LCD 显示屏上成功显示学号，并且 PC 机接收到湿度值。注意 XCOM 使用的 COM 2 而且应该处于打开状态，因为与之配对的 COM1 在模拟开发板上，我们无法通过 COM1 给COM1 自己发消息。 将设定湿度改到 32%，此时电机开始转动： 程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# include &lt;Wire.h&gt;# include &lt;dht11.h&gt; # include &lt;LiquidCrystal.h&gt; # define DHT11PIN 6# define EMPIN 7 LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // 初始化LCDdht11 DHT11;String stuID = &quot;&quot;; int len, lastNumNum = 0;int setHumidity, realHumidity = 0; void setup() &#123; Serial.begin(9600); // 初始化串口波特率为9600 lcd.begin(16, 2); pinMode(EMPIN, OUTPUT); // 设置连接直流电机引脚工作模式&#125; void loop() &#123; DHT11.read(DHT11PIN); realHumidity = (int)DHT11.humidity; lcd.print(&quot;ID:&quot;); if (Serial.available() &gt; 0) &#123; // 串口接收到数据 while (Serial.available() &gt; 0) &#123; stuID += (char)Serial.read(); delay(10); &#125; lcd.println(stuID); len = stuID.length(); lastNum = stuID.substring(len - 3, len - 2).toInt(); // 取末尾数字 setHumidity = 30 + lastNum; stuID = &quot;&quot;; len = 0; lastNum = 0; &#125; // LCD 输出 RH lcd.setCursor(0, 1); // 将光标定位在第0列，第1行（即下一列） lcd.print(&quot;RH:&quot;); lcd.print(realHumidity); lcd.println(&quot;%&quot;); lcd.home(); // 光标返回左上角 // 串口输出 RH Serial.print(&quot;Humidity:&quot;); Serial.print(realHumidity); Serial.println(&quot;%&quot;); if (realHumidity &lt;= setHumidity) &#123; digitalWrite(EMPIN, HIGH); // 电机转动 &#125; else &#123; digitalWrite(EMPIN, LOW); &#125; delay(1000);&#125; 参考 2023西电A测：湿度测控仿真系统-CSDN博客 西电A测：串口通信仿真-CSDN博客","categories":[],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"C++ STL 容器与容器适配器","slug":"C++ STL 容器简记","date":"2023-08-19T10:13:32.000Z","updated":"2024-01-03T05:40:06.642Z","comments":true,"path":"post/20230819181332.html","permalink":"http://example.com/post/20230819181332.html","excerpt":"前言 C++ STL 容器与容器适配器简记，这是一篇用法与底层实现思想的简记，不含源码解析。","text":"前言 C++ STL 容器与容器适配器简记，这是一篇用法与底层实现思想的简记，不含源码解析。 顺序容器 主要有这些： 顺序容器 arrary:定长数组 vector：动态数组 deque ：双端队列 list：双向循环链表 forward_list：单向链表 STL 库中的容器（以及 String）有一些相似的方法和特点，例如使用operator=赋值或assign()赋值，用operator==可以判相等等等，下面是一些个人觉得常见的方法。不过这些方法也并不一定是对所有容器有效，应该根据实际容器的特点来。（例如对于一个定长的array，显然我们也没办法要求 resize()或者push） 迭代器： begin()：指向开始的迭代器 end()：指向末尾的迭代器 容量： size()：当前大小 empty()：是否为空 max_size：理论上的最大大小。例如对于vector是可用 RAM 大小，对 array 则是声明的大小。 元素访问： operator[]：C风格的下标访问 at()：operator[]的不越界安全替代品 front：第一个元素 back()：最后一个元素 以及修改操作： push(_back)：压入一个元素（到尾部） pop(_back)：弹出一个元素（从尾部） emplace()：原地构造一个元素放入（对于自定义类型，避免来回构造析构不必要的临时变量） swap()：交换 insert()：在指定位置前插入元素 resize()：重整大小，小于原值就删去那些元素 clear()：清空所有 erase()：清空指定位置元素 Array 这是对 C 中的简单的 int a[] 这样的数组的替代品，提高了安全性。因此它也如原始数组一样不能变长等。 fill()：用指定元素赋值。 Vector 动态长度的数组。 在中间和前方插入值会消耗较多的时间，因为要挨个挪后面的元素。 内存结构：vector所采用的数据结构非常简单，线性连续空间（即数组），两个迭代器 Myfirst和 Mylast 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 _Myend 指向整块连续内存空间的尾端。 扩容：扩充空间是“配置新空间-数据移动-释放旧空间”的大工程,时间成本很高。因此当容器满的时候，vector 会另辟一段空间（大小为 2^N ），将旧空间的内容复制到新空间然后释放旧空间。如果容器内存放的是自定义类型，那么C++会使用 move 将所有权转移到新空间内，而不是挨个调用构造函数。 迭代失效：对 vector 的任何操作，一旦引起空间的重新分配，指向原 vector 的所有迭代器就都失效了。 Deque：双端队列 deque 容器可以对其两段的数据进行操作，支持随机访问。它不需要像 vector 那样重新配置空间来扩容，因此，deque 没有 capacity 属性，没有 reserve() 功能。 在前端插入删除和后端插入删除一样方便，但是中间会需要挪元素。 deque 容器存储数据的空间是由一段一段等长的连续空间（数组）构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。为了管理这些连续空间，deque 容器用数组存储着各个连续空间的首地址。也就是说，容器中实际存储的都是指针，指向那些真正用来存储数据的各个连续空间。 这提高了在序列两端添加或删除元素的效率，但也使容器迭代器的底层实现变得更复杂。 为了实现遍历 deque 容器的功能，deque 迭代器定义了如下的结构(迭代的是那个指针数组的元素)： 12345678template&lt;class T,...&gt;struct __deque_iterator&#123; ... T* cur; T* first; T* last; map_pointer node;//map_pointer 等价于 T**&#125; 迭代器内部包含 4 个指针，它们各自的作用为： cur：指向当前正在遍历的元素； first：指向当前连续空间的首地址； last：指向当前连续空间的末尾地址； node：指向指针数组中“指向当前连续空间的指针”。 其中： start 迭代器记录着 map 数组中首个连续空间的信息。start 迭代器中的 cur 指针指向的是连续空间中首个元素； finish 迭代器记录着 map 数组中最后一个连续空间的信息。 finish 迭代器中的 cur 指针指向的是连续空间最后一个元素的下一个位置。 1234567891011121314151617181920212223242526272829303132//当迭代器处于当前连续空间边缘的位置时，如果继续遍历，就需要跳跃到其它的连续空间中，该函数可用来实现此功能void set_node(map_pointer new_node)&#123; node = new_node;//记录新的连续空间在 map 数组中的位置 first = *new_node; //更新 first 指针 //更新 last 指针，difference_type(buffer_size())表示每段连续空间的长度 last = first + difference_type(buffer_size());&#125;//重载 * 运算符reference operator*() const&#123;return *cur;&#125;pointer operator-&gt;() const&#123;return &amp;(operator *());&#125;//重载前置 ++ 运算符self &amp; operator++()&#123; ++cur; //处理 cur 处于连续空间边缘的特殊情况 if(cur == last)&#123; //调用该函数，将迭代器跳跃到下一个连续空间中 set_node(node+1); //对 cur 重新赋值 cur = first; &#125; return *this;&#125;//重置前置 -- 运算符self&amp; operator--()&#123; //如果 cur 位于连续空间边缘，则先将迭代器跳跃到前一个连续空间中 if(cur == first)&#123; set_node(node-1); cur == last; &#125; --cur; return *this;&#125; 内存调度策略 如果 deque 数组的总空间大于目前使用空间的两倍，那么不会重新分配内存。 否则会使用 reallocate_map()函数, 空间不足时： deque空间实际足够：这种情况由总是在一个方向插值造成 deque内部进行调整 start , 和 finish 当 deque 后端缓存耗尽时， deque 会将start复制到中间； 当 deque 前端缓存耗尽时， deque 会从后往前复制，将 start 复制到中间。（如果不从后向前复制，那么 start 移动后可能会落在之前的区间内，这时进行复制会覆盖尚未被复制的后部数据）。 deque空间真的不足 申请更大的空间 拷贝元素过去 修改 map 和 start, finish 指向 如果 deque 数组总空间小于目前使用空间的两倍。那么其会根据下列公式计算扩增倍数。 1__new_size = _M_size+max(_M_size,__nodes_to_add)+2 可以看出是至少 2 倍扩容，通过比较当前 deque 数组大小与插入节点数，同时还预留一个为 2 的常数，防止频繁map的重新分配。 List：双向循环链表 list 就是一个双向循环链表，list 节点有 prev 和 next 两个指针。对于任何位置的元素插入或元素移除， list 永远是常数时间。 既然是链表，因此它有一些链表的特点 插入、接合操作，不会造成迭代器失效。即使删除操作，只有指向删除元素的那个迭代器失效。 无法随机存取，但是方便随机插入删除。 不预留空间，每分配一个就是内存中取一块地。 node 指向尾端的一个空白节点，就能符合 ”前闭后开“ 区间的要求。 Forward_list：单向链表 具有和 list 容器相同的特性，但是单链表只能从前向后遍历，而不支持反向遍历。 关联式容器 关联式容器大体可以分为 set 和 map ，有序的均是以RB-Tree（红黑树）为底层架构，无序的（ Unordered_ 前缀）以哈希表为底层架构。 set/multiset map/multimap unordered_set/map/multiset/multimap 关联容器插入删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。而是键-值映射。 除了顺序容器中提到的各种方法，关联式容器中还常有 count()：匹配指定键的元素个数。 find()：找指定键的元素。 merge()：从另一个容器合并结点。 equal_range()：等于给定键的元素范围（？）。 lower/upper_bound():首个不小于/大于指定键的元素的迭代器。（再次提醒是不小于，不是小于）。 contains()(c++20):是否包含指定键。 extract()（c++17）：从另一个容器提取结点。 Set/ Multiset：集合 元素既是键(value)又是值(value)。 键（即元素）是不可被修改的。 insert()函数插入之后会自行被排序，默认是升序 set 不可插入重复值，multiset 则可以； Map/Multimap：映射（键值对） 类比 python 中的字典，拥有键值（key）和实值（value） 所有元素都会根据键值来自动排序，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效。 map 中不允许出现重复键值， multimap 中允许。 map 重载了operator[]，但是 multimap 没有，因为键是不唯一的。 由于 map 是键值对，因此定义了 pair，这是一个有两个值的简单模板结构体。其中第一个值（键）是 const，即键无法修改，值可以修改。它还重载了 operator== 、构造等。而 map 就是一个 pair 结构的红黑树。 Unordered_xxxx 上述四种容器在 C++11 后均增加了 unordered_ 类。其与上述四种容器的区别是底层实现原理为哈希表。 这造成了两点重要影响： 不支持排序，迭代器做范围访问时效率更低（迭代器自加自减的访问效率更低）； 直接访问元素的速度更快（尤其在规模很大时），因为直接计算 key 的哈希值是O(1)复杂度。 容器适配器 容器适配器是一个封装了序列容器的一个类模板，它在一般的序列容器的基础上提供了一些不同的功能。之所以称为容器适配器，是因为它是适配容器来提供其它不一样的功能。通过对应的容器和成员函数来实现我们需要的功能 stack：栈 栈是什么就不必多说了。默认情况下 stack 底层容器是 deque 。也可以指定底层容器，标准容器 vector、deque、list 均符合需求。 stack 不提供遍历和随机访问功能，也不提供迭代器。只有 push 和 pop 操作。 queue：队列 默认情况下 queue 底层容器是 deque。 队列是一种 FIFO 的数据结构，允许从一端新增元素，从另一端移除元素。 queue不提供遍历功能，也不提供迭代器。 pripority_queue：优先队列/堆 优先队列的默认容器是 vector。 优先队列的核心特点在于其严格弱序特性（strict weak ordering）：也即 priority_queue 保证容器中的第一个元素始终是所有元素中最大的。为此，用户在实例化一个 priority_queue 时，必须为元素类型重载&lt;运算符，以用于元素排序。 更进一步的认识 更进一步当然就是需要阅读源码，除了源代码，也可以参考 一个发表于Github的源码解析文章：STL/README.md at master · FunctionDou/STL 你永远值得信任的 cppreference 老大哥： C++ 标准库 - cppreference.com","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"GAMES101-1：课程总览与笔记导航","slug":"GAMES101/GAMES101-1","date":"2023-08-15T16:26:06.000Z","updated":"2024-01-03T16:32:15.887Z","comments":true,"path":"/GAMES10101.html","permalink":"http://example.com/GAMES10101.html","excerpt":"前言 对我的 GAMES101 课程笔记的导览与最后一课的尾声小建议部分:","text":"前言 对我的 GAMES101 课程笔记的导览与最后一课的尾声小建议部分: 笔记导航 对应于 101 课程的四个板块：光栅化、几何、光线传播和动画模拟。标题是于原课程一一对应的。 其中： 笔记 2：回顾了矩阵的基本运算，叉积（判断向量的左右关系，右手定则）和点积（判断两个向量相似程度）。 笔记 3 ~ 10：光栅化： 3：对模型进行 M 变换，摆在空间中； 4：对模型 VP 变换到相机坐标系，并压到 1*1*1 的投影空间中； 5：光栅化打碎到屏幕上成像素； 6.1：光栅化中（和后）进行反走样处理； 6.2：光栅化中进行深度检测 Z-buffer； 7、8：贴上材质，应用 Blinn-Phong 模型等进行光照着色（平面着色/Gouraud 顶点着色/Phong 像素着色）（高光/环境光/漫反射光）； 9、10：重心坐标系插值进行纹理映射，像素金字塔（mipmap）反走样，纹理映射的另类应用：法线贴图 笔记 10 ~ 12：几何，例如贝塞尔曲线、网格细分等 10，11：什么是显式几何（参数，列表），什么是隐式几何（函数形式几何）； 11，12：贝塞尔曲线，网格细分（Loop 细分，Catmull-Clark 细分），网格简化（边坍缩）； 笔记 12 ~ 16：Whitted-Style 光线追踪与路径追踪 12，13：阴影映射，Whitted-Style 光线追踪，面线求交点（显式，算；隐式：AABB 包围盒）； 14：求交的优化：均匀空间划分、树形空间划分，按物体数划分； 15：基于物理（辐射度量学）的光线追踪：通过 BRDF 得反射方程，继而有全局光照 16：路径追踪，在光源进行蒙特卡洛积分，光源和像素上随机挑方向打路径； 笔记 16 ~ 20：光线传播的其他内容：物理材质与光场，这部分感觉比较偏介绍理解就行 17：材质就是 BRDF，用 BRDF 可以处理颜色，透明，抛光等等现象； 18：光线传播计算、外观材质、程序化生成； 19：摄像机的基本参数（光圈，快门，ISO……），光场； 20：色彩空间； 笔记 21 ~ 22：动画，即物理模拟 21：关键帧，用质点和弹簧来模拟形变面，正向运动学和逆向运动学，rigging（思想像三维贝塞尔）； 22：粒子在速度场中的运动模拟； 笔记可能会修改措辞、增删内容，我会在每次访问自己的博客时检查并修正错误。 后面有计划将我校的图形学课的内容也写出来（其实是 hawa 已经写好的），例如线扫描算法等。 后面会有计划将课程作业记录（报告？）写出来。 继续深入…… 对于渲染，请继续学习虎书，结合学习 OpenGL、Vulkan 等，学习各种各样的着色器等。 对于数学……呃，需要的时候再看吧，拓扑、流形什么的 如果对模拟与仿真感兴趣，请看 GAMES201 一些学术会议：ChinaVR、Chinagraph、Sigraph 当然目前我并没有科研的计划，但是如闫老师所言，以各种各样的视角和身份了解不同的领域是一件会很有收获的事。","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"}]},{"title":"GAMES101-22：动画2","slug":"GAMES101/GAMES101-20","date":"2023-08-14T15:41:16.000Z","updated":"2024-01-03T16:40:22.057Z","comments":true,"path":"/GAMES10120.html","permalink":"http://example.com/GAMES10120.html","excerpt":"前言 GAMES101-22:单粒子的运动的模拟方法（欧拉与其各种改进）、刚体模拟、流体模拟、网格法与质点法处理大量物体的移动问题","text":"前言 GAMES101-22:单粒子的运动的模拟方法（欧拉与其各种改进）、刚体模拟、流体模拟、网格法与质点法处理大量物体的移动问题 单粒子模拟 考虑一个粒子在速度场中速度随着时间的变化的模拟。即算常微分方程 x˙=v(x,t)\\dot{x} = v(x,t)x˙=v(x,t) 简单而基础的方法：（前向）欧拉方法 xt+Δt=xt+Δtx˙tx˙t+Δt=x˙t+Δtx¨tx^{t+\\Delta t} = x^t + \\Delta t \\dot{x}^t \\\\ \\dot{x}^{t+\\Delta t} = \\dot{x}^t + \\Delta t \\ddot{x}^t xt+Δt=xt+Δtx˙tx˙t+Δt=x˙t+Δtx¨t 其中右上角只是标记，不是指数；而一个点表示一次求导（即速度）。这种方式用上一帧的数据计算下一帧的数据。其问题在于： 不准确：步长（即两帧之间的间隔 Δt\\Delta tΔt）越大，结果越不准； 不稳定：对于圆周运动的情况，会变成螺旋形飞出去； 不准确在 CG 中往往可以理解容忍，但是不稳定、无论如何都得不到准确的结果是难以接受的。这种不稳定现象是欧拉方法试图用数值方法解微分方程的必然结果。 下面是一些解决了不稳定性的方法。 中点法 使用欧拉方法计算出在 o 点的粒子 p 下一步长所在的位置 a； 取 oa 中点 b 的速度场方向； 对（依然在 o 点的 p）应用 b 点的速度计算欧拉方法，得到实际到达的位置 c。 这样，中点法取了一个中间、更能代表平均运动方向的速度。 如果我们将中点法的公式推出来，那么，我们会发现中点法更准确的原因在于它引入了二阶导，而不是普通欧拉的一阶导。 自适应步长 使用欧拉方法计算出在 o 点的粒子 p 下一步长所在的位置 a； 使用欧拉方法计算出在 oa 中点的粒子下一步长所在的位置 b； 如果 a、b 距离甚远，那么说明步长过大，缩小步长重新计算； 如果 a、b 距离不大，那么说明步长已经缩得够小，取一个作为结果； 这种办法步长可变，所以能模拟得很好。 隐式/后向的欧拉方法 使用下一帧的速度而不是上一帧的速度。 xt+Δt=xt+Δtx˙t+Δtx˙t+Δt=x˙t+Δtx¨t+Δtx^{t+\\Delta t} = x^t + \\Delta t \\dot{x}^{t+\\Delta t} \\\\ \\dot{x}^{t+\\Delta t} = \\dot{x}^t + \\Delta t \\ddot{x}^{t+\\Delta t} xt+Δt=xt+Δtx˙t+Δtx˙t+Δt=x˙t+Δtx¨t+Δt 在实际情况中速度和加速度之间的关系往往并不是那么好直接解出。往往可能需要求根公式等导致速度会比显示慢得多————当然，也变得稳定得多。 龙格-库塔方法 通过中点法我们已经知道阶数越高效果越好。而龙格-库塔方法是一系列解常微分方程的很好的方法（同样基于欧拉），其中四阶的龙格库塔方法（RK4）最常用，它形如 xn+1=xn+16h(k1+2k2+2k3+4k4)tn+1=tn+hx_{n+1} = x_n + \\frac{1}{6}h(k_1 + 2k_2 + 2k_3 + 4k_4) \\\\ t_{n+1} = t_n + h xn+1​=xn​+61​h(k1​+2k2​+2k3​+4k4​)tn+1​=tn​+h 其中四个 k 是四个关于 x、t 的函数，懒得记了，用到再说。 对推导感兴趣的话请学习数值分析。 不基于物理的方法（Position-based / Verlet Intergration） 不基于物理的方法难以保证能量守恒，但是又快又简单。 参见作业 8. 衡量稳定性 通常我们不关心单步的误差（局部误差）和整体误差的值是多少，但是会关心它们和步长之间的关系。 以隐式欧拉为例，步长为 h，整体误差是 O(h)O(h)O(h)，局部误差是 O(h2)O(h^2)O(h2)，即如果步长减少一半，那么可以期望整体误差变为原来的一半，而局部误差可以期望变为原来的四分之一。 刚体模拟 刚体即不可变形的物体，刚体的模拟本质上就是一个大单体粒子的模拟。当然我们还需要考虑一些其他的属性，例如： 角度、角速度（一阶导，F/M）、角加速度（二阶导） 位置、速度、加速度 流体模拟 我们通过模拟小的刚体球（粒子）近似水体；并且认为水的密度是不变的，如果某处的密度改变了，那么就通过修正粒子的位置来进行修正。 物理模拟和渲染是有前后的两步，所以近似为小球不影响渲染。 每个粒子都可以对空间中的任意一点的密度产生影响。因此，为了达到“改变粒子的位置使得此处的密度降低”的目的，我们就需要知道密度对于所有粒子的位置的导数梯度。然后应用梯度下降法即可。（即改变对此处密度影响最大的粒子的位置） 以防万一：梯度是导数下降最快的方向。 这种模拟是不基于物理的，例如我们直接改了粒子的位置。当然为了避免水的运动停不下来，我们也可以加入能量衰减的公式。 大量物体的模拟方法（视角）：质点法与网格法 质点法：又称拉格朗日法，以质点为主体，研究观察质点的位置变化情况； 网格法：又称欧拉法，以空间网格为主体，研究观察一个空间中的固定位置的密度等信息（类似盯着那种大颗粒 LED 滚动屏的单个珠子看）。 材质点法：混合网格质点的方法，例如用粒子记录材质信息，然后用网格计算粒子的变迁，最后写回粒子里。 尾声 见笔记1。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-21：计算机动画 Next：完结撒花！","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"粒子","slug":"粒子","permalink":"http://example.com/tags/%E7%B2%92%E5%AD%90/"},{"name":"刚体","slug":"刚体","permalink":"http://example.com/tags/%E5%88%9A%E4%BD%93/"},{"name":"流体","slug":"流体","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93/"}]},{"title":"GAMES101-21：计算机动画","slug":"GAMES101/GAMES101-19","date":"2023-08-13T14:40:02.000Z","updated":"2024-01-03T17:00:35.266Z","comments":true,"path":"/GAMES10119.html","permalink":"http://example.com/GAMES10119.html","excerpt":"前言 GAMES101-21:动画的历史、关键帧、物理模拟、刚体、正向与逆向运动学、Rigging、动捕","text":"前言 GAMES101-21:动画的历史、关键帧、物理模拟、刚体、正向与逆向运动学、Rigging、动捕 动画 动画：给物体带来生命，一种交流工具。在计算机时代，我们可以认为动画就是不断连续输出模型随时间的变化的帧。 动画的历史 1963 年，就有了计算机动画：sketchPad 中的动画。 Pixar 的《玩具总动员》是一个里程碑式的作品：整个全长电影都是计算机渲染出来的。 关键帧 这个关键帧就是 PR 等中的关键帧。 以前的艺术家，会画出关键帧，然后由助手画中间的帧。 现在，我们希望计算机可以插值出中间的帧。当然，插值有许多的方式，不一定是线性插值。我们还可以期待例如 C1 连续的插值等。 基于物理的动画（物理模拟） 如果例如我们给出正确的力学公式和正确的力学模型，当然就可以更新模型的动作变化，即物理模拟。 其中很重要也很困难的一部分是流体模拟。 质点弹簧系统（Mass Spring System）：通过一系列的质点和连接的弹簧来进行模拟。 在 a，b两个质点之间用 l 长度的弹簧连接。弹簧现在被拉开，因此 a 受到向 b 的力，有应用胡克定律简单有 fa→b=ksb⃗−a⃗∥b⃗−a⃗∥(∥b⃗−a⃗∥−l)f_{a \\rarr b} = k_s\\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|}(\\| \\vec{b} - \\vec{a} \\|-l) fa→b​=ks​∥b−a∥b−a​(∥b−a∥−l) 仅仅应用上面的模型是不够的，因为能量守恒，要让弹簧停下来我们就需要加入摩擦力。摩擦力有这么几点特点 它与 a、b 之间的相对速度有关，而且是沿弹簧方向的相对速度。 与弹簧的力的方向相反。 基于此我们给出阻力公式（以 b 为例） fb=−kdb⃗−a⃗∥b⃗−a⃗∥⋅(b˙−a˙)⋅b⃗−a⃗∥b⃗−a⃗∥f_b = -k_d \\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|} \\cdot (\\boldsymbol{\\dot{b}}-\\boldsymbol{\\dot{a}}) \\cdot \\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|} fb​=−kd​∥b−a∥b−a​⋅(b˙−a˙)⋅∥b−a∥b−a​ 其中 b˙−a˙\\boldsymbol{\\dot{b}}-\\boldsymbol{\\dot{a}}b˙−a˙ 中一个点表示一阶导，即这个方向上的速度。 我们这么理解这个公式：b 的向 a 方向的相对速度经过一个点乘投影到弹簧方向上，再经过一个点乘变成该方向的速度，最后乘以阻力系数并取反得到阻碍 b 向 a方向收缩的阻力的大小和方向。 应用这些力学公式，我们将点之间用弹簧按方格的形式连接起来，似乎就可以简单地表示一块布了。但实际上还有一些问题： 不能抵抗切变：即如果沿一个方向拉，我们不应该能将布拉成一个没有宽度的线。为此，我们需要在对角线上连接上弹簧来抵抗切变。 不能抵抗非平面弯曲：即如果把布折起来，我们不应该能将它折叠成一个平面。为此，我们将一个点与和它上下左右隔了一个点的点连起来，提供一个很弱的力。 于是结构长这样： 切变可复习第三课的基本变换矩阵部分。 其他的模拟方法， 有限元方法 FEM：用一种扩散的方式像热一样看力，适用于汽车碰撞的模拟。 粒子系统：用许多的粒子来模拟，粒子移动受一系列力的作用。这种方式的优点是易于理解、实现和规模可伸缩，挑战则是需要计算许多的粒子，计算需要考虑如何加速。 粒子的本质就是“描述个体与群体之间的关系”，因此实际上我们不仅仅可以用粒子来描述烟、雾、水等等，也可以用它来描述鸟群、蜜蜂、星系等等……例如，一个鸟“粒子”既会跟随鸟群中心移动方向移动，不希望离中心太远，也不会希望和其它鸟太近。 运动学（Kinematics）） 正向运动学（Forward Kinematics） 骨骼系统：描述关节之间的拓扑关系，本身形成了一种树形结构。关节有三种类型： Pin：只能在一个点上旋转（一维旋转） Ball：可以在二维平面内旋转（二维的旋转） Prismatic：可以拉伸 正向运动学只要我们传入好每个关节的角度等参数，就可以告诉我们运动的结果，关节停在了哪儿。这种方式简单而直接，但是并不方便艺术家的使用：显然我们不希望调整关节的方式是不断地挨个输入角度看什么时候调得合适。为此我们需要逆运动学。 逆运动学 逆运动学即我们调整关节的位置，计算机自动给出其他的关节应该如何随着变化。 逆运动学的一些挑战： 计算会比正向运动学复杂很多 多解情况 无解情况 现在用的一些优化方法：用梯度下降的方法而非解数学公式。 Rigging Rigging 是对物体形状的控制，就如木偶上的提线，让角色做出不同的动作造型。 Google Bard 将它翻译成了骨骼系统，不无道理可以参考但是骨骼感觉不能代表所有 Rigging。 这有些像三维世界的（贝塞尔）曲线调整，我们调节一些点使得样条变成我们想要的样子。 动作捕捉 干脆建立一个真人到虚拟人的控制点的映射，然后让人去做动作。 好处在于：真实度高、数据获取快（不用艺术家去一点一点调）； 缺点在于：准备工作非常多而复杂（例如穿控制点的衣服等等）、不一定能获取到需要的数据（非真实风的、控制点难以捕捉的）。控制点有很多办法来记录，例如穿绿幕衣服用摄像机 + CV 算法的方式，或者连接机器等等。 阿凡达的里程碑效应在于，其大量使用了面捕技术。 动画的生产管线：原画-&gt;模型-&gt;生产吧啦吧啦…… 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-20：颜色与感知 Next：GAMES101-22：动画2","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"计算机动画","slug":"计算机动画","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB/"},{"name":"关键帧","slug":"关键帧","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%B8%A7/"},{"name":"骨骼系统","slug":"骨骼系统","permalink":"http://example.com/tags/%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/"},{"name":"运动学","slug":"运动学","permalink":"http://example.com/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"Rigging","slug":"Rigging","permalink":"http://example.com/tags/Rigging/"}]},{"title":"GAMES101-20：颜色与感知","slug":"GAMES101/GAMES101-18","date":"2023-08-12T18:32:12.000Z","updated":"2024-01-03T17:00:16.705Z","comments":true,"path":"/GAMES10118.html","permalink":"http://example.com/GAMES10118.html","excerpt":"前言 GAMES101-20:颜色的物理基础、生物基础、色彩空间","text":"前言 GAMES101-20:颜色的物理基础、生物基础、色彩空间 note：色彩空间，听了三回啊三回………（悲。（CV、VR、GAMES101） 颜色 人对光有不同的颜色认知，原因是有不同的波长（和光的叠加）。我们用谱功率密度（SPD）曲线衡量一道光在不同波长上的分布。谱功率密度具有线性的性质，可以叠加。 需要特别强调的是，颜色是人对光的感知，不是光的固有属性。 人眼有棒状细胞感知灰度，杆状细胞感知色彩，三种杆状细胞分别对不同的波长敏感。 不同个体的三种杆状细胞的分布和占比都大不一样。 同色异谱现象，可以有两个光有一样的颜色不一样的 SPD。我们可以通过混合不同的光得到异谱的同色结果。这就是色彩匹配。 在纸上我们采取减色系统 CMYK，屏幕上加色系统如 RGB。 这样我们就可以做色彩匹配的实验，比如说尝试用调整 RGB 的比例来得到我们看到的所有颜色。但是这时，我们发现有的颜色是调 RGB 调不出来的，需要在需要被匹配的颜色上加光（即在匹配组加负数多的光）才行。这样，我们就可以用 (s)RGB 坐标表示任何波长的光。进而对任意 SPD 可以在 R、G、B 上积分（因为 SPD 上是连续的波长）。 把不同波长表示成一个坐标，那么就得到了一个色彩空间。 XYZ 色彩空间：不同于实验测定的 RGB，还有设计出来的 XYZ 色彩空间，它的优势在于避免了取负数坐标的问题。同时 Y 值被设计得可以表示亮度（明度）。我们计算 x，y 分别为 X、Y、Z 中 X、Y 的占比，那么固定 Y值，就可以把色彩空间表示在二维的面上（而 z = 1-x-y）。表示出来的图像是凸型或者说舌形的。故而可叫色度图、舌形图、色域图。 sRGB 只占色域空间中非常小的部分。 HSV 色彩空间：色调、饱和度、明度。色调选纯色、饱和度决定有多偏白、明度决定有多偏黑（暗）。 LAB 色彩空间：L:亮度（黑白互补对），a：红绿互补对，b：蓝黄互补对。 互补色的确定是人的眼睛的特性确定的。例如我们无法想象偏绿的红，可以想象偏绿的蓝。利用视觉暂留效应，我们可以短暂的看到一种颜色的互补色。 这里我们再次感知到颜色是人的感知效果。 CMYK：印刷减色系统。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-19：摄像机、透镜、光场 Next：GAMES101-21：计算机动画","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"颜色","slug":"颜色","permalink":"http://example.com/tags/%E9%A2%9C%E8%89%B2/"},{"name":"色彩空间","slug":"色彩空间","permalink":"http://example.com/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"}]},{"title":"GAMES101-19：摄像机、透镜、光场","slug":"GAMES101/GAMES101-17","date":"2023-08-11T17:25:54.000Z","updated":"2024-01-03T17:00:02.897Z","comments":true,"path":"/GAMES10117.html","permalink":"http://example.com/GAMES10117.html","excerpt":"前言 GAMES101-19:简单了解：摄像机的基本构造、光圈大小、快门、ISO、弥散圆、曝光、可视角度","text":"前言 GAMES101-19:简单了解：摄像机的基本构造、光圈大小、快门、ISO、弥散圆、曝光、可视角度 GAMES101-20:光场 图像：合成法与捕捉法 成像不一定是合成成像（例如模型），也可以是捕捉成像，例如相机拍拍拍。我们之前说的都是合成成像，本节讲捕捉成像。 相机的部件 小孔或透镜：小孔应用在针孔相机。用于聚光成像。 快门：控制进光时间。 传感器：记录辐照强度（Irradiance）。（如果没有小孔/透镜，一个点有各个地方的光，传感器成像就糊了。） 针孔摄像机利用小孔成像，没有深度（景深）可言，每个地方都是清晰的。我们此前介绍的光线追踪也是这种模型。 焦距和可视角度的关系，设传感器高度为 h，焦距为 f，那么在竖直方向上可视角度： FOV=2arctan⁡h2fFOV = 2\\arctan\\frac{h}{2f} FOV=2arctan2fh​ 由于 FOV 和传感器大小、焦距均有关系，所以一般会规定把焦距换算成 35mm（*24mm） 胶片下的焦距。 通常,对于 35mm 胶片, 17mm 焦距对应 104° 可视角度，是广角镜头，50mm 47°是普通镜头。 当然传感器大有大的好，分辨率可以上升。 曝光 曝光的公式 H=T×EH = T \\times EH=T×E,即曝光 = 曝光时间×辐照强度。曝光时间越长，照片越亮，因为传感器上累计的能量越多。 光圈大小，类似人眼瞳孔的设计，依据 F-Stop 参数控制光圈开合来控制进光多少。 F-Stop 也可以写成 FN、F/N，N 代表一个数。 FN 是焦距除以光圈直径。 光圈大进光多，自然会带来曝光度的提升。 光圈越大，还会导致景深越浅，远景变糊。 快门速度：快门能快速开关，控制开放进光的时间 快门时间过长，拍摄运动物体就会带来模糊效果，即运动模糊。 速度越快/快门越长越模糊。快门时间短，可以减轻运动模糊，但是也需要修正由此带来的亮度降低。 合适的运动模糊既可以增强人对速度的感知，也可以一定程度的反走样。 机械运快门打开不可能真正同时，在记录高速运动的物体（如飞机螺旋桨）的时候会带来扭曲现象。 ISO 感光度：后期处理的一步，在每个传感器数值上乘以一个倍率。 ISO 过大，在放大图像亮度的同时也会放大噪声，使得图像噪声过多。 联系光圈和快门，如果我们相同的曝光度下，想获得浅景深（大光圈），就得减少快门时间来维持曝光度的不变，这需要权衡。同时也意味着同时调整光圈和快门得到的同样曝光度的照片并不一致。 快门时间极短，就是高速摄影，快门时间极长，就是延时摄影。 理想薄透镜、弥散圆与光线追踪 设想一种理想薄透镜：没有厚度，可以改变焦距（基于现在调整透镜组的设计）。 薄透镜有下列关系： 1f=1zi1zo\\frac{1}{f}=\\frac{1}{z_i}\\frac{1}{z_o} f1​=zi​1​zo​1​ 其中 f 是焦距，ziz_izi​ 是物距，zoz_ozo​ 是像距。 失焦模糊：一个点经过透镜可以被聚焦在一个点上，但是我们的感光面并不在该点上，导致在感光面上就成了一个圆（CoC，Cirlcle of Confusion）。根据物距、焦距、感光面到透镜的距离(zsz_szs​)、透镜的大小(A)，我们可以计算 CoC 的大小 C。(像距（ziz_izi​）是中间步骤)： CA=∣zs−zi∣zi\\frac{C}{A}=\\frac{|z_s-z_i|}{z_i} AC​=zi​∣zs​−zi​∣​ 又光圈大小是焦距除以光圈直径，所以我们就知道了为什么大光圈意味浅景深。 光线追踪中加入景深：场景假如我们知道和传感器距离的透镜，一个传感器点随机命中透镜上点 a，我们知道传感器点经过透镜是会聚焦在点 b 的，那么 a 接下来就会往 b 去。 景深 景深就是在焦距附近，CoC 的大小还可以接受的那一段长度。 光场 全光函数：假设我们有一个完全真实的画，贴在墙上，那么我们就无法区分这是窗子还是画。从这个角度出发我们就可以定义函数 P(θ,ϕ,λ,t,Vx,y,z)P(\\theta,\\phi,\\lambda,t,V_{x,y,z})P(θ,ϕ,λ,t,Vx,y,z​)，量依次表示：一个观察者周围 360°的极坐标、该坐标的光强，光波长（颜色），时间，观察者的空间位置。这样，我们就能表示一个可以随处移动的人在任意地点时间任意向方向看到的东西（即我们现实观察的一切）。 定义光线，我们无论怎么定义光线总是需要一个点一个方向，这里它们都是二维的。因为点在物体表面（类似 uv 坐标），而方向可以是 θ，ϕ\\theta，\\phiθ，ϕ 两个方位角。 于是定义光场：一个物体上任意一点向任何方向看的光的信息。 于是我们通过光场（一个四维函数）可以知道任何方向看到这个物体的效果。 光场不一定要在物体表面，正如开头所说，我们只关心看到了什么，不关心看到的东西究竟是在墙上还是墙外。我们完全可以定义一个包围盒包围物体记录光场。 一种定义光场的办法是，定义两个平面，在两个平面（uv 平面和 st平面）上各取两个点，那么就可以确定一个光线。 假定 uv 是离摄像机近的面，st 是离物体近的面。那么可以讨论两种理解： 从 uv 上固定一个点看 st 上所有点：看到一个完整的物体。正如我们在普通摄像机看到的。 从 uv 上所有点看 st 的不同方向：看到一个点在不同方向的信息。 昆虫的复眼其实就是一种光场。我们的眼睛/摄像机之所以不能缺少透镜是因为缺少透镜使得不同方向来的光被混合在了一起，如果我们可以将来自不同方向打到同一点的光经过透镜以后分别存放在不同的感光元件上，那么就可以把光分开了。这样就同时可以看向不同方向。利用这种办法，有人发明了光场相机。 要从光场中还原一个普通的照片，我们可以选定一个方向去光场中获取信息。而光场照片比起普通照片的优点是，我们可以虚拟的移动相机的位置。而不用 CV 的一些手段。 当然，因为要记录大量的信息，光场照片数据量大，分辨率往往不足。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-18：渲染中的高级板块 Next：GAMES101-20：颜色与感知","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"光场","slug":"光场","permalink":"http://example.com/tags/%E5%85%89%E5%9C%BA/"},{"name":"透镜","slug":"透镜","permalink":"http://example.com/tags/%E9%80%8F%E9%95%9C/"}]},{"title":"GAMES101-18：渲染中的高级板块","slug":"GAMES101/GAMES101-16","date":"2023-08-11T14:29:04.000Z","updated":"2024-01-03T16:59:41.265Z","comments":true,"path":"/GAMES10116.html","permalink":"http://example.com/GAMES10116.html","excerpt":"前言 GAMES101-18:渲染中的高级内容（仅作了解，不涉及细节）：光线传播计算、外观材质、程序化生成","text":"前言 GAMES101-18:渲染中的高级内容（仅作了解，不涉及细节）：光线传播计算、外观材质、程序化生成 高级光线传播 有偏光线传播 双向路径追踪 BDPT MLT 无偏光线传播 光子映射 Photo Mapping VCM IR 无偏：蒙特卡洛积分不会引起系统误差，无论样本多少，期望都是正确的。反之则是有偏的。 双向路径追踪 BDPT 路径追踪：从相机打射线追踪到光源。双向路径追踪会先从相机和光源打出一些“半路径”，然后再连接这些半路径。 BDPT 在有的情况下表现比路径追踪好很多（例如光源是对着天花板打的灯，场景全是间接光）。但是相对的速度很慢，写对很难。 Metropolis 光线传播，Metropolis Light Transport，MLT Metropolis 是人名，姑且不译。 应用马尔科夫链蒙特卡洛积分（MCMC），马尔科夫链是一种采样方法，它可以根据当前样本生成靠近的新样本。这样，对于困难的光路，它也可以在局部不断进行探索最后得到新的路径，最后得到最佳概率密度函数（f（x）形状p（x）时）。 MLT 对于复杂光路处理非常好（例如游泳池波浪在水底聚焦的波纹，caustics 现象），因为只要有一个随便的函数就可以得到更多的形状。 缺点则有：难以估计收敛速度；像素之间没有关系，收敛速度不一；因此而得到脏结果；也因为像素不一定会每一帧都收敛，导致一般不用于动画渲染，会导致画面抖动。 光子映射 有多种方法。 步骤1：光子不断反射折射，直到打到漫反射的表面停下。记录下表面的光子数。 步骤2：摄像机打出射线不断反射折射，直到遇见漫反射表面停下。 然后进行计算，计算局部密度估计（local density estimation） ：找到射线附近最近的 N 个光子，计算它们占据的面积大小（密度）。因为我们知道，光子越多越密就应该越亮。 如果 N 过小，则结果噪声大；如果 N 过大，则结果会变糊。 光子映射是有偏的，因为光子数量有限，我们是用不无限小的面积 ΔA 去替代了无限小的面积 dA（数量 N 也是同理）。但是它是“一致的”，也就是极限（光子无穷多）的情况下结果是正确的。 为什么我们是找 N 个光子占的面积而不是找 A 面积内的光子数量？ 因为后者是有偏且不一致的：随着光子数量的增加，结果不会收敛的正确结果。 VCM（顶点连接与扩展） 结合 BDPT 和光子映射。 BDPT 打出的两边的半路径非常接近但是没有连接，就用光子映射的办法去它们作为光子收集起来发挥作用。 实时辐射度 Instant Radiosity 把反射光的平面看成新的光源。 缺点则有有的时候会有异常亮点，不能处理抛光面等。 高级外观（Appearance）模型 非表面模型 散射介质/参与介质:云雾 毛发、纤维 颗粒材质 表面模型 透光材质 布料（cloth） 程序化生成模型 散射介质 云雾会在传播过程中会被吸收也会被散射（往各个方向随机打）。 相位函数类似于 BRDF 决定了光怎样散射（均匀？主要前向？主要后散？）。 渲染：随机选一个弹射方向随机走一段距离，最后连到摄像机。 不是只有云雾才是散射介质，例如手电筒的光照亮捂在上面的手，这里光进入了手一定距离，这里手就是散射介质。 毛发外观 人头发 头发表面会有两种高光，无色的（漫画上的白光带）与有色的。 Kajiya-Kay 模型：效果不好。 Marshner Model：把头发局部视为玻璃圆柱，分为 cortex（表面） 和 cuticle（内部），并且表面会吸收光，内部会有色素。综合考虑 R（反射）、TT（两次折射）、TRT（折射反射折射）。 光会真的在一根根的头发中和头发间折射反射，计算量巨大。 动物毛发 人头发模型运用于动物毛发得到的结果是不对的。 因为毛发的最内层是 Medulla(（毛）髓质)，毛髓会发生散射现象，类似散射介质。而动物毛发的毛髓比人头发大得多。 因此，我们需要模拟毛髓。 进一步地我们也可以在人的头发上模拟（比动物毛发小的）毛髓，得到更真实更亮的头发。 同样用玻璃柱模拟毛髓，这就是更好的双玻璃柱模型。 颗粒材质（granular material） 一粒一粒的，例如盐、香料、沙子…… 可以将其视为一个个单元；然后再分析成分、渲染。 非常耗时间，应用不多。 透光材质（Translucent） 透光（Translucent）往往被翻译成半透明，但并不是半透明。这种性质的原理在于散射，使得光能透过，但是并不能由此看到什么。 例如捂住手电筒的手附近、玉、水母 为此我们引入次表面散射（BSSRDF）的概念，这是对 BRDF 概念的拓展，从一个点一个方向进入的光可以从另外一个点另外一个方向出去，记 S(xi,ωi,xo,ωo)S(x_i,\\omega_i,x_o,\\omega_o)S(xi​,ωi​,xo​,ωo​)。 Dipole 近似：在发生 BSSRDF 表面的地方上下加入两个光源，从而用 BRDF 近似 BSSRDF。 人的皮肤、大理石等等都会发生散射，因此使用 BSSRDF 都会得到更好的效果。 布料材质 纤维（fiber）绕成一股股（Ply），股再缠绕形成线（yarn），最后被织成布料。 渲染：BRDF 面；当成微小的体积单元，根据编织性质确定吸收和散射，向散射介质一样渲染（好，但是计算量大）；更暴力地，像头发一样渲染纤维。 细节外观 现实世界不是绝对完美的，有各种细节上的瑕疵，这反而使得我们的渲染结果不够真实。 如果我们使用的法线贴图（normal map）是完美线性的，就不够真实，如果每个法线既符合整体规律又有自己的特点，就更真实。 这样的微表面渲染非常困难，因为表面太小有太多无法从光源命中摄像机的路径。解决的办法是我们可以把一个像素覆盖的微表面找出来，计算这个像素在各个方向的 BRDF。如果覆盖像素多，则有总体的效果，覆盖的少，就有个体的性质。 如果表面极小，小到接近光波，那么就会需要考虑波动光学来计算 BRDF。 程序化生成的外观 如果我们存储三维空间的纹理，那就太复杂，太占空间了。我们可以用噪声函数，不存储，只在需要用的时候算出来该点的值即可。 一些噪声函数的应用：地形生成、水面生成、木头内外的年轮纹理等等。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-17：基于物理的材质（BRDF） Next：GAMES101-19：摄像机、透镜、光场","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"光线传播","slug":"光线传播","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E4%BC%A0%E6%92%AD/"},{"name":"程序化生成","slug":"程序化生成","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"}]},{"title":"GAMES101-17：基于物理的材质（BRDF）","slug":"GAMES101/GAMES101-15","date":"2023-08-09T14:14:49.000Z","updated":"2024-01-03T17:23:34.910Z","comments":true,"path":"/GAMES10115.html","permalink":"http://example.com/GAMES10115.html","excerpt":"前言 GAMES101-17:各种各样的材质、反射率、斯涅耳定律与全反射现象、菲涅尔项、微表面材质、BRDF 的特点与测量","text":"前言 GAMES101-17:各种各样的材质、反射率、斯涅耳定律与全反射现象、菲涅尔项、微表面材质、BRDF 的特点与测量 材质就是 BRDF 我们现在已经知道，决定模型的光照效果是什么样的是不同的材质，而在我们的渲染方程(不考虑自发光)中，和物体自身相关的项只有 BRDF。这就是说， 材质就是 BRDF。 Lr(p,ωo)=∫H2Li(p,ωi)fr(p,ωi,ωo)(n⃗⋅ωi⃗)dωiL_r(p,\\omega_o)=\\int_{H^2}L_i(p,\\omega_i) f_r(p,\\omega_i, \\omega_o) (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i Lr​(p,ωo​)=∫H2​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​​)dωi​ 材质决定物体的光照效果，具体来说，即反射/折射系数、金属质感强弱、光滑感、柔软度等等； 纹理决定了物体的颜色，从物理上来说即吸收了不同波长的光，纹理的本质是一张图片（uv 图）； 纹理和材质是关系密切的因为它们事实上在渲染公式中的同一项。但是我们通常不会对一束光分成 RGB 三色进行考虑，所以就有了纹理图的需求。当然，准确地说，材质是只和漫反射系数有关的。 材质多种多样，除了漫反射和镜面反射，这里还介绍两种情况。 抛光（Glossy）材质：这种材质像打磨过的金属面，光被反射到一个小区间里，于是既有高光又不是完全的镜面。不同的金属的抛光面也有不同的质感，例如铜面发红，铝面发白。 折射：半透明类型的材质还会同时发生反射和折射。折射的光与物体内的物体发生反射于是我们就可以看到物体内的物体。如果折射的过程中光被吸收了一部分，我们则就会看到发生折射的物体的颜色。（例如水的绿色）。 漫反射与反射率 下面计算反射率。 假设一个完全不吸收光(纯白)的物体表面发生漫反射，就有对任意方向来的光都有 Lo=LiL_o=L_iLo​=Li​， 此时，光均匀地从各个方向来又被均匀的反射到各个方向去，物体本身不吸收任何能量。有： \\begin{align} L_r(p,\\omega_o) &amp;=\\int_{H^2}L_i f_r (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i \\nonumber\\\\\\nonumber\\\\\\nonumber &amp;= f_r L_i \\int_{H^2}\\cos\\theta_i \\mathrm{d}\\omega_i \\\\\\nonumber\\\\\\nonumber &amp;= \\pi f_r L_i \\\\\\nonumber\\\\\\nonumber &amp;\\dArr \\\\\\nonumber\\\\\\nonumber f_r &amp;= \\frac{1}{\\pi} \\end{align} 定义物体的**反射率(albedo)**衡量物体反射的强弱，值介于 0 到 1 之间，则由上式知道反射率和 BRDF 之间的关系是： fr=ρπf_r = \\frac{\\rho}{\\pi} fr​=πρ​ 而我们的情境就是物体反射率最强的时候，这时物体纯白。 Albedo 的定义方式多种多样，既可以是一个数，也可以是 RGB 三个数或一个光图。而 Albedo 纹理是一种特殊的纹理，它用于指定物体表面的颜色或基础反射率。 反射和折射 此外，半透明类型的材质还会同时发生反射和折射。折射的具体效果见上。 类比于 BRDF，对于折射的 “BRDF” 就是 BTDF，二者可以合称 BSDF。 反射 对于反射，我们知道入射角等于反射角。有两种计算反射方位的方式。 利用向量的性质，入射向量加出射向量与法线向量共线(左图)ωi+ωo=2cos⁡θn⃗=2(ωi⋅n⃗)n⃗⇒ωo=−ωi+2(ωi⋅n⃗)n⃗\\omega_i+\\omega_o=2\\cos \\theta\\vec{n} = 2(\\omega_i\\cdot\\vec{n})\\vec{n}\\\\ \\rArr \\omega_o = -\\omega_i+ 2(\\omega_i\\cdot\\vec{n})\\vec{n} ωi​+ωo​=2cosθn=2(ωi​⋅n)n⇒ωo​=−ωi​+2(ωi​⋅n)n 类似在立体角处的讨论，把角度分成与法线方向的夹角 ω\\omegaω 以及垂直俯视法线方向的平面上的角 ϕ\\phiϕ （右图），则 ω\\omegaω 不变，只需ϕo=(ϕi+π)mod 2π\\phi_o=(\\phi_i+\\pi)\\mod2\\pi ϕo​=(ϕi​+π)mod2π 镜面反射还需要涉及到狄拉克 δ 函数，这里没有展开。 折射 斯涅耳定律（Snell's Law）指出，光从环境 i 打到环境 t 中，折射率与折射角（于法线轴夹角）度满足： ηisin⁡θi=ηtsin⁡θt\\eta_i\\sin\\theta_i = \\eta_t\\sin\\theta_t ηi​sinθi​=ηt​sinθt​ 其中，真空的折射率为 1。而折射率越高，往法线方向（的负方向）偏移就越多。 折射在垂直于法线的平面上不改变光的方向。 由斯涅耳定律推出 \\begin{align} \\cos\\theta_t &amp;=\\sqrt{1-\\sin^2 \\theta_t}\\\\\\nonumber\\\\\\nonumber &amp;=\\sqrt{1-(\\frac{\\eta_i}{\\eta_t})^2 (1 - \\cos^2 \\theta_i)} \\\\\\nonumber\\\\\\nonumber &amp;\\dArr \\\\\\nonumber\\\\\\nonumber &amp;1-(\\frac{\\eta_i}{\\eta_t})^2 (1 - \\cos^2 \\theta_i) \\nless 0 \\end{align} 这意味着当入射介质的折射率大于出射介质折射率的情况下，有可能不会发生折射，这就是全反射现象。 Snell's Window 如果大折射率介质中看小折射率介质，我们只能看到有限的一个区域，这是因为其他较远的入射较大的入射角让光无法折射到人眼处了已经。这种情况就是 Snell's Window。 菲涅尔项 日常生活中可以观察到的现象：如果俯视一张光滑的桌子，几乎没有反光现象；如果接近平视，则发光现象明显。这说明，物体的反射折射率于光的入射角度有关，这可以用菲涅尔项描述。 简单地说，菲涅尔项告诉我们： 如果和法线方向夹角越大（最多90度到平面），反射率越高，甚至于几乎全部反射掉；如果夹角越小，则反射率也越小，最小值不为零。 不同物体有不同的菲涅尔项。 导体（金属）和绝缘体的菲涅尔项图像大不一样，主要体现在金属的最小反射率非常高，例如 0.9。 菲涅尔项的计算公式较为复杂，因此我们通常使用近似公式（施里克近似，Shilick's Approximation） R(θ)=R0+(1−R0)(1−cos⁡θ)5R0=(n1−n2n1+n2)2R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0=(\\frac{n_1-n_2}{n_1+n_2})^2 R(θ)=R0​+(1−R0​)(1−cosθ)5R0​=(n1​+n2​n1​−n2​​)2 其中 R0R_0R0​ 是最低反射率。 拓展，导体的反射率还会发生随着角度增大而在一定区域内发生降低。此外，导体的折射率是负数。 微表面材质 从太空看地球我们可以发现这样一个事情，我们看不见地球表面的山川地貌，而看得阳光在地球表面的山川各种作用后的整体光照情况。 微表面理论告诉我们，离得够远，就看不到物体表面细节但是可以看到整体的光照情况。 于是微表面材质： 宏观：平坦但粗糙 微观：崎岖的几何面且镜面反射，有自己的独立法线。 如果表面相对光滑，微表面反射的光集中在一个较小的区间，呈现抛光的效果；如果表面相对粗糙，微表面反射的光分散在一个较大的区间，呈现漫反射的效果。 微表面的 BRDF： f(i,o)=F(i,h)G(i,o,h)D(h)4(n,i)(n,o)f(i,o)=\\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)} f(i,o)=4(n,i)(n,o)F(i,h)G(i,o,h)D(h)​ 其中 h：中间向量方向，即入射与出射方向的中间方向； F：菲涅尔项，告诉我们当前角度的反射率； G：几何项/ Shadowing-masking term，告诉我们有多少微表面的反射被另外一个微表面遮挡而损失了。这可以修正在接近水平面时的过亮情况； D：查询微表面反射的方向和中间向量的位置关系； 各向同性材质与各项异性 各向同性：微表面没有非常明确的方向性；或者从 BRDF 的方向来说，入射角和出射角的方位角变化，但是相对角度不变，则光照效果不变。 各向异性：微表面有非常明确的方向性；从 BRDF 的方向来说，入射角和出射角的方位角变化，但是相对角度不变，光照效果会变。 各项异性的一个例子,沿一个表面刷过的金属器皿有条状/辐射状的高光。 这里的各项异性和我们前面提到的各项异性过滤是一样的内涵。 BRDF 的特性 总结 BRDF 的特点 非负性：能量的分布当然不可能是负数 线性：我们可以把 BRDF 拆分计算再相加（Blinn-Phong 中高光、漫反射、全局的处理） 可逆性：交换入射出射结果不变 能量吸收：BRDF积出来结果不会变多 如果各项同性，BRDF 只有三个维度（θi−θo,ϕi,ϕo\\theta_i-\\theta_o,\\phi_i,\\phi_oθi​−θo​,ϕi​,ϕo​），而不是四个。而且可逆导致第一项只用考虑绝对值。 BRDF 的测量 实际上的 BRDF 非常复杂，所以我们可以（要）测量 BRDF，而不是（不能）仅简单使用公式。 测量方法：可以枚举所有的光照方向和观察方向。 当然，如果各向同性可以砍一个维度。 拓展：MERL BRDF Database 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-16：辐射度量学与路径追踪 Next：GAMES101-18：渲染中的高级板块","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"反射率","slug":"反射率","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84%E7%8E%87/"},{"name":"折射","slug":"折射","permalink":"http://example.com/tags/%E6%8A%98%E5%B0%84/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"微表面","slug":"微表面","permalink":"http://example.com/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"},{"name":"菲涅尔项","slug":"菲涅尔项","permalink":"http://example.com/tags/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9/"}]},{"title":"GAMES101-16：辐射度量学与路径追踪","slug":"GAMES101/GAMES101-14","date":"2023-08-06T10:11:52.000Z","updated":"2024-01-03T16:59:03.825Z","comments":true,"path":"/GAMES10114.html","permalink":"http://example.com/GAMES10114.html","excerpt":"前言 GAMES101-16:蒙特卡罗积分、路径追踪","text":"前言 GAMES101-16:蒙特卡罗积分、路径追踪 蒙特卡罗积分 数学中将随机采样来求解问题的算法统称统称为蒙特卡罗方法，如果应用在积分上就是蒙特卡罗积分。在高数中，我们采取的是求不定积分的原函数在 a,b 的差的方法来积分，但是现在我们不关心原函数又或者说求原函数过于复杂，这种时候蒙特卡罗方法就很有用了。 蒙特卡罗积分的思想如下：对于每次采样 xix_ixi​ ，求得 f(xi)f(x_i)f(xi​)。以该值估算积分：∫baf(x)=f(xi)(a−b)\\int^a_b f(x)=f(x_i)(a-b)∫ba​f(x)=f(xi​)(a−b)，随机取 N 个点进行 N 次估算取平均值，则有： ∫baf(x)=1N∑f(xi)p(xi)\\int^a_b f(x)=\\frac{1}{N}\\sum \\frac{f(x_i)}{p(x_i)} ∫ba​f(x)=N1​∑p(xi​)f(xi​)​ 其中 p(xi)p(x_i)p(xi​) 是取到该点的概率密度。这就是蒙特卡罗积分的公式，这里我们只需要关心采样方法的概率密度函数就可以积分了。 一个点的概率密度就是在该点附近的面积占整个概率函数的面积。如果均匀取点，就有 p(xi)=1a−bp(x_i) = \\frac{1}{a-b}p(xi​)=a−b1​，那么式子就变成熟悉的 1N∑f(x)p(x)\\frac{1}{N}\\sum f(x)p(x)N1​∑f(x)p(x) 了。 路径追踪 Path Tracing Whitted-Style 光线追踪对光线如下处理： 如果是光滑面的镜面反射/折射，就进行光线追踪； 如果是漫反射，就停止追踪； 而这两种处理都是存在问题的。 对于镜面反射，并不是只有能映出影像的镜面，也有抛光（Glossy）面只有高光没有清晰倒影的情况。这也就是说，这种模糊的镜面反射的反射区间比镜面反射略大。 对于漫反射面，其事实上也能产生反射效果。下图左侧展示了不考虑漫反射出的光的后果（天花板与两个立方体侧面），右侧则展现了考略的后果。 上一节的辐射度量学已经指出漫反射将光向四面八方折射的情况 这也正是通过辐射度量学来构建光线追踪的意义所在。 逐步推出路径追踪算法 接下来考虑一个简单场景中的情况：场景中有一个面光源、几个遮挡物体与待渲染点。在这个不自发光的点有 Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)cos⁡θidωiL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)cosθi​dωi​ 应用蒙特卡罗方法进行积分，均匀在半球面上进行采样： Lr(p,ωr)=∫Ω+f(x)dωi≈1N∑i=1Nf(x)p(ωi)p(ωi)=12πL_r(p,\\omega_r)=\\int_{\\Omega^+}f(x)\\mathrm{d}\\omega_i \\approx \\frac{1}{N}\\sum^N_{i=1}\\frac{f(x)}{p(\\omega_i)} \\\\ p(\\omega_i)=\\frac{1}{2\\pi} Lr​(p,ωr​)=∫Ω+​f(x)dωi​≈N1​i=1∑N​p(ωi​)f(x)​p(ωi​)=2π1​ 也就是说，在该点向外随机选择 N 个方向进行采样，如果该方向遇见一个光源，则着色结果加上该方向经过蒙特卡洛积分后的结果，就得到该点的直接光渲染结果。 如果发出射线的方向（ωi\\omega_iωi​）遇见的是物体，那么我们就将该物体往渲染点方向（−ωi-\\omega_i−ωi​）反射的光视为光源的光进行着色，这样得到的就是全局光照。 这种算法的名字叫分布式光线追踪，这种算法并没有错，但是显然，只需要数次折射，追踪的光线的数量就会指数级增长（折射 k 次，则有 NkN^kNk）条光路。这使得这种算法并不实用。 人们对这个问题的解决办法非常简单粗暴：如果每个着色点只有一个采样方向（N = 1），那么折射多少次都不会发生指数爆炸。这样的一个经过多次折射形成的线路就是一个路径。至于噪声问题，则用在一个像素上发出多条路径并取平均的方式进行解决。这就是路径追踪。 路径递归的终止条件被称为俄罗斯轮盘赌方法（Russian Roulette，RR）。即类似于俄罗斯轮盘赌，我们取定一个概率 P，每次只有 P 的概率返回值 LoP\\frac{L_o}{P}PLo​​ ，而 （1-P） 的概率返回 0。这样，返回值的期望不变，但是光线不能无限次的折射下去。 此时，我们的算法如下： 这是一个正确的路径追踪算法了，唯一的问题在于不够高效，低采样率的情况下效果并不好。 造成这种问题的原因在于我们采取了所有方向随机采样的采样方式，低采样率时到光源的方向的可能性低。 在光源采样的高效路径追踪 既然我们想采样到打到光源的路径，那么直接在光源上采样不就好了吗？ 此时，由于我们是在光源上采样，那么也就需要在光源上进行积分，因此需要将渲染方程改写到光源上。设想场景如下： 在光源上进行平均采样，则概率密度是 1A\\frac{1}{A}A1​。将立体角换到光源的立体角上有 dω=dAcos⁡θ′∥x′−x∥2\\mathrm{d}\\omega = \\frac{\\mathrm{d}A\\cos\\theta&#x27;}{\\|x&#x27;-x\\|^2} dω=∥x′−x∥2dAcosθ′​ 于是（在不被遮挡的时候） Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)dAcos⁡θ′∥x′−x∥2dAL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\frac{\\mathrm{d}A\\cos\\theta&#x27;}{\\|x&#x27;-x\\|^2}\\mathrm{d}A Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)∥x′−x∥2dAcosθ′​dA 不过这只是对光源情况的特殊考虑，对于间接光我们还是采用之前的算法并依然采用俄罗斯轮盘赌的算法，所以这时的算法形如 ： 路径追踪是很难处理点光源的情况的，我们可以把它做成很小的面光源 路径追踪是几乎 100% 正确的一种算法，其效果和照片几乎一致： 一些眺望：SideNotes 现代光线追踪的定义：不止于 Whitted-Style 光线追踪 以前，光线追踪仅仅指 Whitted-Style，现在，这个词还可以指各类光线传播的算法，例如（单向、双向）路径追踪、VCM/UPBP、光子映射（Photon Mapping）…… 如何均匀地半球面上采样：本课不涉及 如何在蒙特卡洛积分中选择最佳的概率密度函数：拓展至“重要性采样理论” RR 中随机数的生成方式很重要：Low Discrepancy Sequences （低差异序列/拟随机序列， 一种均匀分布随机数的替代序列） 结合着色点半球面与光源上的采样方法：可行，MIS（Multiple Importance Sampling） 理论 考虑对一个像素的多个路径进行加权处理 路径追踪得到的最后 Radiance 不是着色结果，也和着色结果没有线性对应关系。 色彩空间、伽马校正…… 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-14&amp;15：辐射度量学 Next：GAMES101-17：基于物理的材质（BRDF）","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"路径追踪","slug":"路径追踪","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"name":"蒙特卡洛积分","slug":"蒙特卡洛积分","permalink":"http://example.com/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"}]},{"title":"GAMES101-14&15：辐射度量学","slug":"GAMES101/GAMES101-13","date":"2023-08-04T15:18:19.000Z","updated":"2024-01-03T16:58:36.102Z","comments":true,"path":"/GAMES10113.html","permalink":"http://example.com/GAMES10113.html","excerpt":"前言 GAMES101-14:辐射度量学的意义、能量，功率与辐射强度（intensity）的定义。 GAMES101-15:辐射度量学的基本概念：辐照强度、辐射通量，BRDF，渲染方程，全局光照","text":"前言 GAMES101-14:辐射度量学的意义、能量，功率与辐射强度（intensity）的定义。 GAMES101-15:辐射度量学的基本概念：辐照强度、辐射通量，BRDF，渲染方程，全局光照 辐射度量学 为什么要研究辐射度量学：Whitted-Style 光线追踪尽管可以在一些场景表现不错，但是其建立完全是基于经验值和表现的效果的，而不是实际的物理规律，因此其值不可能完全真实准确。这就是为什么我们需要辐射度量学。 要进行严谨度量，我们就要先定义单位（中文均为个人翻译，课程中没有中文名）： 辐射能 Radiant Energy：辐射出的能量 Q (J)(J)(J)。 辐射速率/功率 Radiant flux（power）：单位时间内辐射/吸收/反射的能量。对于光源即“有多亮” .Φ=dQdt\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}Φ=dtdQ​ ，单位 W(Watt)/lm(lumen)\\mathrm{W(Watt)/lm(lumen)}W(Watt)/lm(lumen) 注意：下文和图形学中说到的能量往往是指 flux 而非 energy，因为我们总是在关心眼下发生的情况（实时）而非累计的结果。 辐射强度 Radiant Intensity：一个单位立体角的功率。 I(ω)=dΦdωI(\\omega)=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}\\omega}I(ω)=dωdΦ​，单位 cd(candela)=lmsrorWsr\\mathrm{cd(candela)=\\frac{lm}{sr}or\\frac{W}{sr}}cd(candela)=srlm​orsrW​。 类比弧度，立体角（Solid angel）是指 Ω=Sr2\\Omega=\\frac{S}{r^2}Ω=r2S​，其中 S 是对应的表面积，一个球的立体角是 4π4\\pi4π。将面积表示成半径 r、和 y 轴（竖直轴）的夹角 θ\\thetaθ、和水平面 x 轴的夹角 ϕ\\phiϕ 的组合，就有： Ω=Sr2=sin⁡θdθdϕ\\Omega=\\frac{S}{r^2}=\\sin\\theta\\mathrm{d}\\theta \\mathrm{d}\\phi Ω=r2S​=sinθdθdϕ 如果一个点光源均匀地向所有方向辐射光，那么 Intensity 就简单的有 I=Φ4πI=\\frac{\\Phi}{4\\pi} I=4πΦ​ 辐照强度 Irradiance：单位面积接收到的(投影后的)能量（flux）。 E(x)=dΦ(x)dS=ΦScos⁡θE(x)=\\frac{\\mathrm{d}\\Phi (x)}{\\mathrm{d}S}=\\frac{\\Phi}{S}\\cos \\theta E(x)=dSdΦ(x)​=SΦ​cosθ 单位 lux=lmm2\\mathrm{lux}=\\frac{lm}{m^2}lux=m2lm​。此处要求的能量与面积是垂直的，如果不垂直则需要投影。这正是 Blinn-Phong 模型中应用的“物体接收到的光取决于与法线的余弦”（Lambert's Cosine Law）的物理意义。 随着距离的增加，辐射强度 Intensity 不会发生改变，但是辐照度 Irradiance 会衰减。 辐射通量 Radiance：单位立体角且单位面积内的辐射能量。换句话说，通量就是单位立体角中的辐照度（理解吸收）或单位面积的辐射强度（理解发出）。通量是一个有方向的量。 L(p,ω)=d2Φ(p,ω)dωdScos⁡θL(p,\\omega)=\\frac{\\mathrm{d^2}\\Phi(p,\\omega)}{\\mathrm{d}\\omega\\mathrm{d}S\\cos\\theta} L(p,ω)=dωdScosθd2Φ(p,ω)​ 单位nit=cdm2nit=\\frac{\\mathrm{cd}}{\\mathrm{m^2}}nit=m2cd​。 对来自单位面积来自所有方向的辐射积分，就有该面积的所有能量。再对面积积分，则有物体的所有接收能量。 这些概念中单位相对而言并不重要，请注意理解概念本身。 BRDF：双向反射分布函数 BRDF 的作用在于，将物体吸收的能量（Irradiance）和指定角度发出（反射）的能量（Radiance）联系了起来。对于一个极小区域 dA\\mathrm{d}AdA，一束从 ωi\\omega _iωi​ 入射的辐射是： dE(ωi)=L(ωi)cos⁡θidωi\\mathrm{d}E(\\omega_i)=L(\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i dE(ωi​)=L(ωi​)cosθi​dωi​ 物体吸收后发射（或者说物体反射）辐射到不同的方向，对于一个指定的方向 ωr\\omega_rωr​，反射的能量记为 dLr(ωr)\\mathrm{d}L_r(\\omega_r)dLr​(ωr​)。 此时，可以记 BRDF 为： fr(ωi→ωr)=dLr(ωr)dEi(ωi)=dLr(ωr)L(ωi)cos⁡θidωif_r(\\omega_i\\rarr \\omega_r)=\\frac{\\mathrm{d}L_r(\\omega_r)}{\\mathrm{d}E_i(\\omega_i)}=\\frac{\\mathrm{d}L_r(\\omega_r)}{L(\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i} fr​(ωi​→ωr​)=dEi​(ωi​)dLr​(ωr​)​=L(ωi​)cosθi​dωi​dLr​(ωr​)​ BRDF 的图像描述了辐射会被反射到哪个方向，例如如果是镜面反射，那么图像就是仅在镜面反射方向有值，其他方向没有多少值。 反射方程与渲染方程 把该点的所有入射光的 BRDF 累加起来，就可以算出该点反射了多少光，即该点的反射方程： Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)cos⁡θidωiL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)cosθi​dωi​ 添加自发光项使得公式对光源也适用： Lr(p,ωo)=Le(p,ωo)+∫H2Li(p,ωi)fr(p,ωi→ωo)(n⃗⋅ωi⃗)dωi L_r(p,\\omega_o)=L_e(p,\\omega_o)+\\int_{H^2}L_i(p,\\omega_i) f_r(p,\\omega_i\\rarr \\omega_o) (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i Lr​(p,ωo​)=Le​(p,ωo​)+∫H2​Li​(p,ωi​)fr​(p,ωi​→ωo​)(n⋅ωi​​)dωi​ 此时方程就是渲染方程。需要指出的是涉及的向量的方向都是从 p 点指向外的，而且通过积分域的限制，我们排除了下半球内的积分，因为这个方向肯定不会对渲染起作用。（相当于 Blinn-Phong 模型中的那个 max() ）。而且通过积分，我们不仅可以处理多个点光源，也可以处理面光源。 全局光照 把上面的式子简单分析一下，其实就是：反射光=自发光+入射光BRDF余弦角。其中未知量只有入射光和反射光。于是我们经过一系列的简化就可以有： L=E+KLL=E+KL L=E+KL 其中 I 是单位矩阵，因为反射的和入射能量没有改变所以两侧 L 相等可以直接合并。 考虑到入射的 L 也可以是其他物体反射的 L，所以类似泰勒展开有 L=E+KL⇒L=(I−K)−1E⇒L=E+KE+K2E+K3E+…L=E+KL\\\\ \\rArr L=(I-K)^{-1}E \\rArr L=E+KE+K^2E+K^3E+\\dots L=E+KL⇒L=(I−K)−1E⇒L=E+KE+K2E+K3E+… 其中， E 即直接进入摄像机的光，KE 即直接打在物体表面的光，二次即一次物体反射的间接光照，三次即在物体上反射了两次才打到渲染物体上的光……依此类推。 光栅化可以较容易的处理前两项，但是很难处理后面的项。这也是为什么我们需要光线追踪。 将所有的光进行考虑得出的结果就是全局光照。下面给一些计算了不同次数反射的全局光照结果对比。 仅直接光（效果类似相机）： 一次弹射，直接光+间接光（E+KE+K^2E）: 两次弹射: 四次弹射(效果愈发接近人眼): 随着次数的增加，弹射对效果的影响愈发的小，也愈发的接近人眼的效果。 需要注意的是，一次和二次光照的时候，屋顶的灯光反而变黑了，这是因为这里光两次折射还没有折出灯管，因此造成了错误。 最后说了一些概率论基础，没有特别需要记的必要。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化 Next：GAMES101-16：辐射度量学与路径追踪","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"渲染方程","slug":"渲染方程","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"},{"name":"全局光照","slug":"全局光照","permalink":"http://example.com/tags/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"}]},{"title":"GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化","slug":"GAMES101/GAMES101-12","date":"2023-08-01T16:56:18.000Z","updated":"2024-01-03T16:58:22.698Z","comments":true,"path":"/GAMES10112.html","permalink":"http://example.com/GAMES10112.html","excerpt":"前言 GAMES101-14: AABB 包围盒的加速方法：均匀网格、KD-Tree 划分、BVH 划分","text":"前言 GAMES101-14: AABB 包围盒的加速方法：均匀网格、KD-Tree 划分、BVH 划分 均匀网格（Uniform Grid）/均匀空间划分 思想/步骤： 建立一个大的 AABB 包围盒包围对空间中的所有物体，包围盒划分成均匀的若干立方网格； 每个网格判断与物体（的表面）是否相交并记录； 光线穿过空间中的若干网格，如果穿过的网格是一个与物体有交点的网格，那么光线与物体就有可能有交点。此时，对物体进行求交操作；否则，不进行求交。 光线穿过网格的算法和光栅化中的扫描线算法是类似的 网格划分的疏密问题 太稀疏：加速效果不明显； 太密：引入太多无效的网格判断，效率降低； （三维空间）合适的格子数：约等于 27 * 物体数。 网格划分思想适用于大量尺度接近的物体均匀分布在空间中的情况，不适用于空间分布很不均匀的情况（局部引起太稀疏的问题） 空间划分（Spatial Partition） 均匀空间划分的明显问题在于：如果空间分布疏密不一，在大块空的地方做了许多没有必要的划分。如果对空间进行不均匀的划分那么性能就会更好。 下面例举三种划分结构： Oct-Tree（八叉树）：把三维空间划分为八份（二维则是四份），如果一块中有物体，则尝试划分得更小，否则就停下这一块的继续划分。 这种划分方式的问题在于，划分数量与空间维度有关，不同维度的空间会形成了不同的数据结构。 BSP-Tree：从不同方向用线/平面/超平面二分空间。这种方式高维难以计算且破坏 AABB 的简单性。 KD-Tree：每次沿一个维度切一刀，例如三维空间就可以依次沿 x，y，z 轴切，二维则沿 x，y 轴切，从而使划分与空间维度无关。最后会形成一个二叉树。 这一部分与多媒体数据课在向量空间归类的思想很相似 KD-Tree 为树设计的数据结构应该： 在内部节点上： 划分轴：此结点应该被哪个轴划分 划分位置：轴在哪个位置坐标划分 子结点指针 不存储内部有哪些物体 叶子结点：存储内部有哪些物体 当光线进入一个空间划分区： 如果该区域有交点，那么检查是否是叶子结点 是：检查是否与内部物体有交点 否：检查与哪个子划分有交点 和该区域无交点：什么都不用做 不过，KD-Tree 也有自己的问题，如： 难以判断三角形与空间盒的相交情况：例如一个小盒子，三个顶点都在盒子外但是面与盒子有交集的情况。 一个物体可能会被划分到多个盒子里，多次检测。 物体划分：BVH（Bounding Volume Hierarchy） BVH 的特点在于是按物体而非空间进行划分，对于一个包围盒，递归地将其划分为子空间并计算子空间的子包围盒的边界。重复这个过程，直到盒子足够小（例如大致都有 x 个 物体）即可。数据结构上，同样是叶子结点存物体的树。 划分维度上可以有许多技巧，例如类似 KD-Tree 的依次轮换维度，或者每次从盒子最长的维度划分；抑或着每次从中间物体的位置划分。总之，应该尽量让空间划分均匀。 存在O（N）算法找到中位数，快速选择算法。 需要注意，由于是按物体进行划分，从空间上来说，包围盒之间可以相交。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-12&amp;13：Whitted-Style 光线追踪（1） Next：GAMES101-14&amp;15：辐射度量学","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"均匀网格","slug":"均匀网格","permalink":"http://example.com/tags/%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC/"}]},{"title":"GAMES101-12&13：Whitted-Style 光线追踪（1）","slug":"GAMES101/GAMES101-11","date":"2023-08-01T04:32:02.000Z","updated":"2024-01-03T16:58:07.621Z","comments":true,"path":"/GAMES10111.html","permalink":"http://example.com/GAMES10111.html","excerpt":"前言 GAMES101-12:光栅化下的处理思路：阴影映射、软阴影 GAMES101-13:Whitted-Style 光线追踪与求交问题、AABB 包围盒","text":"前言 GAMES101-12:光栅化下的处理思路：阴影映射、软阴影 GAMES101-13:Whitted-Style 光线追踪与求交问题、AABB 包围盒 光栅化下的阴影处理：阴影映射（Shadow Mapping ） 着色是一种局部现象，不考虑整体因此处理不了阴影，为此，人们发明了 Shadow Mapping。 Shadow Mapping 的思路：一个点不在阴影含义是，这个点必须同时被光源和摄像机看到。 步骤： 从光源做一次光栅化，记录光源看到的点的深度信息。（不用进行着色） 从摄像机做一次光栅化，对每个点投影回去，如果和“从光源看”的深度指向的点不一致，那么说明这个点在阴影里，否则不在阴影里。 Shadow Mapping 的特点： 不需要知道场景的几何信息； 阴影会产生走样现象：光源处分辨率的限制； 阴影带来巨大开销； 只能处理硬阴影：即要么是阴影，要么不是阴影的情况； 只能处理点光源 浮点数对比有的时候有很多脏数据； 光栅化下也有一些软阴影处理方案，此处不加以介绍。通常都比较麻烦而且不一定准确。 软阴影 软阴影即介于阴影和无阴影之间的的边界是软边界，模糊过渡的一种阴影。产生这种现象的原因是光源本身有不可忽略的大小，即非点光源。 一个例子是日食下的日月，光源太阳不是点光源。如果地球上一地区完全接收不到太阳光，那么这个地方就在月亮的硬阴影里；如果太阳被月亮挡住了部分，那么就是月亮的软阴影部分；否则，完全不被挡住，无阴影。 Whitted-Style 光线追踪 光栅化通常都是快速且近似的方法，光线追踪通常都比较慢。 光线追踪对光线的约束（尽管这些在物理学中不一定正确） 光沿直线传播； 光线之间不相互碰撞； 光从光源出发，抵达人的眼睛，并且光路可逆； 光线投射 从眼睛（一个点）发出光线（eye ray）经过屏幕上一个像素打到物体表面得到一个交点，这个交点就是需要被着色的点（因此光线追踪不需要深度测试）。 如果光源发出的线（shadow ray）可以直接打到该点，就会有一次着色，否则结束。 这个点经过反射、折射（如果有）得到的二次交点们同样检查是否被 shadow ray 照亮。 把二次交点们发出的折射/反射的光（记为 second ray）对一次交点的着色结果累加到一次交点。 对二次交点当然也可以递归上述过程。 求交点 光线是一个有起点的射线，我们如下定义 r(t)=o+td⃗(0≤t&lt;∞)r(t)=o+t\\vec{d} (0\\leq t&lt;\\infty) r(t)=o+td(0≤t&lt;∞) 其中向量 d 是单位向量表示方向。 对一个隐式几何表面 f(x,y,z)=0f(x,y,z)=0f(x,y,z)=0 求交就是说 f(r(t))=f(o+td⃗)=0f(r(t))=f(o+t\\vec{d})=0 f(r(t))=f(o+td)=0 当然多个交点时取最近的。 对于一个显式几何，最简单的办法是对每个三角形求交。思想如下： 首先求射线和三角形所在平面的交点； 射线如上表示为 r(t)r(t)r(t)，平面表示为点 p′p&#x27;p′ 和法线 N⃗\\vec{N}N 的组合。就有 平面上一点表示为 (p−p′)⋅N⃗=0(p-p&#x27;)\\cdot\\vec{N}=0(p−p′)⋅N=0，代入有 (o+td⃗−p′)⋅N⃗=0(o+t\\vec{d}-p&#x27;)\\cdot\\vec{N}=0 (o+td−p′)⋅N=0 于是 t=(p′−o)⋅N⃗d⃗⋅N⃗ (0≤t)t= \\frac{(p&#x27;-o)\\cdot\\vec{N}}{\\vec{d}\\cdot\\vec{N}} \\ \\ \\ (0\\leq t)t=d⋅N(p′−o)⋅N​ (0≤t) 然后判断是否在三角形内。例如使用叉积 或直接应用 Moller Trumbore 算法： 用三角形的重心坐标有： O⃗+tD⃗=(1−b1−b2)P0⃗+b1P1⃗+b2P2⃗\\vec{O}+t\\vec{D}=(1-b_1-b_2)\\vec{P_0}+b_1\\vec{P_1}+b_2\\vec{P_2} O+tD=(1−b1​−b2​)P0​​+b1​P1​​+b2​P2​​ 其中 O⃗\\vec{O}O、N⃗\\vec{N}N、Pi⃗\\vec{P_i}Pi​​ 都是三个数的坐标，应用克莱默法则即可求解。 若 (1−b1−b2)(1-b_1-b_2)(1−b1​−b2​)、b1b_1b1​、b2b_2b2​ 都满足重心坐标系的要求（在 [0,1] 之间）那么就说明和三角形相交。 我们还可以 隐式三角形求交的优化算法：AABB 包围盒 现代模型往往有百千万级别的面数，如果依次按上述方法求交，无疑太慢了。对此的一种改进方法是包围盒：用一个简单图形（例如长方体）包围模型，如果和这个包围盒都无交点，那就不需要求和模型的交点。 如果将包围盒定义为三个方向的面都平行于一个轴面，那三个方向就都可以都简单记为一个 x/y/z 轴上区间的情况，这种包围盒就叫 AABB 包围盒（Axis-Aligned Bounding Box，轴对齐包围盒）。 AABB 包围盒的好处： 对于普通包围盒： t=p′−o⋅Nd⋅Nt=\\frac{p&#x27;-o\\cdot N}{d\\cdot N} t=d⋅Np′−o⋅N​ 对于轴对齐包围盒(以 x 轴为例)： t=px′−oxdxt= \\frac{p&#x27;_x-o_x}{d_x} t=dx​px′​−ox​​ 对每个轴上的对立面求进入的“时间”和离开的时间，中间的差即在两个面之间的时间。对三个对立面分别这样处理，并取交集，即 tenter=max(tin)t_{enter}=max(t_in)tenter​=max(ti​n) 且 tleave=min(tout)t_{leave}=min(t_out)tleave​=min(to​ut)，那么就能得到光线在 AABB 包围盒中滞留的时间。进行分析： tenter&gt;0t_{enter}&gt;0tenter​&gt;0 且 tleave&gt;tentert_{leave}&gt;t_{enter}tleave​&gt;tenter​，正常地和 AABB 盒相交； tenter&lt;0t_{enter}&lt;0tenter​&lt;0 且 tleave&gt;0t_{leave}&gt;0tleave​&gt;0，光源在 AABB 盒内，到处都相交； tleave&lt;0t_{leave}&lt;0tleave​&lt;0 ，盒子在光源后面，没有实际的交点。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-11&amp;12：曲线与面 Next：GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"软阴影","slug":"软阴影","permalink":"http://example.com/tags/%E8%BD%AF%E9%98%B4%E5%BD%B1/"},{"name":"阴影映射","slug":"阴影映射","permalink":"http://example.com/tags/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"Whitted-Style 光线追踪","slug":"Whitted-Style-光线追踪","permalink":"http://example.com/tags/Whitted-Style-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"求交点","slug":"求交点","permalink":"http://example.com/tags/%E6%B1%82%E4%BA%A4%E7%82%B9/"}]},{"title":"GAMES101-11&12：曲线与面","slug":"GAMES101/GAMES101-10","date":"2023-07-31T06:53:48.000Z","updated":"2024-01-03T16:57:48.515Z","comments":true,"path":"/GAMES10110.html","permalink":"http://example.com/GAMES10110.html","excerpt":"前言 GAMES101-11:贝塞尔曲线与B样条 GAMES101-12:贝塞尔曲线与B样条","text":"前言 GAMES101-11:贝塞尔曲线与B样条 GAMES101-12:贝塞尔曲线与B样条 贝塞尔曲线 Bézier Curve 贝塞尔曲线要求给定多于两个点，那么从第一个首尾两个点决定始末，中间的点决定倾向（往哪里弯）。 德卡斯特里奥算法（de casteljau's algorithm）有一种简单的递归画贝塞尔曲线的方法： 假设我们依次有四个点 b0,b1,b2,b3b_0,b_1,b_2,b_3b0​,b1​,b2​,b3​，即三次贝塞尔曲线；一个点在曲线上运动，定义时间t = 0的时候在起点 b1b_1b1​，t = 1 在终点 b0b_0b0​。 连接 b0,b1,b2,b3b_0,b_1,b_2,b_3b0​,b1​,b2​,b3​，找到三条连线线上的 t 位置，定义此点为 b01b^1_0b01​、b11b^1_1b11​、b21b^1_2b21​； 连接 b01b^1_0b01​、b11b^1_1b11​、b21b^1_2b21​，继续找 t 时刻位置得到 b02b^2_0b02​、b12b^2_1b12​； 连接 b02b^2_0b02​、b12b^2_1b12​ 找 t 位置的点 P(b03b^3_0b03​)； P 就是时间 t 的时刻贝塞尔曲线上的点。 下面给出代数写法。 对第一次递归的点可以写成形如 b01=(1−t)b0+tb1b_0^1 = (1-t)b_0+tb_1b01​=(1−t)b0​+tb1​ 的形式； 第二次递归的点等于b02=(1−t)b01+tb11=(1−t)2b0+2t(1−t)b1+t2b2b_0^2 = (1-t)b_0^1+tb_1^1=(1-t)^2b_0+2t(1-t)b_1+t^2b_2b02​=(1−t)b01​+tb11​=(1−t)2b0​+2t(1−t)b1​+t2b2​，可以看到系数是二次项展开的形式； 第 n 次递归同理…… 最终有 bn(t)=∑j=0nbjBjn(t)b^n(t)= \\sum^n_{j=0}b_jB^n_j(t) bn(t)=j=0∑n​bj​Bjn​(t) 其中 bin(t)=Cinti(1−t)n−i=(ni)ti(1−t)n−ib_i^n(t)= C_i^nt^i(1-t)^{n-i}=\\binom{n}{i}t^i(1-t)^{n-i} bin​(t)=Cin​ti(1−t)n−i=(in​)ti(1−t)n−i 其中 tit^iti 前面的系数都是在表示组合数。 贝塞尔曲线的一些性质： 曲线的起点是第一个给出点，终点是最后一个点； 对于最常用的三次贝塞尔曲线，起点处斜率为 b′(0)=3(b1−b0)b&#x27;(0)=3(b1-b0)b′(0)=3(b1−b0)，终点处为 b′(3)=3(b3−b2)b&#x27;(3)=3(b3-b2)b′(3)=3(b3−b2)； 对贝塞尔曲线仿射变换等于对点进行仿射变换再求其贝塞尔曲线； 贝塞尔曲线一定在给定点的凸包内； 凸包：想象一个撑在几个钉子上的橡皮筋，橡皮筋即钉子们的凸包 分段贝塞尔曲线与连续 多次贝塞尔曲线存在的问题：多次贝塞尔曲线点对线的控制不够直观明显，很难体现具体一个点对曲线的影响。 因此，最常用的贝塞尔曲线是三次贝塞尔曲线，通过拼接多个贝塞尔曲线形成长曲线。这样一来，我们就需要考虑在拼接处的连续问题。要讨论两段曲线是否连续，我们先定义连续的概念： G0G^0G0(C0C^0C0)连续：两个曲线在该点首尾相连 G0G^0G0：拼接点切向量方向相同 C0C^0C0：拼接点切向量方向和大小均相同 GnG^nGn：拼接点切向量从 1 阶直到 n 阶导数的方向相同 CnC^nCn：拼接点切向量从 1 阶直到 n 阶导数的方向和大小均相同 其中 CiC^iCi 叫参数连续，GiG^iGi 叫几何连续。 B 样条 样条：一条可控的曲线，分段定义的多项式参数曲线。 早期工程制图时，制图者将一段柔性的条板固定住，中间用一些钉子等工具迫使条板弯曲并固定来得到一条需要的曲线。这个条板就是样条。 B 样条是指基函数样条（basis spline）。B 样条是贝塞尔曲线的一种一般化，在贝塞尔曲线里基函数是伯恩斯坦多项式。B 样条有一些很好的性质，例如局部性：更改一个点不会影响到整条曲线而可以只修改其局部。 一个基函数空间里，所有的函数可以用基函数的线性组合表示。 伯恩斯坦多项式里，每一个项是一个基函数。 贝塞尔曲面 在两个方向都进行贝塞尔曲线，例如水平方向每隔一段进行一次贝塞尔，然后竖直方向上没处把对应的取值作为控制点进行贝塞尔。 网格的几何处理 网格细分：网格拆分为更细的网格，并使模型变得更光滑； 网格简化：网格太细合为更大的网格； 网格正则化：让网格更接近“正”图形（如正三角形），减少网格的依赖。 网格细分 网格细分的两步操作：分出更多的网格、调整顶点位置使得模型更光滑。 Loop 细分 请注意这里的 Loop 是人名而非循环 步骤： 将一个三角形的中点连接，分成四个小三角形，这些中点是新的顶点； 对于新顶点，其在两个三角形的公用边上。假定此边两个老顶点为 AB，非此边上的老顶点为 CD。那么新顶点的位置改为：38(A+B)+18(C+D)\\frac{3}{8}(A+B)+\\frac{1}{8}(C+D)83​(A+B)+81​(C+D); 对于老顶点，其是多个三角形的共用顶点。那么它的新位置为P′=(1−nu)P0+u∑PiP&#x27;=(1-nu)P_0+u\\sum P_iP′=(1−nu)P0​+u∑Pi​，其中 P0P_0P0​ 是该点原本坐标，PiP_iPi​ 是与其通过一条边直接连接的点的坐标； n 是该点的度，即有多少个边与之相连； 若 n=3，则 u=316u=\\frac{3}{16}u=163​，否则，u=38nu=\\frac{3}{8n}u=8n3​ 老顶点的公式暗示：一个点如果连接的点越多，那么这个点的新坐标受周围点的影响就越大，否则，受自己的影响更大。 Catmull-Clark 细分 Catmull-Clark 可以对任意情况的网格使用而不局限于三角形网格。 定义奇异点：任何度不为 4 的顶点。 步骤： 每个边的中点和每一个面的中点都是新的顶点，并且连接一个面内的边中点和面中点； 经过这么一次细分以后，所有的非四边形面都不见了，而且同时会增加原本非四边形面那么多的奇异点。 对于 面中点：四个相邻老顶点的平均 边中点：两个相连的老顶点和两个面中点的平均 老顶点：四个面中点的一倍、四个边中点的两倍、本身位置的四倍的和进行平均 网格简化 有时我们希望在保留整体大致形状的情况下减少面的数量降低运算的压力，就需要网格简化。一种网格简化算法是边坍缩。边坍缩即把一个边两边的点挪动到一起使得该边“坍缩消失”。为了解决哪些边应该坍缩、探索后的点应该在哪的问题，我们则需要使用到二次误差度量算法。 二次度量误差：坍缩后的点的位置是原先有关面上点的距离的平方和（L2距离）的最小值的位置。 于是算法的核心思想：维护一个优先队列存储每条边坍缩会带来的二次度量误差，依次坍缩带来误差小的边，并更新受影响的边的误差值。 这是一种贪心算法，但是整体的效果还是不错的 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-10&amp;11：隐式几何与显式几何 Next：GAMES101-12&amp;13：Whitted-Style 光线追踪（1）","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://example.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"},{"name":"B 样条","slug":"B-样条","permalink":"http://example.com/tags/B-%E6%A0%B7%E6%9D%A1/"},{"name":"网格简化","slug":"网格简化","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96/"},{"name":"网格细分","slug":"网格细分","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%BB%86%E5%88%86/"},{"name":"Loop 细分","slug":"Loop-细分","permalink":"http://example.com/tags/Loop-%E7%BB%86%E5%88%86/"},{"name":"Catmull-Clark 细分","slug":"Catmull-Clark-细分","permalink":"http://example.com/tags/Catmull-Clark-%E7%BB%86%E5%88%86/"}]},{"title":"GAMES101-10&11：隐式几何与显式几何","slug":"GAMES101/GAMES101-9","date":"2023-07-30T16:24:59.000Z","updated":"2024-01-03T16:57:36.559Z","comments":true,"path":"/GAMES10109.html","permalink":"http://example.com/GAMES10109.html","excerpt":"前言 GAMES101-10:隐式几何","text":"前言 GAMES101-10:隐式几何 GAMES101-11:显式几何 用三角形面并不能很好的面对所有的情形，例如：庞大的城市如何简化远景、狗身上繁复细密的毛发、轻薄半透的纱衣…… CG 中将几何分为隐式几何与显式几何。下面分别讨论。 隐式几何 隐式几何：不指明点的位置，但是指明点的关系。例如 x2+y2+z2=1x^2+y^2+z^2=1x2+y2+z2=1。更通用地，隐式几何指明 f(x,y,z)=0f(x,y,z)=0f(x,y,z)=0。 隐式几何很难判断有满足条件的点都有哪些，但是很容易知道指定的一个点是否满足条件（在几何面上）。 在简单的几何情况下，我们容易写出f（x），但是几何体过于复杂时，虽然也可以找到合适的函数（傅里叶？），但是我们可以采用构造实体几何（CSG）的办法： 构造实体几何：对基本的隐式几何体进行基本的布尔运算（交并补等）得到复杂的几何（参考工图作业图）。 此外对于隐式几何我们还可以用距离函数： 距离函数：对任意一个点定义与几何体的，例如在面上距离为 0，面外为正，面内为负。 通过距离函数我们可以实现两个图形相融合的效果（空间中的点同时受到两个面的距离的拉扯），例如 空间中的一个点在图形 AB 的距离分别是 a，b，那么最后距离为 a+b，最后找出 a+b = 0 的地方就是融合后的新面上的地方。 为了表示好复杂情况下的等距离点的集合，我们应用水平集这个概念表示同一个水平线的点的集合，类似等高线。 如果定义在三维，存储为纹理图，那么我们就可以找到一个有同一特征的面形成纹理。 隐式几何我们还可以很方便的表示分形图形。 显式几何 显示几何的定义方法是直接给出（例如前面章节提到的三角形面）或参数映射（例如每个 （u，v）都能映射到一个（x，y，z））。 相对地，显式几何难以判断点是否在几何面上。 显式几何的一些例子： 点云：用一堆点表示面，可以表示任何图形，通常会被转化成多边形面。 多边形面：用多个三角形面拼接成图形 obj格式：一种存储模型的格式，存储用点和点的联系关系。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-9&amp;10：纹理映射的具体内容 Next：GAMES101-11&amp;12：曲线与面","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"隐式几何","slug":"隐式几何","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"显式几何","slug":"显式几何","permalink":"http://example.com/tags/%E6%98%BE%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"构造实体几何","slug":"构造实体几何","permalink":"http://example.com/tags/%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95/"},{"name":"距离函数","slug":"距离函数","permalink":"http://example.com/tags/%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0/"}]},{"title":"GAMES101-9&10：纹理映射的具体内容","slug":"GAMES101/GAMES101-8","date":"2023-07-29T06:00:12.000Z","updated":"2024-01-03T17:01:44.941Z","comments":true,"path":"/GAMES10108.html","permalink":"http://example.com/GAMES10108.html","excerpt":"前言 GAMES101-9:重心坐标、映射办法、纹理应用。 GAMES101-10:纹理应用。","text":"前言 GAMES101-9:重心坐标、映射办法、纹理应用。 GAMES101-10:纹理应用。 插值与重心坐标系 Gouraud 和 Phong 着色模型都要求在三角形内部插值，只是插值的不同，为了解决这个问题，我们应用重心坐标系。 对于任意三角形 △ABC\\triangle ABC△ABC 所在平面内点 P 有： P(x,y)=αA+βB+γCα+β+γ=1P(x,y) = \\alpha A + \\beta B + \\gamma C \\\\\\alpha+\\beta+\\gamma=1 P(x,y)=αA+βB+γCα+β+γ=1 当点在三角形内，则 α β γ\\alpha\\ \\beta\\ \\gammaα β γ 均为非负数。 这就是重心坐标系，通过重心坐标系，我们可以将三角形内的点坐标写成 (α,β,γ)(\\alpha,\\beta,\\gamma)(α,β,γ) 的形式。 已知 P 点的坐标，求重心坐标的办法如下： 连接 PA、PB、PC，把 △ABC\\triangle ABC△ABC 分成三个小三角形 △ABP\\triangle ABP△ABP、△APC\\triangle APC△APC、△PBC\\triangle PBC△PBC。 定义一个顶点对应的小三角形是与它不相邻的小三角形。如 A 对应 △PBC\\triangle PBC△PBC 定义三角形面积为 SSS 由于三角面积S=12l⋅h=12∣a⃗∣∣b⃗∣sin⁡θ=12∣a⃗×b⃗∣S=\\frac{1}{2}l\\cdot h=\\frac{1}{2}|\\vec{a}||\\vec{b}|\\sin\\theta=\\frac{1}{2}|\\vec{a}\\times \\vec{b}|S=21​l⋅h=21​∣a∣∣b∣sinθ=21​∣a×b∣，有：α=S△AS=BP⃗×BC⃗BA⃗×BC⃗β=S△BS=AP⃗×AC⃗BA⃗×BC⃗γ=S△CS=1−α−β\\alpha=\\frac{S_{\\triangle A}}{S}=\\frac{\\vec{BP}\\times\\vec{BC}}{\\vec{BA}\\times\\vec{BC}}\\\\ \\beta=\\frac{S_{\\triangle B}}{S}=\\frac{\\vec{AP}\\times\\vec{AC}}{\\vec{BA}\\times\\vec{BC}}\\\\ \\gamma=\\frac{S_{\\triangle C}}{S}=1-\\alpha-\\beta\\\\ α=SS△A​​=BA×BCBP×BC​β=SS△B​​=BA×BCAP×AC​γ=SS△C​​=1−α−β 当 α β γ\\alpha\\ \\beta\\ \\gammaα β γ 均为 13\\frac{1}{3}31​ 时，该点就是三角形的重心。重心将三角形分为三个面积相等的小三角形。 写成坐标就是： α=(y−yB)(xC−xB)−(x−xB)(yC−yB)(yA−yB)(xC−xB)−(xA−xB)(yC−yB)\\alpha=\\frac{(y-y_B)(x_C-x_B)-(x-x_B)(y_C-y_B)}{(y_A-y_B)(x_C-x_B)-(x_A-x_B)(y_C-y_B)} α=(yA​−yB​)(xC​−xB​)−(xA​−xB​)(yC​−yB​)(y−yB​)(xC​−xB​)−(x−xB​)(yC​−yB​)​ 这个公式没啥记忆的必要，知道向量形式公式咋来就行。 此外还需要注意，由于重心坐标没有投影不变性，因此插值应该在投影前完成而非投影后。 纹理映射 下面是一个简单的纹理映射逻辑： 我们已经知道了每个顶点对应的uv坐标是什么 对于每个像素/屏幕采样点的坐标 插值得到 uv 坐标 查询 uv 坐标对应的值 texcolor 像素的“颜色”（通常来说，漫反射系数）就设为 texcolor。 纹理放大带来的问题 如果纹理太小，分辨率太高，那么就相当于放大了纹理，每个像素求得的 uv 坐标将是小数。此时查询 uv 坐标的 texcolor 我们可以这么做： 对非整数的 uv 坐标直接取整：会导致多个连续像素对应同一个纹素（texel），导致马赛克。 双线性插值：综合考虑上下左右四个纹素的远近关系进行插值，像素过渡更自然连续。 双三次插值：综合考虑最近 16 个纹素的远近关系进行插值，像素过渡更自然连续，但是开销也比双线性更大。 纹理过小带来的问题 如果纹理太细小，那么一个像素对应太大的纹理区域，那么直接采样带来的结果和之前光栅化采样类似，采样频率过于稀疏，导致走样，产生摩尔纹锯齿等现象。超采样能解决问题，但是开销巨大，其他的一些解决办法是： Mipmap Mipmap 可以进行快速、近似、方形的一个范围内的平均值查询。 Mipmap 的思路是，如果使用范围查询，快速查询像素对应区域内纹素的平均值，那么也就不需要采样（点查询），也就规避了采样的问题了。 点查询即给定一个点查询对应点的值，范围查询则要求查询一个范围内的值，具体到此处是平均值。 Mipmap 会对每个图像不断构造分辨率变为原来 12×12\\frac{1}{2}\\times\\frac{1}{2}21​×21​ 后的图像形成层级关系。例如第零层是原图 128×128，那么第一层是 64×64，第二层是 32×32……依此类推。通过数学可以简单地证明这样做带来的开销并不算很大，极限多占用额外的 13\\frac{1}{3}31​ 空间。 Mipmap 也就是计算机视觉中的图像金字塔。 对于一个像素，我们求得它的覆盖的正方形面积（通过求它的邻居映射到哪个 uv 坐标取距离中间值或直接取像素四边对映射坐标等等）。根据边长为 L ，它对应的层级是D=log⁡2LD = \\log_2LD=log2​L,于是取在该层 mipmap 的值即可。 如果求得层级是非正数，那么直接舍入会带来割裂感。我们可以使用插值的办法解决 1.8 层这样的问题。 三线性插值：在下舍的层级进行双线性插值；在上入的层级进行双线性插值，最后对两层结果进行线性插值。 Mipmap 并不是完美的，下图展示了 由于 Mipmap 和三线性插值“平均”的特点导致远处过糊的问题。 各向异性过滤 各向异性过滤对 x 轴、y 轴可以单独压缩，通过这种方式，我们可以解决一个像素对应一个长方形纹理区域的问题，从而带来更好的效果。但是，各向异性过滤不能解决斜向四边形等问题。 各项异性过滤的极限是原图储存的三倍，而非三分之一。 纹理映射的应用 从 GPU 的角度看：纹理就是一段存在内存中的数据，GPU 可以对其进行点查询或范围查询。由此可以 启发我们对纹理映射的应用。 环境光照/环境光映射：记录哪个位置有（直接/间接）光形成纹理图，映射以后就能得到一种类似镜子的、看到周围环境的效果。 环境光映射球/立方：我们可以用“一个绝对光滑的球”记录一个环境里所有的光照来源方向。 凹凸贴图：定义一个点相对于附近的点的高度改变法线方向结果或者直接定义其法线方向，从而得到橘子皮似的凹凸表现结果。 首先计算出原来的法线（插值），求其在 uv 方向的偏导数，进而得到其垂直的法线结果，也就是我们要的“假法线”。 位移（displace ment）贴图：真的去偏移顶点而不是欺骗眼睛。 凹凸贴图的缺点是图像的边缘不会真的变得凹凸出现错误，内部的假凹凸也不会在邻近区域产生阴影。 但是位移贴图要求模型足够细，采样跟得上位移偏移的变化的频率。 3D纹理：通过三维噪声生成纹理贴图，达到处处有贴图的效果，即使一个物体被劈开，内部依然可以得到对应的贴图。 预计算着色：把着色结果记录在纹理图中。例如眉毛下对眼睛产生的阴影，规避一些影子计算的问题。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-7&amp;8：着色、纹理与图形管线 Next：GAMES101-10&amp;11：隐式几何与显式几何","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"重心坐标","slug":"重心坐标","permalink":"http://example.com/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"},{"name":"Mipmap","slug":"Mipmap","permalink":"http://example.com/tags/Mipmap/"},{"name":"线性插值","slug":"线性插值","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"}]},{"title":"GAMES101-7&8：着色、纹理与图形管线","slug":"GAMES101/GAMES101-7","date":"2023-07-26T13:01:54.000Z","updated":"2024-01-03T16:54:03.283Z","comments":true,"path":"/GAMES10107.html","permalink":"http://example.com/GAMES10107.html","excerpt":"前言 GAMES101-7、GAMES101-8:着色（Shading）、Blinn-Phong 着色模型、着色频率、纹理映射、图形管线","text":"前言 GAMES101-7、GAMES101-8:着色（Shading）、Blinn-Phong 着色模型、着色频率、纹理映射、图形管线 仅仅进行光栅化是不够的。想象一个纯色的方块，将它放在空间中，如果四面的颜色是一致，那么我们反而会觉得不够真实。因为我们期待会有明暗变化。也就是 Shading。 注：从本节开始，所引用的图片既有来源于 GAMES101 课程截图，亦有来源于西安电子科技大学《计算机图形学》课程的课件。 着色 Shade 指的是对物体对阳光遮挡产生的阴影。在绘画领域（例如素描）中，绘画者使用不同浓淡、疏密的墨水/线条来表现光线的明暗变化，这样的过程被叫做 Shading。在计算机图形学领域，Shading 基本上做的依然是这种工作，即根据表面和光线等条件确定表面的颜色。 shade 不等于 shadow，我们在这里只关注物体本身的明暗变化，不关心阴影的产生 定义一些概念 定义下面这么一些概念 着色点 p 着色点 p 的性质，例如颜色、闪亮程度（反光） 法线向量 n：垂直于 p 局部表面指向外面 观察者方向 v：从 p 指向观察的眼睛的方向 光线方向 l：从 p 指向光源的方向 Blinn-Phong 反射模型 模型将光分为三种： 高光区域：被光直接打到发生镜面发射的区域 漫反射区域：被光直接打到发生漫发射的区域 环境光区域：没有直接被光打到但是被其他地方反射出来的光照亮的区域 下面依次讨论 漫反射公式 我们认为漫反射会把光均匀的反射给所有的方向。此时，影响 shading 的因素是 这个局部平面接受到了多少来的光 接收到的光有多强 物体反射光的强度：我们知道物体表面会吸收一些光反射一些光 一个表面对于一束光线能接收到多少我们认为取决于法线方向与光线方向的夹角余弦值 cos⁡θ=n⃗⋅l⃗\\cos \\theta = \\vec{n}\\cdot\\vec{l}cosθ=n⋅l。 如果我们已经知道点光源向所有方向散发出的光强总共是 III，那么在距离点光源 rrr 的位置，总共 III 的光的强度（能量）散布在以 rrr 为半径的球上。球上任意一点的光强就是Ir2\\frac{I}{r^2}r2I​ 于是得到如下漫反射着色公式 Ld=kdIr2max(0,n⃗⋅l⃗)L_d=k_d\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{l}) Ld​=kd​r2I​max(0,n⋅l) 其中，max 函数的作用是丢弃从法线方向的反方向传过来的光线，kdk_dkd​ 是反射系数。 如果定义表面对 RGB 三色的不同反射系数，也就定义了表面对不同光的吸收程度。换言之，定义了物体表面的颜色。 下面是光源和位置不变时，不同 kdk_dkd​ 对物体表现的影响。 注意，漫反射意味着从任何方向看亮度都是一致的，这个定义没有暗示漫反射区域的亮暗。 高光公式 高光区域接近于产生镜面反射，我们只有在接近反射方向的时候才能看见明亮的光。 求光源方向 lll 关于 nnn 对称的 l′l&#x27;l′ 与观察方向 vvv 的接近程度比较不方便。衡量观察方向是否接近采用的方法如下： 求 lll 和 vvv 的角平分线方向上的向量（半程向量）hhh：由于 lll 和 vvv 都是单位向量，因此很方便地有h⃗=v⃗+l⃗∣∣v⃗+l⃗∣∣\\vec{h} = \\frac{\\vec{v}+\\vec{l}}{||\\vec{v}+\\vec{l}||} h=∣∣v+l∣∣v+l​ 计算 h⃗\\vec{h}h 和 n⃗\\vec{n}n 的余弦值 cos⁡α\\cos \\alphacosα 于是得到如下高光着色公式 Ls=ksIr2max(0,n⃗⋅h⃗)pL_s=k_s\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{h})^p Ls​=ks​r2I​max(0,n⋅h)p 其中指数 p 是控制高光大小的，即定义多接近反射方向算“接近”。通常取值在 100~200 下图展示了 cos 函数随指数的变化 下图展示了系数对高光的影响 环境光公式 环境光在不同的物体之间来回反射，我们简单地认为环境光是一个常量。公式为 La=kaIaL_a = k_aI_a La​=ka​Ia​ IaI_aIa​ 是环境光的强度，LaL_aLa​ 是环境光在物体表面造成的亮度 着色频率 前面讨论的模型是针对一个着色点进行的，着色频率即选取着色点的疏密。 有三种着色的方式，它们有不同的着色频率： Flat 着色：对一个面选取一个着色点，以该着色点的结果对整个面着色； Gouraud 着色：把每个顶点视为着色点，面内部的颜色使用线性插值得到；下面是计算插值的两种方式： 直接插值 增量法：利用前一步的计算结果加上增量得到当前的结果 当扫描线增加一个单位变为 y+1y+1y+1，对线上的点A、B 2.当逐个处理非线上的点，xxx 变为 x+1x+1x+1 Phong 着色：对面上的每一个像素点都进行着色，这些面内的着色点的法线方向是根据顶点法线方向插值得到。法线方向插值公式如下： 通常地说，Flat 着色（均匀着色）的着色结果最不准确；Gouraud 着色更加精细，但是也会有高光错误的问题；Phong 模型在三者中最精细但是计算量也远大于前二者。但是这种区别不是绝对的，随着技术的进步，如今模型的面数越来越多。而在面够多够小的情况下，Gouraud 甚至 Flat 也能取得不错的效果，当然，这种情况下由于面太多，它们的计算量也会升高。 如果面数多余像素数，那么 flat shading 的着色频率甚至比 phong shading 还高 点的法线向量的求法 数学告诉我们面的法线向量的求法（利用法线与所有面内向量垂直的特性），对于每个顶点，我们定义它的法线向量是它邻接的面的法线向量的（加权）平均： Nv=∑iNi∥∑iNi∥N_v = \\frac{\\sum_iN_i}{\\|\\sum_iN_i\\|} Nv​=∥∑i​Ni​∥∑i​Ni​​ 使用面积进行加权则： Nv=∑iSiNi∥∑iSiNi∥N_v = \\frac{\\sum_iS_iN_i}{\\|\\sum_iS_iN_i\\|} Nv​=∥∑i​Si​Ni​∥∑i​Si​Ni​​ 面内像素法线求法见上面 Phong 着色部分 图形管线（实时渲染管线） 简单地说，渲染管线就是将从 MVP 变换至今的所有流程组合在一起的过程（类似流水线的概念） 简要解读，步骤如下： 顶点处理： MVP 变换、顶点着色； 三角形处理：屏幕空间中的点生成三角形； 只要知道点和点之间的关系，我们没有必要对边进行 MVP，对点进行就够了 光栅化：打散成 fragment：每个 fragment 通常对应一个像素，但是如果应用 MSAA 等，那么多个也就 fragment 才能对应一个像素了； fragment 处理：对 fragment 进行深度检测、（可见的像素）着色； 帧缓存操作：放入缓存（buffer）中输出。 着色与着色器（Shader） 着色有两个可以发生的步骤，一是顶点处理时的顶点着色 Gouraud 着色，一是片段（fragment）处理时的 Phong 着色。 进行着色处理的代码就是着色器（Shader）。根据着色方式的不同，也就分为顶点着色器和像素/片段着色器。可编程 Shader 即我们自己编写一段逻辑操作硬件进行着色处理，这种逻辑会对每一个顶点/片段应用一次。 Shader 逻辑决定了像素颜色应该是什么。 一个可以写和探索 Shader 的网站:shadertoy 纹理映射（Texture Mapping） 在应用同一个模型同一个着色方案的时候，这些模型有相同的高光区域和漫反射，这就是材质。但是，我们依然希望一个物体表面上不同的点有不同区别，例如颜色。换言之我们需要一种对模型表面每个点的不同属性的表达方式，这即是纹理。 以 blinn-phong 公式为例 Ld=kdIr2max(0,n⃗⋅l⃗)L_d=k_d\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{l})Ld​=kd​r2I​max(0,n⋅l)，我们可以认为纹理就是决定了每个点 kdk_dkd​ 这一部分的取值应该是多少。 如果我们将一个模型表面展开，那么所有点都可以在一个平面上表示。因此我们用一个平面图（纹理图）存储点的属性，再将纹理图的点投射对应到物体表面上的点，那么模型就有了纹理。这就是纹理映射。 纹理图上点的坐标使用（u,v）表示。因此 uv 图即纹理坐标图。我们规定 u，v 的取值范围均为 [0,1][0,1][0,1] ，但是并不要求 uv 图必须是正方形。可视化时，我们还可以将 u 方向大用偏红，v 方向大用偏绿进行表示。 注意：没有规定一个模型的表面和 uv 图的点是一一对应的，一个 uv 坐标完全可以对应多个模型点坐标 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-6(2)：深度检测与 Z-buffer 算法 Next：GAMES101-9&amp;10：纹理映射的具体内容","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"着色器","slug":"着色器","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"},{"name":"Blinn-Phong 着色模型","slug":"Blinn-Phong-着色模型","permalink":"http://example.com/tags/Blinn-Phong-%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B/"},{"name":"纹理","slug":"纹理","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"uv 图","slug":"uv-图","permalink":"http://example.com/tags/uv-%E5%9B%BE/"},{"name":"图形管线","slug":"图形管线","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/"}]},{"title":"GAMES104-1&2：课程介绍、游戏引擎的层级","slug":"GAMES104/GAMES104-1","date":"2023-07-22T12:54:09.000Z","updated":"2024-01-04T08:31:52.063Z","comments":true,"path":"post/20230722205409.html","permalink":"http://example.com/post/20230722205409.html","excerpt":"前言 GAMES104-1:介绍 GAMES104-2：游戏引擎的层级结构","text":"前言 GAMES104-1:介绍 GAMES104-2：游戏引擎的层级结构 这节课介绍了什么 游戏引擎的基础结构：有几层结构？为什么要这样做？ 渲染：我们拿模型、材质、光照、渲染管线……去干些什么？ 动画 物理 游戏逻辑（Gameplay） 其它：特效、寻路、镜头 工具集：C++ Reflection 在线游戏 前沿技术 游戏引擎的结构 由上而下，我们可以简单做如下分层： 工具层：使用引擎的时候，我们就在不断调用各种编辑器：动画编辑器、关卡编辑器、资源管理器…… 功能层：物理计算、动画计算、渲染、脚本、镜头、输入……让游戏能看得见、动起来、可以玩 资源层：数据与资源的加载处理。 不同的资源格式不同需要统一、存储方式对于游戏引擎并不一定是最高效的 核心层：内存管理、线程、进程处理 平台层：OS差异、输入设备、发行平台、图像API…… 第三方库、中间件：在每一层都有不同的专精工具，它们如何与游戏引擎配合交流？ 以制作一个动画系统为例 资源层的工作：由资源到资产 将资源（resource）转化为资产（asset），舍弃不需要的信息，转化为适合机器处理的格式。 例如，分层信息、压缩算法导致的不高效 GUID：每个资产一个有唯一的身份识别 管理资产的生命周期：不断的加载与卸载、GC 功能层的工作：Tick 让游戏活起来：每一次 tick 计算逻辑和渲染。 逻辑：A 有没有打中 B ？A 要不要向前运动 x 米？ 渲染：光照、shader…… 功能的多线程问题： 早期：固定数个线程 现代主流：Thread Fork。例如 animation、物理等比较并行的东西用不同线程。 更好：Job system。分为不同的原子任务给任何有空的核心，但是难点是同步。 核心层 数学库 引擎中相对于精度，更注重速度 数据结构与容器：默认的结构可能不适合游戏。 例如，c++ vector 容量不够是按倍数扩张 内存管理：宗旨：尽可能放在一起、尽可能顺序访问、尽可能按块读写管理 平台层 其他部分的逻辑应该平台无关 平台差异 图形API：DX11、DX12、Vulkan 硬件不同、甚至文件路径的标记格式 工具层 可用性：让创作者简单地创造 DCC（Digital content creation）：不同的内外编辑器数据导入导出 为什么要分层 封装解耦：每一层都不需要关心其他层是怎么做事的。只要负责接收处理就好了。 这种解耦的思想在开发过程中时常遇见，分层、接口、消息广播……因为我们总是倾向于各司其职，而不是为了一件小事让所有人大动干戈。","categories":[{"name":"GAMES104","slug":"GAMES104","permalink":"http://example.com/categories/GAMES104/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GMAES104","slug":"GMAES104","permalink":"http://example.com/tags/GMAES104/"},{"name":"导论","slug":"导论","permalink":"http://example.com/tags/%E5%AF%BC%E8%AE%BA/"}]},{"title":"GAMES101-6(1)：反走样","slug":"GAMES101/GAMES101-6-1","date":"2023-07-22T07:09:27.000Z","updated":"2024-01-03T16:56:26.889Z","comments":true,"path":"/GAMES1010601.html","permalink":"http://example.com/GAMES1010601.html","excerpt":"前言 GAMES101-P6：反走样","text":"前言 GAMES101-P6：反走样 走样现象 瑕疵（Artifact）：图形学中的一切错误、误差、不准确等。 经过采样以后，会看到明显的锯齿边缘，这是一种走样现象。 常见的走样现象：锯齿、摩尔纹、频闪效应 走样不仅可以发生在空间中，时间上也可以走样。例如频闪效应。 采样现象产生的原因：信号变化的频率对于采样频率而言高。（奈奎斯特定理） 采样频率高于信号频率两倍，才能完全恢复信息。 傅里叶变换 傅里叶变换：任何函数可以可以用一系列的基本三角函数的组合表示。 通过傅里叶变换我们可以将图像由时域迁移到频域。并且可以发现，对于大部分正常的图像，大部分信息集中在低频，高频信息很少。 我们应用滤波： 高通滤波：我们忽略掉低频信息，只保留高频信息，那么就能得到图像的边界（像素迅速变化的地方）。 低通滤波：我们忽略掉高频信息，只保留低频信息。那么就能得到模糊的图像。 保留区间内频率：一些不太明显的边界（太明显的当然是非常高频的信息）。 我们可以认为：滤波=卷积=平均（卷积的概念见维基） 卷积定理：时域上两个信号的卷积等价于频域上它们信号的乘积。 越大的卷积盒会保留越低的频率，带来越模糊的图像。 从频谱的角度理解采样： 采样就是在不同的频域上复制原有的频谱 采样率不够高，那么不同频域上的频谱就会混叠在一起 反走样的办法 增加采样率：简单暴力，直接提高采样率。 Pre-Filter：预先滤波。首先用滤波对原图进行模糊，这样边缘有的像素就会点上介乎于边界两边的中间色，例如更浅的颜色。 滤波必须在采样之前进行,否则得到的是模糊的锯齿(Blurred aliasing)，没有很好的反走样效果。 因为真实边界信息在采样过程中已经损失了，所以滤波只能平均/模糊错误的信息。 从频率的角度来理解，滤波的作用是削去了高频信号，这样就占用的频率带宽变小，原本会混叠的信号就不会混叠了 MSAA：对一个像素内设置更多的采样点。例如四个角各有一个像素点，如果只有 x 个点被覆盖就是 x/4 的灰度。 MSAA 并没有提高分辨率，只是提高了一个像素内的采样数量。 当然，MSAA 会显著提高计算量，不过当代工业界会通过复用像素等方法来降低消耗。4x MSAA 并不会让游戏帧率降低到 1/4。 FXAA（Fast Approxim AA）：不对图像而对图片进行处理。得到图像以后，图像匹配找到有锯齿的边界，用没有锯齿的边界进行替换。 TAA：复用上一帧的结果。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-5：(三角形的)光栅化 Next：GAMES101-6(2)：深度检测与 Z-buffer 算法","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"反走样","slug":"反走样","permalink":"http://example.com/tags/%E5%8F%8D%E8%B5%B0%E6%A0%B7/"}]},{"title":"GAMES101-6(2)：深度检测与 Z-buffer 算法","slug":"GAMES101/GAMES101-6-2","date":"2023-07-22T07:09:27.000Z","updated":"2024-01-04T08:30:34.603Z","comments":true,"path":"/GAMES1010602.html","permalink":"http://example.com/GAMES1010602.html","excerpt":"前言 GAMES101-P7：可见性问题：画家算法和 Z buffer 算法","text":"前言 GAMES101-P7：可见性问题：画家算法和 Z buffer 算法 场景中的不同远近的物体存在遮挡关系，我们需要根据深度（z 轴值）得出正确的遮挡关系。 画家算法：由油画家启发的算法 画家算法的思路：类似于油画画家的作画思路：画家先画最远的面，再画较近的面，最后画最近的面，就能得到完整的画面。 画家算法的做法：先对每个面进行深度排序，然后按远近顺序进行作画覆盖。 由于排序算法的时间复杂度最快是 O(nlog⁡n)O(n \\log n)O(nlogn), 因此画家算法至少会有这么多的时间复杂度 画家算法能得到一些正确的结果，但是不能保证一直正确，例如一个面上所有的点的深度不一致、循环遮挡等情况。下面是一个画家算法无法处理的情况 Z-Buffer 算法：深度缓冲算法 我们已经维护了一个帧缓存（frame buffer），其存储的每个单元就是屏幕显示的每个像素的颜色。我们现在再维护一个深度缓存（depth buffer/Z-buffer），存储当前像素点的深度信息。 一开始所有深度都为无穷大，每次放入一个面，就对其覆盖的像素检查深度值。深度浅于当前深度时，才会对应更新此像素点对应的深度值和颜色值。 伪代码： 1234567foreach T in triangles foreach pixel[x,y,z] in T if(z &gt; zBuffer[x,y]) frameBuffer[x,y] = pixel[x,y,z]; // update color zBuffer[x,y] = z; // update depth else do nonthing; Z buffer 的优点在于，Z buffer 不需要考虑到遍历的顺序问题，得到的结果总是正确的。而且速度优于画家算法：Z buffer 的时间复杂度可以认为是 O(n)O(n)O(n) 的，因为我们并没有进行排序，而只进行了遍历。 请注意： 我们没有考虑深度一致的问题 Z-buffer 无法处理透明效果 如果我们将 Z-buffer 与 MSAA 结合，那么对像素的处理就要对应变为对采样点的处理。 Z-buffer 是当前广泛采用的算法 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-6(1)：反走样 Next：GAMES101-7&amp;8：着色、纹理与图形管线","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"深度检测","slug":"深度检测","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"Z-Buffer 算法","slug":"Z-Buffer-算法","permalink":"http://example.com/tags/Z-Buffer-%E7%AE%97%E6%B3%95/"},{"name":"画家算法","slug":"画家算法","permalink":"http://example.com/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"}]},{"title":"GAMES101-5：(三角形的)光栅化","slug":"GAMES101/GAMES101-5","date":"2023-07-20T14:58:17.000Z","updated":"2024-01-03T16:56:05.164Z","comments":true,"path":"/GAMES10105.html","permalink":"http://example.com/GAMES10105.html","excerpt":"前言 GAMES101-P5：光栅化","text":"前言 GAMES101-P5：光栅化 本节介绍 MVP 变换之后的操作：光栅化 Rasterize 屏幕与光栅化 定义屏幕： 单元为像素的一个二维数组 分辨率：长宽像素 是一种光栅成像设备 光栅化：“画”到屏幕上 像素：显示由 RGB 混合的单一色彩。 pixel 是 picture element 的缩写 raster 其实是德语中的 screen 的意思 屏幕空间：定义方式不一，可以以左下角为（0，0）点第一象限定义空间。 XY方向的投影 将经历投影变换得到 [±1,±1][\\pm 1,\\pm 1][±1,±1] 宽高的面拉成屏幕的宽高[0,w]×[0,h][0,w]\\times[0,h][0,w]×[0,h]。变换矩阵： [w200w20w20h2001−n+f20001]\\begin{bmatrix} \\frac{w}{2} &amp; 0 &amp; 0 &amp; \\frac{w}{2} \\\\ 0 &amp; \\frac{w}{2} &amp; 0 &amp; \\frac{h}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} ⎣⎢⎢⎢⎡​2w​000​02w​00​0010​2w​2h​−2n+f​1​⎦⎥⎥⎥⎤​ 三角形的光栅化 光栅化即将多边形劈成数个像素的过程，这个过程中最基础的是三角形。 三角形的良好性质： 最基础的多边形，而且其他多边形都可以拆分为三角形 三角形定义的一定是平面（反例：沿对角线折了的四边形） 清楚的内外定义：没有凹凸之分，通过叉积可以简单判断在里还是外 三角形内点的属性可以由根据离三角形顶点的距离关系进行插值得到 如何判断一个像素该不该被点亮？ 采样 抽象地说，采样就是将一个函数离散化。 对像素中心进行采样： 如果像素中心在三角形内，则点亮，否则不点亮。 边界问题：如果落在边上，采取统一的处理方式即可。如①不认为在多边形内左下、②左下认右上不认； 判断点在三角形内：用三条边与点 q 连线进行叉乘。 如 P0P1P_0P_1P0​P1​、P1P2P_1P_2P1​P2​、P2P0P_2P_0P2​P0​ 分别对 P0QP_0QP0​Q、P1QP_1QP1​Q、P2QP_2QP2​Q 叉乘，得到的结果都在同一侧则说明在三角形内 对判断过程进行加速 包围盒方法：左于最左顶点高于最高顶点的肯定不用考虑。最上下左右的点围成的四边形就是三角形的包围盒。 记录边界的所有点。 Extend：关于显示设备 隔行扫描：造成画面撕裂 帧缓存（frame buffer）：将内存（显存）中的一块区域存储图像，并映射到屏幕。 LCD：液晶显示。通过液晶过滤指定的波改变光的颜色。 LED：发光二极管。小灯管组合发光。 墨水屏：控制黑色墨水面显示在上还是白色墨水面显示在上，刷新极慢。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-4：视图和投影变换 Next：GAMES101-6(1)：反走样","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"}]},{"title":"Unity的新按键输入系统","slug":"Unity/Unity的新按键输入系统","date":"2023-07-17T15:39:53.000Z","updated":"2023-07-18T12:29:22.852Z","comments":true,"path":"post/20230717233953.html","permalink":"http://example.com/post/20230717233953.html","excerpt":"前言 这是 Unity 新输入系统（input system）的简要笔记。","text":"前言 这是 Unity 新输入系统（input system）的简要笔记。 官方文档地址：Input System | Input System | 1.5.1 Actions Action Type Value 类型：每次值改变的时候触发OnAction报告值；适用于追踪持续改变状态的输入。 Button 类型：每次按下的时候触发； Passthrough 类型：看文档意思是一种冲突解决方案：对所有的控制类型都会响应。 因此，一次按下松开会使 Value 类型调用两次 OnAction，但是只会调用一次 Button 或 Passthrough。 检查 Action 的状态(委托与轮循) 可以使用下列三个 Action————此处 Action 是指一参无返的委托，不是 InputAction： action.started action.performed action.canceled 也可以使用下列函数进行轮循： 对于 value 类型： action.ReadValue&lt;T&gt;() action.PerformedThisFrame() 对于 Button 类型： action.IsPressed() action.WasPressedThisFrame() action.WasReleasedThisFrame","categories":[{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"}]},{"title":"Beautiful Times个人翻译","slug":"歌词翻译/Beautiful Times翻译","date":"2023-07-11T00:37:12.000Z","updated":"2023-07-11T01:09:19.470Z","comments":true,"path":"post/20230711083712.html","permalink":"http://example.com/post/20230711083712.html","excerpt":"前言 Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。","text":"前言 Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。 除了旋律的优美与积极，另外一个另我印象深刻的点是排比和押韵的使用。大部分我都使用加粗、斜体、加粗斜体进行标识。这种韵律也是促使我翻译这个歌词的重要原因，尽管不太翻译出了其这一特点，但是这种用心琢磨一下文字的感觉实在让人心情很好。 翻译 A spark soaring down through the pouring rain 耀眼的电光穿过瓢泼大雨 And restoring life to the lighthouse 废弃的灯塔被它再次点燃 A slow motion wave on the ocean stirs 激荡的海面逐渐涌起巨浪 My emotion up like a raincloud 我的心绪如雨云一样高飞 When did the sky turn black? 天空什么时候没了光彩？ And when will the light come back? 阳光什么时候才会回来？ A cab driver turned to skydiver 的士司机当了跳伞者 Then to survivor, dying to break down 在幸存之后濒临崩溃 A blood brother,surrogate mother 代孕母亲和她的哥哥 Hugging each other,crying their eyes out 互相拥抱着泣不成声 When did the sky turn black? 世界什么时候没了光彩？ And when will the light come back? 光明什么时候才会回来？ I'm ecstatic like a drug addict 我喜悦的心情好似嗑药 locked in the attic. Strung out and spellbound 困在阁楼，疲惫又热情 I fought all through the night 我整晚都在顽强对抗它 Oh oh, but I made it alive 最后终于让我走了出来 The sun's starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 这场生的搏斗太难、太难、太难了 But I'm gonna survive 但我会把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 A bad feeling burned through the ceiling 就把消沉的心绪付之一炬 Leaving my healing heart with a new scar 只给我痊愈的心添道新疤 A dead fire rose and rose higher 死亡之火升腾得愈高愈旺 Like a vampire up from the graveyard 如飞起的吸血鬼凌于群鸦 When did the sky turn black? 世界什么时候失去光华？ And when will the light come back? 希望什么时候能够回家？ We all suffer but we recover 我们都饱经磨难但是挺了过来 Just to discover life where we all are 最后明白我们生命的意义在哪 I fought all through the night 我搏斗了整整一夜 Oh oh, but I made it alive 但最后我还是活了下来 The sun's starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I'm gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I'm gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 My heart's burning bad and it's turning black 灼烧的心已焦黑几近焚毁 But I'm learning how to be stronger 但我已学着变得更加强大 And sincerely I love you dearly 亲爱的我真切地爱着你 Oh but I'm clearly destined to wander 但明显地我注定着要流浪","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"}]},{"title":"C# 中的委托机制(delegate、action、func)","slug":"Cs中的委托机制","date":"2023-07-06T13:40:05.000Z","updated":"2023-07-20T18:03:20.212Z","comments":true,"path":"post/20230706214005.html","permalink":"http://example.com/post/20230706214005.html","excerpt":"前言 简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是?","text":"前言 简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是? 主要参考了C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili，一个很好的视频。 委托 Delegate 委托的底层是一种函数指针。顾名思义委托的作用就是，当一个函数“不方便做某事”的时候，“拜托”另一个函数去做。可以用于实现事件与回调。 所有的委托都派生自 System.Delegate 类。 声明一个委托 委托的声明 1delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt; 委托经过声明以后决定其可以引用的方法。方法与声明有相同的参数、返回类型、标签（关于标签参考此 CSDN 博客）。换句话说，委托的声明决定了它能调用什么样的方法，委托是被调用方法的模板。 实例化委托 声明完成后，可以用 new 实例化一个委托实例，并且在参数中指定实例调用的方法。如下 1234public delegate void printString(string s);...printString ps1 = new printString(WriteToScreen);printString ps2 = new printString(WriteToFile); 最后向委托中传递参数即可。如下是一个完整的例子（From：runnoob） 1234567891011121314151617181920212223242526272829303132333435363738using System;delegate int NumberChanger(int n);namespace DelegateAppl&#123; class TestDelegate &#123; static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125; public static int MultNum(int q) &#123; num *= q; return num; &#125; public static int getNum() &#123; return num; &#125; static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法 nc1(25); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); nc2(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; &#125;&#125; 委托的多播 如果委托对象（即实例）的类型相同，则可以合并、分离委托（使用 + 和 - 运算符），这被称之为委托的多播或组播。如下是一个例子（From：runnoob） 1234567891011121314...static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc; NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); nc = nc1; nc += nc2; // 调用多播 nc(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; Func Func 是委托的一种，它固定具有一个参数和一个返回值。 格式如下： 1Func &lt;parameter_type,return_type&gt; expression; expression 可以是一个 lambda 表达式，也可以是一个方法。是方法的时候，这个方法和 Func 一样必须有一个传入值和一个返回值。这样，就可以把方法作为参数进行传递，同时不必像委托一样显式的进行定义声明。 lambda 表达式的举例： 1234Func&lt;string, string&gt; convert = s =&gt; s.ToUpper();string name = &quot;Dakota&quot;;Console.WriteLine(convert(name)); 实例化委托方法的举例： 123456789Func&lt;string, string&gt; convertMethod = UppercaseString;string name = &quot;Dakota&quot;;Console.WriteLine(convertMethod(name));string UppercaseString(string inputString)&#123; return inputString.ToUpper();&#125; Action Action 也是委托的一种，它一定具有一个参数，并且没有返回值。 即： Action &lt;T&gt; name 总的来说，和 Func 差别不大。同样可以给它赋值为 lambda 表达式或方法。只要这个方法有一个参数并且没有返回值。 Event Event 是一种特殊的委托，但是其复制的权限为delegate。使用 Delegate 的时候，我们不一定想立刻为其赋值。这种情况下，我们可以考虑使用 Event。 事件的声明： 12345 delegate void MyDelegate(); event MyDelegate myEvent;// orevent Action myEvent //Action 的本质是 Delegate 事件声明完成后就是一个实例了（类似变量）。 当作为类成员的时候， event 只能在类中被调用。 Event 的一种用处：让类外成员可以观测到类的私有成员发生了变化。 在类中定义私有成员的 public {get;set;} 变量，set 时，invoke 类中的event； 类外事物需要观测时，在 event 中注册函数就会收到通知。 参考 C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili C# 委托（Delegate） | 菜鸟教程 Func&lt;T,TResult&gt; 委托 (System) | Microsoft Learn 三分钟彻底搞懂委托，事件，Action，Func的作用和区别_哔哩哔哩_bilibili 延申 逆变与协变类型请参考：Covariance and Contravariance in Generics | Microsoft Learn lambda 表达式部分参考： Lambda表达式_百度百科 C++ 中的 Lambda 表达式 | Microsoft Learn","categories":[{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"}],"tags":[{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"}]},{"title":"向量数据库技术鉴赏观看记录","slug":"向量数据库技术鉴赏观看笔记","date":"2023-07-01T14:49:55.000Z","updated":"2024-01-03T17:15:05.291Z","comments":true,"path":"post/20230701224955.html","permalink":"http://example.com/post/20230701224955.html","excerpt":"前言 配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。","text":"前言 配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。 笔记 为什么要有向量数据库？ 我们可以将几乎所有的事物转化为数个值的组合来进行区别和描述。例如，一个狗={毛发长短，毛发颜色，体格大小，温顺程度……}，于是就可以用向量来表述一个东西。 向量一定程度的推理关系：如果“关系”作为向量的一环，那么我们会发现“警察与小偷”和“猫和老鼠”之间关系的相似性。 向量的应用： 图片领域：描述特征。实现“以图搜图”功能，参考计算机视觉实验和多媒体数据处理实验3（多媒体实验3：基于 BOF 进行相似图片搜索） 文本向量化：描述一个句子中有多少个x关键词，见上述多媒体数据处理实验3。相似文本内容查找。利于理解文本的实际内容，AI相关。 将相似对话输入给 chatGPT，极大提高输出效果。 问题：传统数据库不适合存储处理向量（在一些云计算的例子中，甚至只提供存储字符串类型）。 传统数据库：通过查询语句进行精准搜索 向量数据库：查询库中与查询向量最相似的向量转化为 KNN 问题，具有一定的模糊性。 向量数据库的核心：KNN（K最近邻算法） 距离的定义：欧几里得距离、余弦相似度、海明距离等…… 暴力搜索算法 聚类思想：如果我们先将数据进行分类，那么只在查询点所在类进行搜索，搜索的范围就小多了。 Kmeans 算法 指定聚 n 类，迭代 k 次。 随机生成 n 个代表点，按距离进行分类。 训练：将分类结果的平均点视为新代表点，重复此过程 k 次。 收敛：代表点数值趋于稳定 不能保证聚类不遗漏 近似最近邻 ANN：通常来说，试图提高速度的行为基本上都会带来准确率的下降。例如 Kmeans 中将一个点放入了错误的类中，算法得到的往往是近似的 KNN（参考 LSH 中的结果部分）。 局部敏感哈希算法 LSH：关于欧几里得距离的 LSH，见多媒体实验4：LSH局部敏感哈希 采用海明距离的LSH 哈希函数：随机一个有正反的超平面。判断点是在正面还是反面，记为0/1。 对两个点点被哈希得到的 01 串计算海明距离 把 01 串进行分段，只要有一个段一致就候选的策略，提高分到同一个桶的概率。 ANN 问题中的内存开销问题：量化与乘积量化（PQ） 内存开销问题：一个 128 维，每维一个浮点数（32 bit，4 byte）的向量需要占用 512 字节空间 B 树类数据结构可以为读写庞大数据库减少内存损耗。数据库存储在磁盘中，每次只读取其中的一个结点。见B 树、B+树、二叉搜索树与红黑树； 乘积量化可以减少一个向量本身占有的空间 用代表点代表类中的所有向量：有损压缩 量化：向量根据码本转化为代表点 使用码本记录代表点，记录码本索引值代替记录向量真实值 如果我们使用一个字节存储码本索引，最多可以记录 256 个代表点，此后的每个向量只需要一个字节即可表示。 维度灾难问题：每一个维度都会拉远点与代表点的距离，高维非常分散。要保证好的效果，就需要大量聚类，码本开销就十分巨大。 乘积量化PQ：用低维子向量拼接代替高维直接量化，缓解维度灾难问题 例如 128 维向量被分割为8 个 16 维向量分别量化，得到结果再拼接。每个子向量有自己的码本。 高维结果实际上是低维量化结果的笛卡尔积，所以叫 PQ。 从指数增长变成了加法增长。 主要减少了内存开销，但是一定程度地提高了速度（O(n+klog⁡klog⁡log⁡n)O(n+k\\log k \\log\\log n)O(n+klogkloglogn)）,与之相比，暴力搜索的时间复杂度是 O(kn)O(kn)O(kn)。 其他降维方法：主成分分析PCA，见多媒体实验2：PCA主成分分析 基于图结构的高效 KNN：导航小世界NSW 与 HNSW 内存相比于速度和准确度，只能被开发者感知，因此有的时候我们愿意牺牲内存提高ANN的准确性与速度 导航小世界NSW 基于图结构：向量与向量之间的六人理论 图的构建方法： 没有孤立点 如果两个点够近就一定有边相连 边尽可能少 德劳内三角：一种满足 NSW 需要的构建方法 构建方法 将点随机放回空间 每次放回，就将其与最近点相连 最终图中既有一开始生成的较长的边，也有后续生成的较短的边 通过长边，我们可以从随机的查询点快速移动到与待查询点较近的点（直接在点空间构建不具备这种性质） 通过短边，满足德劳内三角的图结构，准确找到待查询点 分层小世界HNSW： 越上层越粗略，快速导航 越下层越仔细，准确查找 算法层面保证了先粗后快的查找过程，数据量扩大时表现更优良，稳定且快速。 本质是对查询的一种跳表化。 小世界算法：没有压缩 + 维护复杂的图结构 = 内存爆炸 其他向量数据库问题 向量数据库依然是数据库，和传统数据库产品一样有许多方面需要考虑：访问接口、访问控制、备份、多节点、容错、机器的监控与追踪……","categories":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}]},{"title":"B 树、B+树、二叉搜索树与红黑树","slug":"B树与红黑树","date":"2023-06-25T14:47:14.000Z","updated":"2024-01-04T08:29:31.308Z","comments":true,"path":"post/20230625224714.html","permalink":"http://example.com/post/20230625224714.html","excerpt":"前言 B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。","text":"前言 B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。 为什么需要 B 树（和其他平衡树） 我们早就知道可以构造这样的树：比根小的扔左边，比根大的扔右边，这样就可以轻松构建一个有序的结构了。但是如果根的左右两边不平衡，显然就会导致找其中一边化的时间比较变长。因此我们就需要一些把树变平衡的方法。由是得到平衡查找树。 平衡的方法各有不同，对于本文介绍的树们，它们的逻辑关系是这样的： 由于二叉查找树的不平衡性，人们设计 AVL 树。它通过左右旋保证左右子树高度差不超过 1； AVL 树严格的平衡反而导致开销过大，于是设计了不那么严格的红黑树。红黑树通过两种颜色的区别，保证左右高度差不超过一倍； B 树从另一个角度入手，一个结点上存多个值叉分出多个子树，通过“限定结点上值的数量”和“叶子结点都在同一层”，保证平衡。由于一个结点上有多个值，树比二叉树浅，适合磁盘上存储大量数据的数据库采用。 B+ 树把值全存在叶子结点上，相比 B 树检索速度更稳定。此外遍历和排序也都更方便了。 B* 树在 B+ 树的基础上提高了结点拆分合并的时间，因为一个结点被从兄弟中创建出来的时候拥有了上限的 2/3 而不是 1/2 的结点，需要拆分的次数降低了。 AVL 树 AVL 树是最先发明的自平衡二叉查找树。 在AVL树中任何节点的两个子树的高度最大差别为 1 。 AVL树增删操作后需要把失去平衡的结点重新变平衡。为此，引入左旋和右旋操作： 上图将 A 为根结点在树进行左旋，得到 B （原右孩子）为根结点的树。这个过程可以如下描述： B 的左子树成为 A 的右子树； A 成为 B 的新左子树； B 成为新的根结点； 类似地，右旋就有：（假设 A 是根结点，C 是 A 左结点） C 的右子树成为 A 的左子树； A 成为 C 的新左子树； C 成为新的根结点； 我们现在可以讨论 AVL 树的再平衡了。 我们规定一个结点左右子树高度差绝对值是平衡因子，那么 AVL 数平衡因子只能是 0 或 1。 显然一个结点（下的子树）失衡，说明之前其平衡因子是 1，现在变成了 2。这也说明，新结点插入的那个子树原先较长而且插入一个结点使其变得更长了。于是最靠近插入结点的失衡结点的一个子树现在的平衡因子必然为 1。 假设是插入在左子树。对于结点插入在左子树的左边的情况（左），我们可以把不平衡节点的子树右旋，使得插入了结点的左子树成为新根结点，则树恢复平衡。插入右边的情况，则先对左子树进行左旋，再对根结点右旋。插入在右子树的情况是类似的。总结如下： 对于最靠近插入结点的失衡结点 A： 插入结点在 A 的左结点 B 的左子树上：A 右旋 插入结点在 A 的左结点 B 的右子树上：B 左旋，再 A 右旋 插入结点在 A 的右结点 C 的右子树上：A 左旋 插入结点在 A 的右结点 C 的左子树上：C 右旋，再 A 左旋 红黑树 AVL 树对平衡要求很高，左右旋又是较为耗时的操作，增删比较频繁时，付出的代价甚至可能比获得的效率收益还多，故而它只适合用于插入删除次数比较少的情况，实际应用不多。 红黑树是对 AVL 树的一种改进，它只保证最长路径不超过最短路径的两倍，是一种弱平衡二叉树。因为平衡要求没那么严格，所以增删花费时间少，查询时间则有所增多。 红黑树每个结点非红即黑，而且有： 根节点、叶节点（请注意，叶子结点是 NULL 结点）都是黑的； 红结点的两儿子都是黑的； 对于任意节点而言，到其下叶子结点路径都包含相同数目的黑结点； 高度始终保持在h = logn 红黑树的插入 记新结点为 N，其父结点为 P，父结点的兄弟结点（叔父结点）为 U，父结点的父结点为祖父结点 G。首先，我们将结点 N 插入到树中，并标记它的颜色为红色。检查此时的情况： P 不存在，N 是根结点：把 N 染黑。 P 是黑结点：什么都不用干。因为 N 取代了一个黑空节点，到达 N 下空结点经过的黑色结点数没有变。 P 是红结点，此时 G 结点必存在为黑节点。 P、U 都是红结点：P、U 染黑。 G 是根结点：不动。 G 不是根结点：染红。 如果不动 PU，把 N 染黑，那么 G 到达 N 下结点经过的黑结点数就会比去 N 兄弟的路径多一个。 如果不染 G，那么 G 的父亲到达 G 下结点经过的黑结点数就会比去 G 兄弟经过的多一个。 P 左红 U 右黑，N 是右节点(记为 LR )：对 P 左旋，然后对 G 右旋，P 染黑，G 染红。 左旋一次以后，变为下面的 LL 情况。 P 左红 U 右黑，N 是左节点：对 G 右旋，P 染黑，G 染红。 N 的插入不会导致经过的黑色结点数发生改变，但是 P 子树深了一层，所以不管改 P 还是 N 都会导致经过黑点增加，除非同时通过 G 把增加黑点数减掉，但是这同时会导致 U 子树方向少掉一个黑点， P 子树还是多一个，因此通过单纯的染色是无法解决问题的。 通过旋转操作，相当于把 P、N 两个都在 P 子树的红点移了一个到 U 子树。由于 G、U 都是黑结点，因此在里面插一个红点不会有影响。这样就两边都没有红点相连的情况了。 P 右红 U 左黑：对照上面对称处理。 注意这些情况和 AVL 树的再平衡的相似。 红黑树的删除 假设删除的结点是 D 如果左右子树均不为空：将左子树中的最大值或右子树中的最小值挪过来覆盖，然后删除原来其在的结点。这个结点是最值，那么显然不可能有两个有值的孩子，于是转化为下面的情况。 左右子树至少有一个为空： D 是红结点：那么父结点和子结点都是黑色结点，直接接一起就完了。（当然优先的不空的子树） D 是黑结点，且非空孩子是红结点：删除 D，把非空孩子移上来并染黑。 D 是黑结点：可知两个孩子都为黑空，将 D 变成黑空，可知此时 D 子树少了一个黑色结点，然后有下面若干种情况。 假设删除的结点是 D，D 的父亲 P，兄弟 U，U 的左右孩子 NL，NR： 情况1：P 为空， D 是根结点：什么都不用干； P 为黑 情况2： U 为黑，NL，NR也为黑：U 变红，U 子树减一个黑色接结点；然后 P 子树减少了一个黑结点，对 P 思考该问题； 情况3： U 为红：对 P 左旋；然后 P 变红， U 变黑。然后情况 4, 5, 6： 相当于将兄弟子树的一个红节点拿了过来。 情况5： NL 为红，NR 为黑：U 右旋，NL 变红 ，U 变黑，变成情况 6； 情况6： NL 为黑，NR 为红：P 左旋，U 变 P 的颜色(黑)，P 变黑，U 的颜色，NR 变黑。 根结点的颜色不变，根的左子树补了一个黑结点（U）。 P 为红，U 为黑： 情况4： U 的孩子都为黑：对换 P、U 的颜色； 情况5： NL 为红，NR 为黑：U 右旋，NL 变红 ，U 变黑，变成情况 6； 情况6： NL 为黑，NR 为红：P 左旋，U 变 P 的颜色(红)，P 变黑，U 的颜色，NR 变黑。 根结点的颜色不变，根的左子树补了一个黑结点（P）。 B树 B 树（B-Tree）， B 普遍来说被认为是 Balanced 的意思，因为这是一种自平衡树。 有的地方翻译为 B-树，容易给人一种是 B “减”树的错觉，事实上 B-Tree 就是 B 树。 如果数据太大，我们就无法在内存中放下整个树，同时我们知道磁盘读取速度远慢于内存。因此这种情况下我们对“读取”操作非常敏感。如果是不够平衡的树，或者深度太深，检索速度就会很慢。在数据库应用中，B树的每个节点存储的数据量大约为4K, 这是因为磁盘数据存储每个块的大小为通常为 4K，这样每次磁盘 IO 可以读写刚好一个数据库结点。 B 树是多叉树，而且每个结点能存储多个值。它定义如下： 一个结点能存储多个值，这些值称之为键。 度：定义一颗树的度为 t(t≥2t\\geq 2t≥2)。度能决定树内的结点有多少键： 空树：0个； 根结点:[1,2t−1][1,2t-1][1,2t−1] 个； 普通结点：[t−1,2t−1][t-1,2t-1][t−1,2t−1]个。 子结点数：自己的键数 +1 个。一个键把数轴划为两个区间， n 个键自然就是 n+1 个区间。 叶子结点都在同一层。 例如：t = 2。此时的 B 树内部节点可以有 2、3 或 4 个孩子，称之为 2-3-4 树。 B 树的检索 在树 T 中检索关键字 k 的逻辑如下： 首先，查找 k 和 T 根结点的区间关系。 如果落在一个键上，那么就搜索到了 k 是 T.root 的第 i 关键字。 否则，继续第二步 在 k 落在区间的对应孩子上继续搜索。 当前结点没有孩子，说明没找到。 B 树的插入 逻辑： 如果结点的键槽没有满：结点添加一个新键。 如果结点满了（2t-1个键）：那把此结点的键分为三份，最中间的键插入到父结点，左右分裂为两个有 t-1 个键的结点。其孩子也对应分配给新分裂出来的结点。 如果父节点也满了：递归重复上面过程。 如果根结点都满了：创建一个空结点为新的根结点，然后分裂根结点 实际我们在确定新键位置的过程中，就沿途分裂了所有遇到的满结点。因此实际上这不是一个递归过程。 B 树的删除 假设问题是删除结点 x 中的键 k： 不少于 t-1 个键的叶子结点删除：直接删除； 内部结点： 找到 k 前面的区间对应的子结点 y，看是否有至少 t 个键： 如果 y 至少有 t 个键：找到结点 y 中最后一个键 k'（即 k 的前驱）。执行“删除结点 y 中 k' 键”的操作。x 中用 k' 替换 k。 否则：找到 k 后面的区间对应的子结点 z，看是否有至少 t 个键： 如果有：找到结点 z 中最后一个键 k'（即 k 的后继）。执行“删除结点 z 中 k' 键”的操作。x 中用 k' 替换 k。 否则：此时 y 和 z 加起来就只有 2t-2 个键。把键 k 和结点 z 都合并进 y。然后再在 y 中删除 k； 由上向下找 k 时如果确定 k 在一颗以 x 为根的子树中，并且 x 只有 t-1 个键，设 x 的父结点为 p： x 的一个相邻兄弟（y/z）结点有至少 t 个键：删除此键。根据是 y 或者 z，从 p 中对应给一个键给 x。从 y/z 中对应给一个键给 p； 相邻兄弟也只有 t-1 个键：合并 x 和 y/z、p 中由两个子结点夹着的键。如果p 是根结点而且本来就只有一个键，那么树的高度就缩减了。 B+ 树 B+ 树的特点是在 B 树上做了如下改动： 非叶子结点不存值，只有子结点的头元素的索引。即一个键（子结点头元素值）对应一个指向子结点的指针。 相邻叶子结点之间用指针直接串连。 根结点至少一个元素，非根结点有 [m/2, m-1] 个元素。其中 m 是 B+ 树的阶。 这样一来 B+ 树的查询速度基本恒定。 此外 B+ 树还有以下好处 遍历快：因为块与块之间有指针 天然排序：例如我我们想取一个区间内的数据，取出来就是有序的。 B+ 树的插入 当节点元素数量大于 m-1 ：按中间元素分裂成左右两部分，中间元素是右半部分的头结点。同时父节点添加中间元素当做索引。 B+ 树的删除 因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可。 删除元素后依然满足要求：直接删除 删除后元素个数不够 兄弟结点有多余元素：向兄弟要一个元素，修改父结点的索引值； 兄弟结点无多余元素：和兄弟合并。递归删除父结点的索引。 删除元素后 B* 树 很显然，B* 树又是对B+数的再一次改进，在 B+ 树的构建过程中，为了保持树的平衡，节点的合并拆分是比较耗费时间的，所以 B* 树就是在如何减少构建中节点合并和拆分的次数，从而提升树的数据插入、删除性能。 一个结点创建的时候有 upper(2/3)mupper(2/3)mupper(2/3)m 的键，而不是 upper(m/2)upper(m/2)upper(m/2)； 如果结点存满了，检查兄弟结点是否是满的： 不是满的：向兄弟节点转移关键字； 也是满的：和兄弟结点各拿 1/3 创建一个新结点； 参考 面试官问你B树和B+树，就把这篇文章丢给他 - 好好学java - SegmentFault 思否 二叉搜索树(BST)与平衡二叉树(AVL) - 知乎 万字大总结，一文搞懂二叉搜索树、B树、B+树、AVL树、红黑树 - 知乎 红黑树 - 维基百科，自由的百科全书 《算法导论》","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"多媒体实验4：LSH局部敏感哈希","slug":"课程报告/多媒体实验4LSH","date":"2023-06-14T03:47:13.000Z","updated":"2023-06-30T15:12:31.512Z","comments":true,"path":"post/20230614114713.html","permalink":"http://example.com/post/20230614114713.html","excerpt":"前言 KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。","text":"前言 KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。 目的 在corel数据集上实现LSH索引并分别进行近邻搜索，查询数据集前1000点的前10个最近邻，并统计搜索算法的性能(召回率，准确率，时间)。 局部敏感哈希的思想 常规的哈希思想是通过算法将被哈希后的值作为键去索引原来的值，由于根据值是可以算出键的，所以这就给我们的查找带来了方便。通过哈希，我们可以把一个稀疏矩阵紧密存放，但是又不损失索引的速度。 不过哈希函数也有别的用法，例如密码学哈希函数。这类特别的哈希算法旨在用哈希函数实现加密，因此其哈希值难以推出原值，而且对输入敏感，稍加变动就会彻底改变哈希值。此外，其对抗碰撞的要求也很高，因为碰撞意味着加密的不安全。 而局部敏感哈希则反其道而行之，其非常容易发生碰撞。实际上，这种哈希函数的目的是使邻近的值在经过哈希以后依然邻近，或者说干脆就相等了（这一步可以通过把处理后的值取整实现）。因此，通过局部敏感哈希，我们就相当于对数据集中的数进行了一次分类，这样以后需要搜索 KNN 时，我们就不需要搜索整个数据空间而只对与查询值具有相同哈希值的那些点进行计算即可。 当然，哈希函数不能保证所有被映射到一起的值均是邻近的值，因此 LSH 只能是 KNN 的近似算法，不能保证准确。 一个简单的例子是： 令哈希函数为 h((x，y))=xh((x，y))= xh((x，y))=x ，即 x 轴值。那么 y 轴方向上距离很大的点依然会被错误的认为是邻近点 为了提高准确性，我们可以试着改变哈希算法的一些参数，使得更多的点映射在一起，相当于扩大了“邻近”的范围从而匹配到更多的点。另一方面，我们也可以采用另外一个不同的哈希函数进行运算，看看结果是否会不同。对于多次哈希的结果，我们可以取邻近点的交集，也可以取邻近点的并集，只要参数适当，都可以取得还不错的结果。事实上，由于处理的数据往往维数很大，所以我们都需要采取多个哈希函数。 例如对于上面的例子，我们采用h((x，y))=yh((x，y))= yh((x，y))=y 作为第二个哈希函数算法，并且认为只有两次哈希结果均邻近才能算邻近值（取交集），那么 y 轴方向上距离很大的点就不会被认为是邻近点。 前人们已经总结出了许多的哈希函数，针对不同的要求，例如求的是点的什么距离，我们可以采取不同的哈希方法。因此我们可以不自己构造哈希函数。 总结一下，LSH 思想就是：通过构造哈希函数将相邻近的点映射到一起，用多次哈希提高精确度，用查找哈希值索引到可能的最邻近点并计算距离得出近似最邻近点。当参数取得合适，我们就可以保证 LSH 找到 KNN 的准确性可以接受。 性能评估：准确率、精确率、召回率 准确率、精确率、召回率是三个容易混淆的概念。 假设我们的问题是在所有样本中找出所有为真的样本。那么对于机器给出的结果，就有“机器判断正确/错误”和“机器判断是真/假”的组合共计四种情况，记前者为 True/False，后者为 Positive/Negative，并简记为TFPN。那么机器就将样本分为了 TN、TP、FN、FP 四种类别。于是： 准确率（accuracy）指机器对多少样本的判断是正确的，即 TP+TNTP+TN+FP+FN\\frac{TP+TN}{TP+TN+FP+FN}TP+TN+FP+FNTP+TN​。准确率只在乎判断得对不对; 精确率/查准率（precision）指预测为真的样本中有多少判断是正确的，也就是 TPTP+FP\\frac{TP}{TP+FP}TP+FPTP​，精确率要求没有找到错误的真点，不关心有没有漏找; 召回率/查全率（recall）指实际为真的样本中有多少判断是正确的，也就是究竟找（召）回了多少为真的样本，即TPTP+FN\\frac{TP}{TP+FN}TP+FNTP​，召回率只关心有没有找全真点，不关心有没有错误的点。 在灾害预报中，我们应该关心召回率，因为每一次没有预测到灾害都会给社会带来巨大损失；但是如果是人脸识别，那么就应该关心精确率，因为无法识别人脸用户可以使用其他方式继续，但是如果错误识别则可能给用户带来损失。 也可以用语言的角度进行理解，准确无疑是指我们判断对了没有，精确则是判读对了多少。因此前者关心整体的判断，而后者只关心预测为真的样本中的判断。 程序的基本结构 在这里，我采取的是计算欧几里得距离，这样，我们的哈希函数就可以形如 H(x)=floor((r⃗⋅p⃗)+bHsize)H(x) = floor(\\frac{(\\vec{r}\\cdot\\vec{p})+b}{H_{size}}) H(x)=floor(Hsize​(r⋅p​)+b​) 其中 HsizeH_{size}Hsize​ 是提前指定的值，p⃗\\vec{p}p​ 是输入点的向量形式，bbb 和 r⃗\\vec{r}r 是哈希函数中的随机偏移量和随机向量，bbb 的取值范围在 (0,Hsize)(0,H_{size})(0,Hsize​) 间。向下取整的 floor 函数负责将邻近的值舍入到一起。 在程序的一开始，我们根据需要的哈希数量和 HsizeH_{size}Hsize​ 的值随机生成 bbb 和 r⃗\\vec{r}r。由于矩阵的性质，我们可以直接将前者生成为一维数组，后者为每列一个 r⃗\\vec{r}r 的矩阵。然后对点进行计算。 得出计算结果后，我们使用字典列表按哈希值进行分类保存。这样索引就算建立完毕了。 搜索时，首先计算待查询值的哈希值，然后查询索引获得候选最邻近点。对不同哈希给出的候选集可以使用并集的方法，也可以采取交集的方法。最后对给出的所有候选点计算欧几里得距离，排序后选出最近的前 K 个点即可。选择并集或者交集需要适当的修改参数，不过总的来说，并集的效果好一些（见后面结果）。 在本例中，主要可以修改的参数是 HsizeH_{size}Hsize​ 是哈希函数的数量。前者决定了对计算结果的区分度， HsizeH_{size}Hsize​ 越大，被哈希到一起的邻近点就越多,速度就越慢，但是精确度相应提升。后者则可以从不同方向来判断邻近点，哈希函数越多，邻近点就越多，但是速度也同样会变慢。 为了判断精确度和用时，我们还需要构造一份正确答案。可以采取暴力计算的方式进行。将结果作为 JSON 文件存储于磁盘内，就可以加速在判断 LSH 准确性时的速度。 源代码 LSH: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import numpy as npimport jsonimport time# region functionsdef get_hash_para(BUKET_SIZE): offsets = np.random.uniform(0, BUKET_SIZE, [1, BUCKET_NUM]) vectors = np.random.random([32, BUCKET_NUM]) return offsets, vectorsdef calc_LSH_indexes(data, bucket_num): &quot;&quot;&quot;&quot; 进行哈希计算并分配到哈希“桶”中\\\\ 哈希公式 H = （（dot（v·r）+b)）/BUCKET_SIZE）\\\\ 其中r是向量，b是一个数 &quot;&quot;&quot; buckets = [&#123;&#125;for _ in range(bucket_num)] # 结果是68040*15，每个向量在每个桶内映射为一个哈希值 mapped_indexes = np.floor( (np.dot(data, hash_vectors)+hash_offsets)/BUCKET_SIZE) # 由（数据向量值的）索引对应的一串桶中的哈希值，转变为桶中的哈希值对应的索引 # 方便由哈希值找索引 for index, hash_keys in enumerate(mapped_indexes): for j, hash_key in enumerate(hash_keys): buckets[j].setdefault(hash_key, []).append(index) return bucketsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def search(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.union( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef search_with_intersection(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近,交集&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.intersection( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef check_accuracy(chk_res, crrt_res): # 如果check-res中的元素在correct-res则append一个ture correct_num = sum([i in crrt_res for i in chk_res]) TP = correct_num FP = K - correct_num FN = K - correct_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # 变量 COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_RES_PATH = &#x27;./multi/4.10NN.json&#x27; BUCKET_NUM = 5 # 提高哈希量：增加准确性降低速度，时间的增加是几乎线性的 BUCKET_SIZE = 1.5 # （降低数值）提高区分度：降低准确性增加速度 K = 10 buckets = [] mean_precision = 0 mean_recall = 0 total_hash_time = -1 total_bf_time = -1 total_pre_time = -1 # 文件读取 data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) with open(CRRCT_RES_PATH, &#x27;r&#x27;) as f: correct_res_set = json.load(f) # 预处理 pre_start_time = time.time() hash_offsets, hash_vectors = get_hash_para(BUCKET_SIZE) buckets = calc_LSH_indexes(data, BUCKET_NUM) total_pre_time = time.time()-pre_start_time # 查询 hash_start_time = time.time() for query in range(0, 1000): # hash print(&#x27;query index:&#x27;, query) res = search_with_intersection(data[query], K) hash_end_time = time.time() # bf bf_res = correct_res_set[str(query)] # 评估 _, precision, recall = check_accuracy( chk_res=res, crrt_res=bf_res) mean_precision += precision mean_recall += recall total_hash_time += time.time()-hash_start_time + 1 # 结果 mean_precision /= 1000 mean_recall /= 1000 print(&#x27;hash used time:&#x27;, total_hash_time, &#x27;hash preprocess time &#x27;, total_pre_time, &#x27; bf used time:&#x27;, total_bf_time) print(&#x27;precision:&#x27;, mean_precision, &#x27;recall:&#x27;, mean_recall) 暴力： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npfrom sklearn.cluster import KMeansfrom scipy.cluster.vq import vqimport jsonimport timefrom sklearn.metrics.pairwise import cosine_similarity# region functionsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def check_accuracy(check_res, correct_res): accurate_num = sum([i in correct_res for i in check_res]) # false_num = K - accurate_num TP = accurate_num FP = K - accurate_num FN = K - accurate_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # variables COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_PATH = &#x27;./multi/4.10NN.json&#x27; K = 10 # 预处理 hash_pre_time = time.time() data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) hash_pre_used_time = time.time()-hash_pre_time # 查询 mean_accuracy = 0 mean_precision = 0 mean_recall = 0 total_hash_time = 0 total_bf_time = 0 bf_res_set = &#123;&#125; for query_index in range(0, 1000): bf_res = [get_distance(data[i], data[query_index]) for i in range(data.shape[0])] bf_res = np.argsort(bf_res)[1: 11].tolist() bf_res_set[query_index] = bf_res print(query_index) with open(CRRCT_PATH, &#x27;w&#x27;) as f: f.write(&#x27;&#123;\\n&#x27;) for i, (key, value) in enumerate(bf_res_set.items()): f.write(f&#x27; &quot;&#123;key&#125;&quot;: &#123;json.dumps(value)&#125;&#x27;) if i &lt; len(bf_res_set) - 1: f.write(&#x27;,&#x27;) f.write(&#x27;\\n&#x27;) f.write(&#x27;&#125;\\n&#x27;) 准确率与参数参考 需要说明是，准确性和时间受随机与性能的影响很大，因此以下结果仅作参考。 候选点交集： 交集 num：5 size = 1.5 search_time : 350 preicision: 0.94 num：5 size = 1.1 search_time : 168 preicision: 0.84 num：5 size = 1.0 search_time : 247 preicision: 0.91 num：5 size = 1.0 search_time : 119 preicision: 0.84 //这一步可以看到随机对结果和性能的影响 num：5 size = 0.5 search_time : 146 preicision: 0.77 num：5 size = 0.5 search_time : 100 preicision: 0.77 num：5 size = 0.2 search_time : 11 preicision: 0.53 num：5 size = 0.1 search_time : 3.39 preicision: 0.25 取并集： 并集 哈希一次 num：1 size = 0.02 search_time : 18 preicision:0.25 num：1 size = 0.05 search_time : 46 preicision:0.50 num：1 size = 0.10 search_time : 90 preicision:0.74 num：1 size = 0.20 search_time : 169 preicision:0.87 哈希三次 num： 3 size = 0.02 search_time : 58 preicision:0.60 num： 3 size = 0.05 search_time : 153 preicision:0.96 num： 3 size = 0.10 search_time : 230 preicision:0.97 哈希五次： num： 5 size = 0.01 search_time : 47 preicision:0.49 num： 5 size = 0.02 search_time : 86 preicision:0.72 num： 5 size = 0.05 search_time : 189 preicision:0.96 num： 5 size = 0.10 search_time : 290 preicision:0.997 参考 xducs/多媒体数据处理/LSH.ipynb at main · silence-tang/xducs · GitHub 一文看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"}]},{"title":"多媒体实验3：基于 BOF 进行相似图片搜索","slug":"课程报告/多媒体实验3图片搜索","date":"2023-06-12T21:10:47.000Z","updated":"2023-07-04T10:20:55.014Z","comments":true,"path":"post/20230613051047.html","permalink":"http://example.com/post/20230613051047.html","excerpt":"前言 BOF算法是一种通过特征来实现图像检索或分类的算法。","text":"前言 BOF算法是一种通过特征来实现图像检索或分类的算法。 目的/要求 使用BOF算法，在数据集上实现以图搜图：即输入数据集中某一张图，在剩下的999张图里搜索最邻近的10张图。数据集是按文件夹放好的 10 * 100 张 jpg 图片。 什么是BOF BOF，bag of features 是由自然语言处理领域的 BOW（bag of words）引申而来的。BOW，用一个袋子装起了一个个词，顾名思义就是用（关键）词为单位去处理文章句子。引申到图像领域，就用特征（feature）代替了关键词（words），即通过处理特征来处理图像。 具体地说，BOF的思想是这样的：每个图像的特征多少不一而足，我们将这些特征进行归类，就可以把一个的图像转化“有多少个xx”类特征这样的表述，从而方便计算和表述。这个过程就像是把图像的特征扔进一个个袋子里分类，即 bag of features。 而这就有了三个子问题：1.特征哪来？2.袋子哪儿来？3.咋扔？ 特征的来源很多，我们可以使 SIFT 特征，但是使用其他的特征也并非不可，例如 HOG 等。 袋子哪儿来？袋子并不是凭空出现的。而是根据数据集中的特征进行归类归出来的。这是一个把数据归类的问题，我们可以使用 KMeans 聚类算法把所有的数据归为人指定的 K 类。（K的值可能需要不断调整到最佳值） 扔进袋就是给一个查询点，将其放到最近的袋子中。我们可以使用 scipy 中 vq 来完成这一步。 这样，我们就完成了对一个数据集的初步 BOF 处理。 不过，为了更准确地进行搜索，我们还引入了 TD-IDF 对“单词”进行加权。 TI-IDF 想象一下下面两种情况： 在国际新闻中以“美国”为关键词进行搜索：搜索结果数量纷繁。 在国际新闻中以“贸易战”为关键词进行搜索：搜索的结果基本都和近年“中美贸易战”密切相关。 如果我们的目标是查询“2018年中美贸易战”有关的新闻报道，那么“贸易战”是比“美国”更重要的关键词。这是因为“美国”在几乎所有的文章中都频繁出现，而“贸易战”只在贸易战有关的新闻中频繁出现。 为此我们使用 TI-IDF进行评估。TF(term frequency)是某一个词语在一个文件中出现的频率，即词频。IDF（inverse document frequency，逆向文件频率）则衡量一个词语在所有文档中出现的频率。TF-IDF计算方法为： TF=文档中该词数量文档总词数TF=\\frac{文档中该词数量}{文档总词数}TF=文档总词数文档中该词数量​ IDF=lg文档总数包含该词的文档数IDF= lg\\frac{文档总数}{包含该词的文档数}IDF=lg包含该词的文档数文档总数​ $TFIDF= TF\\times IDF $ 只有在特定文件中高，但是在整体文件中低的词语，才能取得较高的TF-IDF值。 我们使用 TF-IDF 加权以后的特征来进行搜索以提高准确率。 程序的基本结构 有关功能基均有库可调，下面简单叙述我的程序中的各个函数。 get_dictionary()，读入图片，用 opencv 计算 SIFT特征。取特征的描述子使用 sklearn 中 KMeans 聚类，取聚类中心代表类。完成这一步，就相当于我们已经造好了“袋子”并找到了“词”。 corel_bof()：遍历前面保存的词，判断各个词最近的袋子是什么。并把结果存入一个 numpy.histogram 直方图中。这就相当于我们已经把词扔进了袋子，以后就可以用直方图代表此图片了。 tf_idf()：使用 sklearn 对直方图进行 TF-IDF 加权。 以上的步骤耗时较长，而且一经处理不再变动。因此可以将其导出为 JSON 或其他文件，方便后续使用。 搜索时则： search_similar()：对搜索图片同样进行上述三步处理。得到结果使用 sklearn 中 cosine_similarity计算其与我们的数据集的 TI-IDF 的余弦相似度。对其排序后返回最相近结果的前 K+1 个。因为我们的图片均来自数据集，因此最像的肯定是自己。 show_result：使用 pillow 显示最像的前 K 个图片。 程序中的一些小点 读入图片可以使用 glob.glob() 递归查找文件目录下的所有图片。 SIFT 的结果只要其中的描述子，这是因为关键点仅包含坐标信息，描述子才真正的表示了一个特征。我们所有的操作都是对描述子进行的。 cv2.imread 默认读入彩图是 BGR 格式，这会导致图片泛蓝。搜索和计算时这并不怎么影响，但是输出时就需要转为 RGB 格式或者直接用 pillow 的 Image.open()。 各个函数的格式要求不一，所以能见到反复转格式。特别是导出为 JSON 时需要转 NDArray 为 list。因为 JSON 是内置的库，但是 numpy 可不是。 试着使用了# region 来折叠代码，不过这不同于 C#，这并不是 python 本身提供的支持。我仅在 VScode 上验证可用。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import numpy as npimport cv2import globimport jsonfrom PIL import Imagefrom scipy.cluster.vq import vqfrom sklearn.cluster import KMeansfrom sklearn.metrics.pairwise import cosine_similarityfrom sklearn.feature_extraction.text import TfidfTransformer# debugcorel_path = &#x27;./multi/corel/&#x27;query_img_path = &#x27;./multi/query.jpg&#x27;dict_file_path = &quot;./multi/dictionary.json&quot;bof_file_path = &quot;./multi/bof.json&quot;tfidf_file_path = &quot;./multi/tf-idf.json&quot;bag_of_features = []features = []tfidf_feature = []# region preProcessdef get_dictionary(mode): &quot;&quot;&quot; 根据图像生成特征字典：一共有这么多的特征。\\\\ 包含SIFT和KMeans两步 &quot;&quot;&quot; if (mode == &quot;load&quot;): with open(dict_file_path, &#x27;r&#x27;) as f: dictionary = np.array(json.load(f)) return dictionary progress = 0 for imgpath in glob.glob(corel_path+&#x27;*/*.jpg&#x27;): img = cv2.imread(imgpath) # 显示进度 print(&quot;load a pic success:&quot;+(progress+1).__str__()+&quot;/&quot;+&quot;100&quot;) progress += 1 # 获取img的所有描述子,不需要关键点 _, des = cv2.SIFT_create().detectAndCompute(img, None) features.append(des) # vertical stack,垂直堆叠二维数组 all_features = np.vstack(features) # KMeans对象对 all_features 聚类 k = 64 kmeans = KMeans(n_clusters=k, max_iter=300, n_init=10) kmeans.fit(all_features) # 词典即聚类中心 # k*128的二维数组 dictionary = kmeans.cluster_centers_ if (mode == &quot;save&quot;): with open(dict_file_path, &#x27;w&#x27;) as f: # ndarray不能直接输出为json json.dump(dictionary.tolist(), f) return dictionarydef corel_bof(dictionary, mode): &quot;&quot;&quot; 表示出每个图片包含特征字典中的哪些特征&quot;&quot;&quot; bag_of_features = [] if (mode == &#x27;load&#x27;): with open(bof_file_path, &#x27;r&#x27;) as f: bag_of_features = np.array(json.load(f)) return bag_of_features # 遍历所有描述子 for des in features: print(&quot;gennerated a des\\n&quot;) # 使用vq获得图片每个描述子最近的聚类中心（属于哪个聚类中心） code, _ = vq(des, dictionary) # 生成到直方图并归一化 # .shape[0]聚类中心的数量 hist, _ = np.histogram(code, bins=range(dictionary.shape[0]+1)) hist = hist/np.sum(hist) # 添加到列表中1000*64维 bag_of_features.append(hist) if (mode == &quot;save&quot;): with open(bof_file_path, &#x27;w&#x27;) as f: json.dump([arr.tolist() for arr in bag_of_features], f) return bag_of_featuresdef tf_idf(): &quot;&quot;&quot;&quot; 计算TF-IDF\\\\ TF值 = 词在文档中出现的次数 / 文档总词数\\\\ 逆向文件频率：IDF值 = log（语料库中包含某个词的文档总数 / 语料库中文档总数）\\\\ 每个词在每篇文档中的TF-IDF值：TF值*IDF\\\\ 在这篇“文章”中出现得多的且其他文章出现得少的“词”，才是能标明它身份的“词”\\\\ 大部分人都有的特征不算\\\\ &quot;&quot;&quot; # list[NDArray]-&gt;NDArray-&gt;稀疏矩阵-&gt;NDArray-&gt;list # 通过NDArray转化为list以输出 tfidf_feature = TfidfTransformer().fit_transform( np.array(bag_of_features)).toarray().tolist() with open(tfidf_file_path, &#x27;w&#x27;) as f: json.dump(tfidf_feature, f) return tfidf_feature# endregiondef searchSimilar(queryIMG, dictionary): # 对单个图像的ti-idf处理 _, m_des = cv2.SIFT_create().detectAndCompute(queryIMG, None) query_code, _ = vq(m_des, dict) query_hist, _ = np.histogram(query_code, bins=range(dictionary.shape[0]+1)) query_hist = query_hist/np.sum(query_hist) query_hist = np.array(query_hist).reshape(1, -1) query_tfidf = TfidfTransformer() query_tfidf = query_tfidf.fit_transform(query_hist).toarray() # reshape(1, -1)：转化为长度为一行的二维数组 # 返回1*1000的二维矩阵similarity similarity = cosine_similarity(query_tfidf.reshape(1, -1), tfidf_feature) top10_indices = np.argsort(similarity[0])[-11:][::-1] print(top10_indices) return top10_indicesdef show_result(result_array): imgs = [] total_width = 0 max_height = 0 for idx in result_array: img_path = corel_path+str(idx//100)+&quot;/&quot;+str(idx)+&quot;.jpg&quot; img = Image.open(img_path) imgs.append(img) total_width += img.width max_height = max(max_height, img.height) # 创建拼接后的图像 result_image = Image.new(&#x27;RGB&#x27;, (total_width, max_height)) # 拼接所有图像 x_offset = 0 for image in imgs: result_image.paste(image, (x_offset, 0)) x_offset += image.size[0] # 显示拼接后的图像 result_image.show()if __name__ == &#x27;__main__&#x27;: # load or save file_op = &quot;load&quot; # 字典、bof和tf-idf的获取 dict = get_dictionary(mode=file_op) bag_of_features = corel_bof(dict, mode=file_op) tfidf_feature = tf_idf() # 查询 query = cv2.imread(query_img_path, cv2.IMREAD_COLOR) result = searchSimilar(query, dict) # 结果 show_result(result) 参考资料 new bing 你是我爹","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"}]},{"title":"云计算实验：在 Windows 平台搭建 Hadoop","slug":"课程报告/Hadoop构建","date":"2023-05-23T11:00:56.000Z","updated":"2023-08-13T18:02:57.184Z","comments":true,"path":"post/20230523190056.html","permalink":"http://example.com/post/20230523190056.html","excerpt":"前言 云计算课程大作业：在本机配置一个 Hadoop 环境","text":"前言 云计算课程大作业：在本机配置一个 Hadoop 环境 准备工作 Hadoop 有三种运行模式：本地、伪分布、完全分布。由于这只是一次实验，我选择的是在本机搭建运行 Hadoop 的伪分布模式。此模式下，Hadoop 守护进程运行在本地机器上，模拟一个小规模的集群，形式上与完全分布相同，使用不同端口代表不同的机器。 我选择的平台与版本如下： Windows 11 Java 16.0.1 winutils 3.3.1 Hadoop 3.3.5 实验过程 下载 在 Apache 官网下载 Hadoop 的已编译版本，解压至指定目录（此处是 C:/Hadoop）中。 由于我已经装了 Java，所以本次实验我省略安装 Java 的步骤。 由于 Windows 不是 Hadoop 的最初开发和运行平台，目前支持还较为有限。为此，需要额外下载工具 winutils。此工具最初由官方社区开发者维护，但是较新版本来自开发者 github/kontext-tech。下载后放入 C:\\hadoop\\bin 文件夹内并复制一份hadoop.dll放到C:\\Windows\\System32下。yarn 已内置于此工具内。 配置文件 新建环境变量 HADOOP_HOME 指向 Hadoop 文件夹。Path添加 Hadoop 文件夹下 \\bin 和 \\sbin 文件夹的地址。完成后可以在终端内通过hadoop version检查是否能被正常识别且无错。 在 \\Hadoop 文件夹下新建文件夹如下： \\tmp \\data\\datanode \\data\\namenode 在 \\Hadoop\\etc\\hadoop 文件夹下,修改 core-site.xml 文件如下： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/hadoop-3.1.3/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://your_host_name_or_localhost:9123&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同文件夹下，，修改 hadoop-env.cmd 中的 Java_home 项的值为环境变量中 JAVA_HOME 的值，即指定 JDK 地址。 修改 hdfs-site.xml 文件如下，指定节点数量和实际存储地址。 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/C:/hadoopdata/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改yarn-site.xml 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hahoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 特别地，在完成上述步骤后我遇到了端口冲突的问题，为了解决此问题，在 hdfs-site.xml 文件中继续添加参数如下: 123456789101112&lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9856&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.http.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9857&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9858&lt;/value&gt; &lt;/property&gt; 格式化与启动 在终端中输入 1hdfs namenode -format 进行节点格式化。观察到输出末尾有namenode has been successfully formatted 字样即格式化成功。 随后启动 \\hadoop\\sbin 目录下的 start-all.cmd。如果一切正常，那么将会弹出四个终端窗口且无报错。此时即已正常运行 Hadoop。 检查 在浏览器输入 localhost:9857 和 localhost:9856，访问 datanode 和 namenode。 使用 hadoop fs -put &lt;local_file&gt; &lt;hdfs_destination&gt; 命令上传文件、hadoop fs -get &lt;hdfs_file&gt; &lt;local_destination&gt;下载文件。创建文件夹（-mkdir）、列出文件（-ls）、删除文件（-rm）等命令与 Linux 系统相似。可以 在namenode中可以观察到上传成功，也可以使用 -ls 命令检查。 遇到的各种问题 winutils 的版本问题 最早的 Wintils 是由 Stevelougran开发的，他是 Hadoop 的提交者（committer）之一。由于忙碌，此仓库停留在了 3.0.0 版本，而后cdarlint继续开发并停留在了 3.2.2 版本，而kontext-tech继续在Fork cdarlint 后开发。 与本次作业的 Hadoop 版本（3.3.5）最接近的是 kontext-tech 的 3.3.1 版本，本次使用的就是此版本。经验证，能正常工作。 yarn --version 无结果 winutils 中包含了运行 Hadoop所需的 yarn，但是这一过程中我们没有给 yarn 配置环境变量，运行上述命令不成功。不过 yarn 实际上已经可以正常运行了。我们可以使用 where yarn（cmd）或where.exe yarn(powershell)来检查 yarn 存在的位置。 JAVA_HOME 的配置细节 需要注意的是，在 cmd 文件中 JAVA_HOME 指向使用的 Java 的地址。此地址不应该包含空格也不能通过打双引号的方式规避空格问题。二者的报错不一样但是均会有影响。前者为&quot;Error JAVA_HOME is incorrectly set.&quot;,后者为&quot;The filename, directory name, or volume label syntax is incorrect hadoop&quot; 针对空格源自 Progame files 的情况，可以通过改写为 PROGRA~1 来表达含义同时规避空格问题。（这是由于早期文件夹名不能包含空格引起的） 此外，电脑上还可能含有多个 Java 版本。通过如问题2所述 where 语句，我们可以检查到底有几个 Java 版本，在环境变量中调整顺序，使得需要的版本最前，即可保证 Java --version的检查结果和后续使用的是同一个版本。 格式化时结尾为&quot;SHUTDOWN_MSG: Shutting down NameNode at xxxx&quot; 这是正常现象，只要在其上可以找到namenode has been successfully formatted即可。 start-all.cmd 时出现&quot;error Couldn't find a package.json file in \\hadoop-2.7.7\\sbin&quot;错误 这一错误是由于有多个 yarn 引起的。例如 winutils 中包含了 yarn 而自己随后又通过 npm 安装了yarn。我选择了暂时卸载后者即可解决问题。 端口被占用 正常来说，我们可以通过杀死对应端口进程来结束占用。检查端口被进程占用的方法是终端中输入netstat -aon|findstr [端口号] 。然后结束对应进程（如果无返回结果则说明此端口无占用）。 但是奇怪的是我一开始并没有发现有什么进程占用了端口。不过通过上述第二部分改端口配置，可以成功解决 namenode 的端口占用问题。而 datanode 则还加了一次重启的步骤。 运行 start-all.cmd 后，可以通过使用 netstat -aon|findstr [端口号] node 对应端口号的方式确定程序在正常工作：各端口均有一个进程。 一个建议： 在配置过程中，不免频繁输入各类命令：例如不断运行 start-all.cmd 同时检查进程。这个过程中可以善用 Windows 终端的多窗口功能，将命令进行分类，使得窗口更加美观。不过，更改了环境变量以后，需要重新打开终端（而非shell）来使其生效。+ 参考资料 WIN10安装配置Hadoop-知乎 如何在windows系统下安装hadoop-CSDN Install Hadoop 3.3.0 on Windows 10 Step by Step Guide hadoop中修改端口号-李悠然-博客园","categories":[],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算","slug":"云计算","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"《第一行代码》笔记","slug":"AndroidNotes","date":"2023-05-13T12:00:39.000Z","updated":"2023-06-09T01:22:46.368Z","comments":true,"path":"post/20230513200039.html","permalink":"http://example.com/post/20230513200039.html","excerpt":"注意 这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。","text":"注意 这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。 结构 Android视图不是真实视图但是屏蔽的文件基本无需修改。 project 目录下主要关心 app 文件夹。app 文件夹下 java：代码文件夹 res：图片、布局等资源 AndroidManifest.xml：项目配置文件 libs：第三方包 AndroidTest：测试","categories":[{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"从 &a+1 说起————数组变量、&和+运算符","slug":"数组名与指针与右值","date":"2023-04-20T15:04:57.000Z","updated":"2023-06-09T01:22:46.380Z","comments":true,"path":"post/20230420230457.html","permalink":"http://example.com/post/20230420230457.html","excerpt":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？","text":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？ &amp;a+1 == ? 这个问题由和同学聊到这个标题而来，其中 a 是一个数组的名字。 一开始我想当然地认为：&amp;a 取得数组首地址，+1 指向数组首地址的下一个地址（字节）。但是事实并非如此，事实上，上面这个算式指向的数组末尾地址 +1 的那个地址。 为了搞懂这个问题，必须要理解一个在这之前的学习中被忽略的问题，即：数组是什么类型？int 型变量和 int 型数组和长度不同的 int 型数组，属于相同的变量类型吗？进而，我了解到了引用、左值与右值、以及关于指针的一些知识。 开始探索吧。 测试代码 我们以 c++ 来讨论这个问题，为此，定义变量并写下测试程序如下，我们稍后解释测试结果： 1234567891011121314151617181920212223// 数组int a[5];// 非数组变量int t = 2;int *p = &amp;t;// 引用int n = 4;int &amp;nn = n;// 数组值、大小printf(&quot;value: %d %d %d %d %d %d\\n&quot;, a, &amp;a, a + 1, &amp;a + 1, (int *)&amp;a + 1, (char *)&amp;a + 1);printf(&quot;sizeof: %d %d %d %d\\n&quot;, sizeof(a), sizeof(&amp;a), sizeof(a + 1), sizeof(&amp;a + 1)); // 20 8 8 8cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(a + 1).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a + 1).name() &lt;&lt; endl;// 变量cout &lt;&lt; &quot;\\nsingle\\nvalue: &quot; &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p + 1 &lt;&lt; endl;cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(&amp;p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(*p) &lt;&lt; endl;cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(*p).name() &lt;&lt; endl;// 引用cout &lt;&lt; &quot;\\n变量引用\\ntype: &quot; &lt;&lt; typeid(n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(nn).name() &lt;&lt; endl; 在上述代码中，我们使用了 sizeof 来检查输出变量的大小，typeid 运算符检查变量的类型。typeid 的 name 方法输出变量类型的名字。如下解读：A 指代 array，i 指代 int 型，P指代 pointer。其他的没有出现在输出中。 它的输出如下： 1234567891011value: 6487488 6487488 6487492 6487508 6487492 6487489sizeof: 20 8 8 8type: A5_i PA5_i Pi PA5_isinglevalue: 0x62fdb8 0x62fdbc 0x62fdb0 0x62fdb8 2 3sizeof: 8 8 4type: Pi PPi i变量引用type: i Pi i 对测试结果的解释 数组变量和数组退化 在定义一个数组变量，编译器将为数组分配一块连续的地址空间，并且产生一个数组变量 a。在这里，a 是数组名，也即所谓数组变量。数组变量是一种特殊的变量类型，它包含有【数组长度】个【数组单元变量类型】的变量。例如，我们的数组变量 a 就是包含了 5 个 int 型单元的数组变量。它不是一个 int 型变量，也不是含糊其辞的数组型变量。在我们是输出结果中，这被写作A5_i。 在很多情况中，数组变量 a 的表现和一个指向 a[0] 的指针一样，但是它们并不一样：指针不包含长度信息。很显然数组变量指明了数组的长度，但是一个指针并不清楚自己指向了一个数组单元还是一个变量。从数组变量变成指针，我们称之为“数组退化”。 “数组退化”的发生情况很多，最常见的一种是把它作为参数传入以后。为什么要这么设计很好理解：不同长度的数组是不同类型的变量，如果不退化成指针，写函数时就必须指定数组的长度，这很不方便。如果退化成指针，我们只需要再加一个参数指明数组长度就可以解决问题。 左值和右值 另一种会导致数组变化的原因是将其作为了右值。 左值和右值是 c++11 引入的特性。左值指能在内存寻址的值，右值则不是。我们用下面这个例子进行区分： 12int i;i= 12; 很明显我们不能说 12 存储在内存上的哪儿，但是可以说出 i 在内存的地址。 下面是数组变量因为作为右值而退化的例子（或者说，我们认为编译器在这里把数组名解释成了指向数组头的常量指针）。 123int a[5];a++;int *b = a+1 特别需要注意的是，尽管对左值进行自增操作是允许的，但是上面的 a++ 写法事实上是错误的，因为数组变量指向的地址是不可修改的。这也是为什么我们说它退化后是常量指针。 另外一个有意思的地方在于 a++ 和 a 一个返回右值一个返回左值。这是因为 a 操作先取得 a 的值，再返回 a 的值，最后把加一的值赋给 a ，++a 则完成了赋值操作再返回。这导致前者返回的值事实上不是 a 地址的值，所以只是右值。 关于 &amp; 符 &amp; 运算符有两种用法，第一种是取地址，第二种是取引用。 取地址当然就是取得变量地址，这意味着两件事：第一，它的右侧必须跟着一个左值；第二它返回的值的类型是指向某个地址的变量————即指针。 另一种引用是引用。引用相当于给 n 变量取了一个别名 nn。如果改变 n 的值，也就改变了 nn的值。这两个变量的地址是完全一样的，这不同于定义一个指针。nn 并不是一个指针，它和 n 有相同的变量类型和地址。 前面提到了 a++ 和 a ，而 &amp;a 和 &amp;++a 都是错误的，但是原因并不相同。前者是因为返回了右值，后者是因为视图修改常量指针。 指针的 + 运算 指针的 + 运算会得到不同的结果。具体来说就是，指针 +1 时，指的并不是地址 +1 字节，而是 +1 指针指向的变量大小单元。如果是 int 型指针，那么 +1 指的就是 4 字节，如果是 char 型，就是 1 字节。 如前所述，数组是数组类型而不是指针。所以一个指向数组的指针 +1 ，并不是加一个指针大小（64位系统上是 8 字节），而是加一个数组长度。首地址加数组长度，很显然指向的就是数组地址的尾地址 +1 了。 我们通过一个简单的小测试来验证这个说法：输出(int*)&amp;a+1和(cahr*)&amp;a+1。可以发现前者是在首地址基础上 +4，后者是 +1.这是因为数组变量型指针在 +1 前被转换成了 int型和 char 型，从而影响到了后续的 +1 操作的含义。 一个有趣的事情是，+ 运算符的优先级高于 &amp; 运算符。但是在 &amp;a+1 中会先执行 &amp; 运算，这是因为如果先执行 + 运算，返回的右值无法进行 &amp; 运算，出现语法错误，所以编译器隐式转换成了（&amp;a）+1。 总结 这里是前面的总结。 a:数组变量，直接输出得到其存储的数组起始地址。 a+1:数组变量退化成指向数组起始地址的指针常量，再加一个数组内单位长度 &amp;a：取数组变量的地址，会得到值是数组变量的起始地址，但是数据的类型是数组变量型指针 &amp;a+1：等价于 (&amp;a)+1，因此是数组变量地址的邻接地址 &amp;a++:错误,a++ 返回右值，返回值不是真正 a 的值，违反了 &amp; 的要求 &amp;++a:错误,++a返回左值，但是数组变量指向的地址不可修改 &amp;(a+1):错误，a+1是右值 （int*）&amp;a+1: 将数组变量类型指针转换为int型指针再加一个单位","categories":[{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"多媒体实验2：PCA主成分分析","slug":"课程报告/多媒体实验2PCA","date":"2023-04-10T14:47:38.000Z","updated":"2024-01-03T17:25:30.055Z","comments":true,"path":"post/20230410224738.html","permalink":"http://example.com/post/20230410224738.html","excerpt":"前言 PCA（Principal Component Analysis）是一种常用的数据分析方法。","text":"前言 PCA（Principal Component Analysis）是一种常用的数据分析方法。 从数据压缩说起 正如本课的课名所指出的,本课探究的是计算机对多媒体数据的处理分析过程。这个过程中，我们将人类看得懂的各类信息（声、图、文、语言等）输入计算机，期望计算机能对&quot;信息&quot;进行分析，进而发现&quot;知识&quot;，从中学习或者获得智能。把信息在人类载体（上述声、图、文、语言等）和机器载体（比特）之间变换的过程，就是编码和解码。数据压缩，就是在编码的过程中将庞杂的信息转化为更简短和信息，进而方便处理。 例如，对信息 111444444999995，我们可以记为 1#3 4#6 9#5 5#1 从而起到压缩的作用 在这个过程中可以注意到，不是所有的信息都具有相同的价值。压缩数据时，我们希望保留那么有价值的数据，而舍弃那些几乎没有关联的数据。这就带来了如何判断一个数据是否可以被舍弃的问题。 例如人的视觉和听觉中，对高频细节不敏感，可以在变换过程中滤除高频系数，保留低频系数，从而减少数据量。减少处理的难度。一个有名的例子是傅里叶变换。 我们首先定义数据的表示方式，我们记一条数据为一个向量，它的每一维都是一个类别的数据。我们希望对它进行处理，使得向量的维度尽可能的少，同时信息丢失尽可能的少。这个过程被称之为&quot;数据降维&quot;。 如果一个电商平台提供了浏览量和购买量两个数据，二者肯定不等价，但是浏览量高的店铺成交量往往更高。所以我们可以考虑舍弃其中一个数据，这样我们依然可以较好的衡量一个店铺的经营状况。 对此，我们可以采用 PCA。 PCA的思路--------重新发现 空间变换 我们已经知道 PCA 的目标是数据降维。接下来我们看看是如何做的。开始之前，我们先规定，一条数据是一个向量，多条数据排列就形成了一个矩阵。我们以矩阵为基本单位进行讨论。 以二维空间为例，如果对一个数据集，其点大致分布在直线 y=x 附近。我们可以想到，采用以 y=x 为轴而非 x、y 为轴的话，表示会更加简单。我们忽略 y=-x 方向上的量，把点投影到 y=x 上，此时仍可以基本保持原来的形状，同时，原来二维的数据被降维到了一维。 在这个过程中，我们进行了数据降维。本质上是把一个二维空间给变换到了一个一维空间。在线代中我们已经明白可以采取矩阵乘法进行变换。问题的关键是：我们已知需要变换到 K 维空间。如何选择此 K 维空间的基呢？即如何确定变换矩阵？ 具体来说，我们可以认为两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。 我们的目标是变换后尽量保留最多的原始信息。对此，一种直观的看法是：希望投影后值尽可能分散。 方差与协方差 高中阶段我们就已经知道，数学上使用方差来表达分散程度的概念。方差可以被如下表示： Var(a)=1m∑i=1m(ai−μ)2Var(a)=\\frac{1}{m}\\sum_{i=1}^m{(a_i-\\mu)^2} Var(a)=m1​i=1∑m​(ai​−μ)2 预先对矩阵进行处理使得均值为 0 ，则有 Var(a)=1m∑i=1mai2Var(a)=\\frac{1}{m}\\sum_{i=1}^m{a_i^2} Var(a)=m1​i=1∑m​ai2​ 多个维度中，我们希望尽可能多的表示原始信息，所以维度之间不应该存在相关性，否则它们的信息就会有重复。我们使用协方差衡量相关性。 Cov(a,b)=1m∑i=1maibiCov(a,b)=\\frac{1}{m}\\sum_{i=1}^m{a_ib_i} Cov(a,b)=m1​i=1∑m​ai​bi​ 相互之间协方差为 0 时，相关性最弱。所以我们需要选择相互之间协方差为 0 且字段方差尽可能大的一组向量作为基底。 在数学上，有：设 m 个 n 维数据记录排列成 n×mn\\times mn×m 的矩阵X，而 C=1mXXTC=\\frac{1}{m}XX^\\mathsf{T} C=m1​XXT 则 C 是一个对称矩阵。其对角线分别个各个字段的方差，而第 i 行 j 列和 j 行 i 列元素相同，表示 i 和 j 两个字段的协方差。 由前面的分析可知，我们使 C 非对角线为 0（协方差为 0 ），对角线由上到下递减。那么我们选取 X （而非 C ）的前 K 行，就得到了我们需要的变换矩阵。我们对 C 操作的这个过程被叫做矩阵的对角化。 现在问题变成了：如何使协方差矩阵对角化？ 特征值 一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量，设这n个特征向量为 e1,e2,⋯ ,ene_1,e_2,\\cdots,e_ne1​,e2​,⋯,en​ ，我们将其按列组成矩阵 E。对特征向量矩阵 E 和协方差矩阵 C，有： E^\\mathsf{T}CE =\\Lambda =\\begin{pmatrix} \\lambda_1 &amp; &amp; &amp; \\ &amp; \\lambda_2 &amp; &amp; \\ &amp; &amp; \\ddots &amp; \\ &amp; &amp; &amp; \\lambda_n \\end{pmatrix} $$ 进而我们需要的矩阵 P 有： $$P=E^\\mathsf{T} P 是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是 C 的一个特征向量。如果设P按照 Λ\\LambdaΛ 中特征值的从大到小，将特征向量从上到下排列，则用 P 的前 K 行组成的矩阵乘以原始数据矩阵 X ，就得到了我们需要的降维后的数据矩阵 Y 。 总结 总结 PCA 的思路。 目的：我们需要数据压缩，为此，将数据进行降维，删去那些没有带来额外信息或者带来信息极少的维度，即数据降维。 投影：我们将 M 维数据尽可能分散地投影到 K 维空间上。因为越聚集就代表投影以后（该方向）丢失的信息越多，得到的数据的信息越趋同。着我们尽可能让每个点的信息都被记录下来就需要分散。 例如: 在纸上画出一个立体图像的时候，我们会选用一个倾斜的角度展现三个面，而不是三视图中的一个面； 三维空间的直线投影到二维应该最好是投影成直线而不是一个点。 我们使用方差来衡量一个方向的数据分散程度，使用协方差来保证每个方向都是正交（相关性低）的。 我们使用特征值向量矩阵选取协方差矩阵中方差最大的 K 个正交方向（主成分），再把原始数据变换刚刚求出的 K 维空间中去即可。 PCA的具体步骤 我们可以把上述过程总结为下述步骤： 设有 m 条 n 维数据，我们将其排成 n 行 m 列（ n*m ）的矩阵 X，按一下步骤对齐进行 PCA： 将X的每个属性字段进行零均值化，即减去这一列的平均值（如果我们排成 m 行 n 列，也可以是减去行的均值）。 求出协方差矩阵 C=1mXXTC=\\frac{1}{m}XX^\\mathsf{T}C=m1​XXT 求出协方差矩阵的特征值及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 k 行组成矩阵 P 对 X 左乘矩阵 P，有 Y=PXY=PXY=PX 即为降维到k维后的数据。 PCA的python实现 我们可以使用 numpy 进行矩阵计算；使用 pandas 读取 ASC 文件中的数据 此外，scikit-learn 库中的 PCA 模块可以直接实现 PCA，我们可以使用它验证我们的代码。 具体来说，我们使用到了 numpy 的以下方法： np.mean() :求解行/列均值用于零均值化 np.dot(): 点积运算 instance.shape:获取行数、列数等数据 np.linalg.eig()：特征值 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport pandasdef PCA(x, k): # n维n列 # m条m行 # m*n的矩阵 # 1\\. 形成样本矩阵，样本零均值化 # 压缩0轴（行），得到1轴（列）的均值 mean mean = np.mean(x, axis=0) x -= mean # 2\\. 计算样本矩阵的协方差矩阵 x_col = x.shape[1] cov = np.dot(x.T, x)/x.shape[0] # 3\\. 对协方差矩阵进行特征值分解 eig_vals, eig_vecs = np.linalg.eig(cov) # 对应特征值与特征向量 eig_pairs = [] for i in range(0, x_col): eig_val_i = np.abs(eig_vals[i]) eig_vec_i = eig_vecs[:, i] eig_pairs.append((eig_val_i, eig_vec_i)) # 选取最大的p个特征值对应的特征向量组成投影矩阵 eig_pairs.sort(reverse=True) feature = [] for i in range(0, k): feature.append(np.array(eig_pairs[i][1])) # 4\\. 对原始样本矩阵进行投影，得到降维后的新样本矩阵 reduced_data = np.dot(x, np.transpose(feature)) return reduced_dataFILEPATH = &quot;D:\\DocumentsSet\\ColorHistogram.asc&quot;data = pandas.read_csv(FILEPATH, sep=&#x27; &#x27;, header=None, index_col=0).valuesresult = PCA(data, 5)print(result) 参考资料 CodingLabs - PCA的数学原理","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"多媒体实验1：算术编码的 python 实现","slug":"课程报告/多媒体实验1算术编码","date":"2023-04-06T14:59:08.000Z","updated":"2023-07-04T10:20:42.114Z","comments":true,"path":"post/20230406225908.html","permalink":"http://example.com/post/20230406225908.html","excerpt":"前言 算术编码是一种编码算法，它比哈夫曼编码更高效。","text":"前言 算术编码是一种编码算法，它比哈夫曼编码更高效。 由哈夫曼编码说起 哈夫曼编码对于更高频的符号，使用更短的编码。由于编码的前缀是不一致的（短编码不是长编码的前缀），所以我们可以保证唯一确定一个编码的长度不发生混淆。 可以通过构造一个特殊的二叉树的方式求哈夫曼编码，这个树就是哈夫曼树。下面是一个哈夫曼树示例。 香农的信息熵公式指出 $$H(x)=-\\sum\\limits_{x} P(x)log_{2}[P(x)]$$ 其中 H(x)H(x)H(x) 为信息熵， P(x)P(x)P(x) 为每个符号出现的频次（概率）。 哈夫曼采用整数进行符号编码的，使得其不能更好的逼近信息熵极限。 例如，如果 A 的出现频次是 0.5，B 的出现频次是 0.4，C 的出现频次是 0.1。那么我们应该期待 B 的编码长度接近于 A，而不是 C，但是事实上 B 的编码长度和 C 一样长，是 A 的编码的两倍长。因此，其达不到最佳的编码长度。 一个更好的办法是：改用算术编码。 算术编码的原理 算术编码的本质思想，也是对于高频的字符进行短编码。但是具体实现并不相同。 设想一个区间被划分若干段。任给一个数字，通过比较我们就不难判断出其属于哪一个段。现在我们统计每个字符的频次，并将其依次对应到 [0,1)[0,1)[0,1) 区间内同样长度的一段内。编码一个字符，我们就找出对应的区间，并把区间内的一个数字作为编码值，就能唯一确定这个编码。 例如: 假设对字符 A、B、C，有 P(A) = 0.5 P(B) = 0.4 P(C) = 0.1 则对应到区间如下 A:[0,0.5) B:[0.5,0.9) C:[0.9,1)A:[0, 0.5)\\ B:[0.5, 0.9)\\ C:[0.9, 1)A:[0,0.5) B:[0.5,0.9) C:[0.9,1) 假设有编码值 E = 0.75，由于 0.75 在区间 [0.5,0.9)[0.5, 0.9)[0.5,0.9) 之间，所以对 E 进行解码就有解码值 D = &quot;B&quot; 在一个字符串内，我们重复这个过程，每次都在之前的编码区间内继续按比例进行划分。这样，我们就得到了为一确定了一个区间可以代表原来的文本。在区间里，按&quot;取二进制值最短的数作为编码值&quot;的原则取编码，就能得到算术编码的编码值。 解码的时候，我们进行上述操作的逆操作即可：不断划分区间，看编码在那个区间内，就继续对齐划分区间。 特别需要注意的是，在取编码值的时候，我们只考虑其编码值最短，这会引起一个解码时的问题，即我们不知道能解码多少位。因为所有以 MSG 为前缀的信息 MSG' 都处在 MSG 的编码区间内，我们难以确定是否 E 是 E(MSG),还是 E(MSGA) 或者 E(MSGB)。（吗） 算术编码的实现 下面给出我的算术编码代码思路。 decimal库：算术编码需要高精度的小数，在通常的浮点数运算中，很容易出现精度不够或者计算误差的情况（例如本应得到 0.3 但是实际内存中的值是 0.2999999999 或 0.3000000000041）。我们通过引入库 decimal 来解决计算位数和精度上的问题。 预设的比例区间 编码函数 encode：在上述区间内计算，得到一个结果区间。 解码函数 decode：对编码值转换为十进制，在上述区间内计算，确定属于什么区间，不断解码出信息。 十、二进制转换函数：我们使用十进制进行表示和计算，但是最终希望得到的编码是二进制值，因此，我们需要二者间的进制转换作为编码与解码的基础。特别的，bin() 求解的是区间（value。valueUp）区间内的最短值。具体来说，我们对左右区间不断转换二进制并比较，检查到二者的第一个相异位，此时左边界此为 0，右边界为1。我们取此位为 1。则得到最短编码值。只要我们认定编码值均小于等于右侧边界，就不会造成问题 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import decimal# use Decimal for high precisiondef bin(value, valueRange): result = list() valueUp = D(value+valueRange) value = D(value) while 1: value *= D(&quot;2&quot;) valueUp *= D(&quot;2&quot;) # 均大于 if value &gt;= 1: value -= D(&#x27;1&#x27;) valueUp -= D(&#x27;1&#x27;) result.append(1) # 均小于 elif valueUp &lt; 1: result.append(0) # low0up1 else: if valueUp == D(&#x27;1&#x27;): result.append(0) result.append(1) break while 1: i = result.pop() if i: result.append(i) break return resultdef dec(value: list) -&gt; decimal.Decimal: w = D(&#x27;1&#x27;) result = D(&#x27;0&#x27;) for i in range(0, len(value)): w *= D(&#x27;0.5&#x27;) result += w*value[i] return resultdef encode(): encode_str = input() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) for i in encode_str: index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) return bin(l, nowRange) # h = thedict.get(encode_str[i]) # print(h)def decode(codebin: list, codelenth): codedec = dec(codebin) result = str() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) st = D(&#x27;0&#x27;) for j in range(0, codelenth): for i in range(1, len(low)): st = (low[i])*nowRange+l # ed = st + nowRange if codedec &lt; st: index = i-1 # index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) result += chars[index] break return resultif __name__ == &#x27;__main__&#x27;: D = decimal.Decimal decimal.getcontext().prec = 32 chars = input(&quot;Dict:&quot;).split(&#x27;,&#x27;) # if default if chars[0] == &quot;0&quot;: chars = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] distribute = [D(&#x27;0.1&#x27;), D(&#x27;0.4&#x27;), D(&#x27;0.2&#x27;), D(&#x27;0.3&#x27;)] else: distribute = input(&quot;Distribute:&quot;).split(&quot;,&quot;) ans = encode() print(str(ans)) ans = decode(ans, 7) print(ans) 参考资料 什么是算术编码 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"}]},{"title":"2022 Seed 训练营笔记收录","slug":"Seed训练营笔记收纳","date":"2023-03-24T14:47:43.000Z","updated":"2024-01-03T14:51:46.138Z","comments":true,"path":"post/20230324224743.html","permalink":"http://example.com/post/20230324224743.html","excerpt":"前言 2022 年参加 Seed 训练营的笔记，另附 Seed 训练营感想。","text":"前言 2022 年参加 Seed 训练营的笔记，另附 Seed 训练营感想。 开发系列课 1.架构 架构的意义是什么？ 划定边界 生物属于动物，但是哪些东西能判定一个生物是动物？ 玩家操作player，玩家不能操作NPC，Bot属于NPC还是player？其他玩家属于player还是NPC？ 只有划定边界才能解决这个问题 设计就是不断的重新划定边界 例子：建筑师需要定义规格 建筑师的设计需要有极多的国家规范 软件项目也需要规格，设计者就是一种建筑师 例如player设计可能有三米高，但是建模只能允许两米以下的player进入 只有严格的物理计算参数才能有和谐的演示效果 设计可能存在的问题 性能的过度冗余：明明只有1000的在线，却考虑1000K的在线性能 功能的过度冗余：明明只需要打电话，却也考虑了打游戏的功能。 讨论架构需要画图 1.5.实现架构 抄 面向项目内代码编程 面向GitHub/Stack overflow编程 依葫芦画瓢 2.模块的基本目标 问题：区分边界：这个函数该在这个模块还是那个？ 要求：用词准确：没有二义性、也不过于繁琐失去宏观性。 困难：语言本身却存在模糊性 解决方案： 减少词的二义性： 形成团队共识 使用最基本的共识：自从词语最基本最字面的意思来使用。 举例：不使用“持有”而使用“拥有”或“在手上”。 注意：如果一个模块囊括了太多不同的功能，模块也就失去了它的意义（state controller） 反复绕来绕去的逻辑是bug的温床 2.5模块间的关系 关系A：关联、泛化、细化、依赖 关系B：聚合、组合 模块之间相互用到信息或服务 脚本可能是一个模块，模块和模块之间还可能构成一个更大的模块。不能忽视后者的存在。（如玩家移动模块和玩家背包模块可能同时构成玩家模块） 如果一个模块已经被聚合了，对外界应该是一个统一的模块。这就是说，外界应该统一从一个地方调用模块内部接口，而非在深入了解后从各自的地方调用。这样可以避免同步的问题等等。 3. Debug bug的三步走 重现bug 打断点是最快最方便的定位方法 有时过多断点需要通过条件过滤断点 分析原因 重新设计 避免不一致的设计 如果闻到“bad smell”那一定有什么不对劲 内部用户的易用性也是非常重要的，即使改动非常小 4. 项目程序规范 不提交无关的文件 删除调试代码 一次提交一个bug 提交时的注释很重要 注释中文还是英文：从大家利于理解的角度 有统一最重要，是什么不重要。 命名规范 代码风格 其他内容 创意与原型：创意部分 A.困惑 如何快速产生大量创意？ 如何清晰快速有感觉的展示？ 如何判断创意是否靠谱？ B.发现创意 step1：一个主题+三个词 标准：使用名词或动词,不使用形容词。因为每个人对形容词的感受是不一致的。 step2：一个名字+三句话 用三句话写明短中长期的玩家历程体验 step3：图文一页展示 找图片：要求贴合三句话、画风一致、符合自己的想法（包括对画风的想法） 排版等 step4：电梯演说概述游戏 电梯演说：高效地表达自己的想法 提高演说力：乔布斯的模拟演讲 e.g:“我想做一个野炊式画风崩坏式战斗的弱联机开放世界…“ C.设定Box 划出你的边界，游戏创意不能超出这个边界 如何设定box？ 从自己出发:兴趣、擅长 从市场出发:行业数据、市场调研 创意与原型：原型部分 原型不等于游戏：它只是解答问题、验证想法的游戏的部分模拟。 游戏demo又或者纸面原型。 A.明确问题 例如 sf4中，什么是玩家需要抉择的？ 皇室战争中，玩家会如何搭建自己的卡组？ PUBG，玩家会如何选择开局？带来什么体验？ 头脑风暴 rules： 头脑风暴不管对错，不做评价 头脑风暴时，点子越多越好 即使有人讲错了，只需要往最终的方向带就行 需要存在一个主持人 原型头脑风暴只为最终体验服务 不同类型的交通工具消耗成本、运载容量等数据固然重要，究竟是摩托车还是电瓶车却是更直观具象的游戏体验。 头脑风暴为游戏提供所需的元素 B.明确范围 以SF4为例： 时长：模拟的是一个回合的瞬间？还是一个回合？还是若干回合？ 时期：模拟游戏早期？末期？ C.明确形式 原型准备： 玩家输入 接单、过单… 系统输出 -出单、奖励…… 桌游 开票 跑团 玩 自己和自己 和策划 设计师眼中的游戏 1.游戏是构建体验的系统 为什么游戏是构建体验的系统 最核心的目标就是构建体验，但是为什么是游戏？ 游戏的互动性 体验大于玩法，玩法服务于体验。 同样的玩法，换一个设定，也许吸引的人就完全不一样。 构建体验的四要素 机制、设定、美学、技术 2. 体验从理解人类开始 A.理解用户 人的注意力是有限的 模式认知：人脑会自动识别抽象。 ￮ 容易认知模式 ￮ 不容易掌握 对比产生美 可塑的大脑：越练习，越熟练 情感黑盒：吊桥效应 大脑的偏见：看上去不一样长的线实际上一样长 人是千差万别的 男女差异、MBTI、职业、游戏经历…… 用户的动机 quanticfoundry的玩家动机理论，九种玩家 B.理解市场 市场是多变的，也是可预测的 市场的特点： 市场竞争 游戏是非竞争性商品 游戏可以被轻易的复制，不会因为我玩别人就没办法玩 马太效应 强者恒强，强力的游戏可以轻易吸走冷门游戏的用户 创新者的困境 巫师三让市场对2077有过高期待 英雄联盟让拳头难以花时间精力推出新的游戏 船大难调头 细分市场：细分市场是信息流转充分发达情况下的必然结果：适合大部分人的 80 分产品也许吸引不了大部分人，适合小部分人的 95 分产品却很有可能吸引小部分人中的大部分人。 未被开发的细分市场就是蓝海市场。 B.市场定位（竞争） 自我定位 在细分市场的定位 蓝海？还是红海？ 竞品？ 自己在和什么游戏对比？ 市场会拿来和什么游戏对比？ 哪些地方更好了？哪些地方可以被放弃? 3. 什么是好的游戏 A.好的体验 强烈的情感体验：高光时刻 心流体验：这个玩家太难，那个玩家也许太简单 沉浸： B.可持续发展 利润=营收-开发成本-营销成本 营收=用户规模*用户付费 营销也是产品设计的一部分：广告、买量、主播直播、黑魂是数值不平衡的垃圾游戏还是有挑战性的硬核游戏？（hook成本） 积累=提升质量、降低成本 作品管理入门（以三周的 Seed 项目为例） 如何把想法落地？ 排期表 开发流程前决定谁是 PM 玩法验证 不要复合验证，不要着眼于验证中新产生的想法 开发过程注意 完整流程与工作项的 mapping 优先交付高价值的部分 敏捷开发 晨会制度：同步成果、目标、困难 展示会 回顾会 情感表现 好的剧本可以拍出好的电影，但是好的剧本不一定能拍好电影 同样的事情，想要传达不同的情感会深刻改变游戏的： 场景调度 隐喻：破案感、发现穿帮镜头的兴奋感 节奏（情绪曲线）：好莱坞三段式… 引发回忆：引发群体回忆、各年度回顾 灯光：主光辅光轮廓光的软度硬度 转场 设计流程 学会根据需求预估工作量 多少模块？ 多长时间？ 多少行代码？ 需求分析 理解、分析、注意约束 未表达的要求 潜在的限定 未来可能的发展变化 系统责任和对外交互 逐个完成模块设计，然后汇合 需要的话，画状态图和（或）流程图辅助代码设计----“盖大楼”的“脚手架” 可能的设计方向 以点带面（最常见） 自顶向下（技术要求高） 自顶向上，逐步拼装 自中向下，在逐步拼中为大 要达到更高的技术要求，就要有从“以点带面”向“自中而下”靠拢的行动力。 不太重要的 不太重要，或者说我没太记的一些笔记。 音频 游戏中音乐类型 音效与音乐 音乐功能设计 氛围营造： 闪避效果：人声压背景 分轨设计：转阶段后不断叠加分轨音乐细节更加丰富 反馈信息： RTPC：实时根据游戏参数反馈改变音乐 娱乐效果： 游戏音乐内容制作 主流中间件：Wwise，Criware… 快捷制作 audio editor插件 心理 情绪曲线 心理需求 丰富的体验 消极情绪+积极情绪 消极情绪的作用：快速参与代入、高强度的代入 推荐 心理学家的面相术 情绪（蓝色粉笔字封面） emotionpolygon 游戏数据 制作是不断优化选择的过程 手上有多少东西可以选？ 游戏源自生活 电影和游戏 电影：剧本 游戏：机制+剧本 游戏： 纯机制的游戏是存在的 剧本可以辅助理解游戏机制 表达情感","categories":[{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"}]},{"title":"2022 Seed 训练营笔记收录","slug":"维塔士实习回顾","date":"2023-03-24T14:47:43.000Z","updated":"2023-09-15T14:08:47.040Z","comments":true,"path":"post/20230324224743.html","permalink":"http://example.com/post/20230324224743.html","excerpt":"","text":"前言 记第二次实习：在维塔士西安工作室的虚幻Demo。 开始与 Unreal 学习 七月的困顿中发现了老师在群里发的维塔士西安工作室的实习海报，于是抱着再怎么样也比在学校勉强自己对着牛客OJ发呆好的态度报名，然后面试等等各种流程走下来，也就是入职了。 维塔士西安是西安仅有的几家游戏公司，所以虽然本身是 2B 的业务但是居然也让我听过，再加上上个学期有参与 OpenDay 也就更熟了一点（和 NS 失之交臂呜呜）。 Git树上下 树下的肥（屎）料（山） 这次主要是负责了 Buff 系统;整个设计大概是这样的： 角色有 Buff 和技能； Buff 修改玩家的属性，技能则由玩家主动施放，由更多的自由度。 例如，我们可以将手雷设计为一种技能，血包设计为一种技能，他们有对应的按键，有特效，有各种独一无二的动画和逻辑…… 而 Buff 只需要储存什么修改了玩家的什么属性即可 所以 Buff 只需要是一种数据结构 Buff 有冲突、有一个 Buff 改多种属性、有时限，有延时增减等情况。 话是这么说，但是实际上写起来却乱七八糟。一开始我设想了一种基数据类，他存储了最基本的数据信息，然后，对于不同的时限等问题分开衍生子类。这样，就可以用一个指针队列存储所有的 Buff 了。但是这样做的问题在于数据类型实际上是不一样的，需要类型转换（例如我们也许会有 Float 型的血量，但是 int 型的金钱）。这样做技术上来说并没有问题，但是说到底 void* 指针强转本身就是不安全的。尽管在这一方向的尝试让我了解了模板的一些知识，但是最后我还是放弃了这种做法。 最后的“摆烂”做法是将所有的数据堆在了一个数据结构中，对于不需要的数据（例如一个无限时的 Buff）直接置空就行。这种做法当时看来是摆烂、权宜的做法现在想想其实是正确的。回头翻翻在西山居的代码，也是读表读出的字符串，然后在构造的时候做类型转换。（这里的类型转换是基本类型，而且不牵扯到内存地址，所以并不是那么的不安全）。那么对于这个数据结构，我们也完全可以做这样的权益，即大家都用 float 型，或者放大以后用 int 型，抑或 string，这样就可以使用统一的容器存储他们了。如果我们用的时候是做其他类型的值————无非int/ float / bool 等等，再去做类型转换就 ok 了，至于转换的逻辑，例如大于零则视为 bool 为真完全可以放到对应属性的逻辑函数中去做。 我原本的设想是数据结构中有一个指向其附属角色的指针，这样就抽象成将 *buff.AttributePtr 赋值为 buff.value 就可以了。但是事实上根本没有足够多的属性值得去这么做，即使有，也完全可以写成让 changeAttribute() 根据实际参数去定义一个对应的指针。 事实上，在云计算的课程中就讲到过，应该是 google 云计算数据库只能存入字符串类型的值，大大简化数据的存储管理，不管要什么值，要值的一方自己去做转换即可。毕竟索取值的一方自己肯定很清楚值的类型。 另一个值得一提的思考是属性组件，按理来说属性组件是存储所有的属性，但是事实上这样做不妥：如果是 public 那么属性是不安全的；如果是private/protected ，每个组件用到属性的地方都会产生一个函数调用。而且，UE 框架中的 MovementCoponent 本身已经是写好的了，我们总不能重载它去适应我们的属性组件吧？ 所以更好的办法是每次修改值的时候，属性组件去查询对应的组件的值然后做修改，如果有事件，不妨也在属性组件做通知。这样只要保证大家都从属性组件做修改就不会有问题。此外，可以所有的组件声明属性组件为友元，这样就可以不写函数接口，而只有属性组件能只有访问那些私有成员，其他的组件没有办法去做修改。（当然友元的写法会破坏面向对象的封装性，但是暂时想不到其他更好的解决办法了，也许最好的办法是不要AttributeComponent）。 其他的一些工作：改蓝图，让 Buff 加成的属性在血条上显示成蓝色（其实是做了两个血条）。以及各种情况下的读蓝图，也算会了点蓝图的基本操作。 树上的猴子 这次实习我们使用的是跑在局域网上的 Git 仓库，之前不能说没有用过 Git 但是还确实没用过其进行多人协同，这次也算是一次体验了。 rebase, merge, fetch,revert... 这些操作有些之前不是很熟悉也借此机会有了一定的了解。一次很离谱的操作则在于某次 push 后所有的 commit 都有我作为合作者了……另外一个麻烦的地方则在于每次有版本落后，即使没有冲突，使用 VS-git 也会自动创建一个 Merge commit 使得分支受到了一定的污染。 另一方面则是隔壁的某组模仿我们组没有使用 SVN，结果看到他们反复地请正式员工来做 git 的 debug……看到这种场景不由让人领会到自己平时的训练积累的重要性。说到底如果没有有关经验的人在正式项目中这么做的话，不提时间、效率的问题，也难免会让人产生挫败，消磨斗志。 其他的一些思考与牢骚 蓝图这种可读性居然需要通过挪格子和连乱七八糟的线来保证的产品，虽然降低了一点点门槛，但是看得真是让人头大。 不想和不会做变量命名、写出来的东西只有自己能 debug 的人说话。 远离指针…… 通勤时间实属人幸福感的一部分，每天七点过起床赶八点的高新六路，然后忍受堵车，下车找共享单车骑在早高峰的十字路口……这种体验实在是一个月就够了。","categories":[{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Unreal","slug":"Unreal","permalink":"http://example.com/tags/Unreal/"},{"name":"杂录","slug":"杂录","permalink":"http://example.com/tags/%E6%9D%82%E5%BD%95/"}]},{"title":"GAMES101-4：视图和投影变换","slug":"GAMES101/GAMES101-4","date":"2023-03-18T09:14:50.000Z","updated":"2024-01-03T16:55:45.524Z","comments":true,"path":"/GAMES10104.html","permalink":"http://example.com/GAMES10104.html","excerpt":"前言 GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5","text":"前言 GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5 如何拍一张照片：MVP变换 Model Transformation:摆好位置 View Transformation：找好拍照角度 Projection Transformation：拍照。 视图变换：View 思考：任何情况下进行拍照，照片都只和物体相对于相机的坐标有关。 所以建立一个新的坐标系（相机坐标系）规定 相机处于原点； 相机的向上方向是 Y （up at Y）； 相机看向 -Z 方向。 将坐标转换： 平移相机至原点 旋转使向上方向为 Y，旋转使相机看向的方向为 -Z。 求此处旋转矩阵，可以求坐标轴旋转为相机轴的旋转矩阵，然后转置。 投影变换：Projection 两种投影方式： Orthographic Projection：正交投影 Perspective Projection：透视投影 透视投影更接近人眼成像，会有“近大远小”、“平行线相交于一点”等效果。 在如下图所示的模型中，透视事实上就是拍下了锥形视野内的 [n,f] 内的一段区间内的物体，正交则是相机处于无限远处的一个特例。 正交投影 构建相机坐标系 构建一个包含所有物体的空间立方体，描述它为 [l,r]×[b,t]×[f,n][l,r]×[b,t]\\times [f,n][l,r]×[b,t]×[f,n] 的一个立方体（左右下上远近）。是由远及近是由于右手坐标系且看向 -Z 方向导致远处 Z 坐标更小。 将结果规范化在一个 [±1,±1,±1][\\pm1,\\pm1, \\pm1][±1,±1,±1] 的方块内 矩阵形式：中心移至原点，再缩放 Mz=[2r−l00002t−b00002n−f00001]×[100−r+l2010−b+t2001−n+f20001]M_z=\\begin{bmatrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{b+t}{2}\\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Mz​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎥⎤​×⎣⎢⎢⎢⎡​1000​0100​0010​−2r+l​−2b+t​−2n+f​1​⎦⎥⎥⎥⎤​ 透视投影 对如上图的透视，定义近平面 n 和远平面 f，有： 近平面保持不变，其余地方进行“挤压”使得其与近平面一样大。使上图左侧变成右侧形状。 进行正交投影 透视投影的变换矩阵 这里有一个需要注意的地方是，挤压以后，坐标的 Z 轴值“可能”会发生变化。对此我们规定： n 平面上的坐标不变 f 平面上的坐标 Z 轴不变，且平面中点坐标不变 对于任意的点 (x,y,z)(x,y,z)(x,y,z) ，对应到一个 n 平面上的点 (x′,y′,z′)(x&#x27;,y&#x27;,z&#x27;)(x′,y′,z′)。相似三角形有 \\begin{align} y&#039; =\\frac{n}{z}y\\\\ x&#039;=\\frac{n}{z}x \\end{align} 接下来求解 Z 轴的变换方程，即矩阵的第三行。 假设变换矩阵为 M，有： M(x,y,z,1)T=(nzx,nzy,z1,1)T=(nx,ny,z2,z)TM(x,y,z,1)^T=(\\frac{n}{z}x,\\frac{n}{z}y,z_1,1)^T=(nx,ny,z_2,z)^T M(x,y,z,1)T=(zn​x,zn​y,z1​,1)T=(nx,ny,z2​,z)T 其中 z1,z2z_1,z_2z1​,z2​ 未知。 z1z_1z1​ 的值的变换向量是 M 矩阵中的第三行，所以可以只关心第三行。又因为 Z 坐标值显然和 XY 没有关系，所以此行可以写为 (0,0,A,B)(0,0,A,B)(0,0,A,B) 其中 A、B 未知。 n 平面上的点满足变换矩阵且 Z 坐标不变。所以 n 平面上的坐标可以写成 (x,y,n,1)T(x,y,n,1)^T(x,y,n,1)T 。同时乘以坐标 n，代表的点依然不变：(nx,ny,n2,n)T(nx,ny,n^2,n)^T(nx,ny,n2,n)T。 所以有 (0,0,A,B)(x,y,n,1)T=n2(0,0,A,B)(x,y,n,1)^T=n^2(0,0,A,B)(x,y,n,1)T=n2 f 平面同样中点 (0,0,f,1)(0,0,f,1)(0,0,f,1) 满足变换矩阵且 Z 坐标不变。于是 (0,0,A,B)(0,0,f,1)T=f2(0,0,A,B)(0,0,f,1)^T=f^2 (0,0,A,B)(0,0,f,1)T=f2 于是可以联解 \\begin{align} An+B =n^2\\\\ Af+B =f^2 \\end{align} 得 \\begin{align} A = n+f\\\\ B = -nf \\end{align} 所以解出 Z 轴变换方程值， M 矩阵 [n0000n0000n+f−nf0010]\\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -nf \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}⎣⎢⎢⎢⎡​n000​0n00​00n+f1​00−nf0​⎦⎥⎥⎥⎤​ 近平面的表示方法：可视角度 我们通常认定近、远平面的深度（z轴）是已知的，所以现在的问题是如何描述近平面： 指定近平面四个点的坐标 指定宽高比和可视角度。下图为 y 轴可视角度的表示，根据 y 轴可视角度和宽高比可以求出 x 轴的可视角度 两种表示是可以互相转换的，如下： 其中近平面的范围为[±r,±t][\\pm r,\\pm t][±r,±t]，aspect 为宽高比。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-3：变换 Next：GAMES101-5：(三角形的)光栅化","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"}]},{"title":"GAMES101-3：变换","slug":"GAMES101/GAMES101-3","date":"2023-03-10T05:28:27.000Z","updated":"2024-01-03T17:02:51.302Z","comments":true,"path":"/GAMES10103.html","permalink":"http://example.com/GAMES10103.html","excerpt":"前言 GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。","text":"前言 GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。 对图形进行各种变换，可以相当于对其左乘对应矩阵。 基本线性变换 缩放矩阵 [sx00sy]\\begin{bmatrix} s_x &amp; 0\\\\ 0 &amp; s_y \\end{bmatrix}[sx​0​0sy​​] 切变 （Shear） 矩阵: [1a01]\\begin{bmatrix} 1 &amp; a\\\\ 0 &amp; 1 \\end{bmatrix}[10​a1​] 切变的本质就是将矩形变成平行四边形。坐标不变的一条边称之为依赖轴，变换称之为方向轴。下图为一个 y 为依赖轴的例子： 旋转：旋转点通常是原点。[cosθ−sinθsinθcosθ]\\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix}[cosθsinθ​−sinθcosθ​] 对旋转矩阵，其反方向旋转的对应矩阵为其逆矩阵同时也是转置矩阵。 齐次坐标和仿射变换 使用 n+1n+1n+1 维坐标表示 nnn 维坐标。其中，对于点，记为 (x,y,1)T(x,y,1)^T(x,y,1)T，对于向量，记为 (x,y,0)T(x,y,0)^T(x,y,0)T 由于平移，不能写成左乘形式进而与其余变换统一。所以我们引入齐次坐标，使得平移矩阵为 [10tx01ty001]\\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}⎣⎢⎡​100​010​tx​ty​1​⎦⎥⎤​ 思考：为什么向量和点的第三维不一样？ 对于向量，具有平移不变性，我们不希望其左乘平移矩阵得到的结果是新的向量，对于点的想法则相反。因此向量的最后一维应为 0 使得其不受平移矩阵影响。 进一步地，有： 向量 + 向量 = 向量 向量 + 点 = 点 点 - 点 = 向量 点 + 点 = 二者中点 …… 可以发现向量为 0 而点为 1 的情况对于上述现象也可以解释得很好。 仿射变换 定义仿射变换：仿射变换 = 线性变换 + 平移。 使用齐次坐标可以表示仿射变换。齐次坐标等于多个线性变换矩阵、平移变换矩阵左乘后的结果。 M=[abtxcdty001]M=\\begin{bmatrix} a &amp; b &amp; t_x \\\\ c &amp; d &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}M=⎣⎢⎡​ac0​bd0​tx​ty​1​⎦⎥⎤​ 其中 a,b,c,da,b,c,da,b,c,d 表示旋转、缩放、切变，tx,tyt_x,t_ytx​,ty​ 表示平移。 逆矩阵 对于仿射变换矩阵 M，定义逆矩阵： MM−1=EMM^{-1} = E MM−1=E 其中 E 为单位矩阵。 M 的逆矩阵恰好对应原来仿射变换的逆变换。 特别地，对于旋转变换，其逆矩阵和转置矩阵相同，使得求其逆变换变得方便。逆矩阵等于转置矩阵的矩阵被称为正交矩阵。 矩阵不满足交换律，变换也不满足交换律。变换的顺序很重要。 绕任意点的旋转 设任意点为 P，将旋转分解为：把 P 平移回原点、旋转 α 度、平移 P 回 P 点。 于是有变换矩阵： T=T(P)T(α)T(−P)T = T(P)T(\\alpha)T(-P) T=T(P)T(α)T(−P) (注意顺序是由右到左表示的) 三维变换 对于三维变换，可以简单地写出缩放和平移，重点关注旋转。 绕轴旋转 考虑简单的旋转：绕一个轴在一个平面内旋转。 Rx=[10000cos⁡α−sin⁡α00sin⁡αcos⁡α00001]R_x=\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 \\\\ 0 &amp; \\sin\\alpha &amp; \\cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Rx​=⎣⎢⎢⎢⎡​1000​0cosαsinα0​0−sinαcosα0​0001​⎦⎥⎥⎥⎤​ Ry=[cos⁡α0sin⁡α00100−sin⁡α0cos⁡α00001]R_y=\\begin{bmatrix} \\cos\\alpha &amp; 0 &amp; \\sin\\alpha &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin\\alpha &amp; 0 &amp; \\cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Ry​=⎣⎢⎢⎢⎡​cosα0−sinα0​0100​sinα0cosα0​0001​⎦⎥⎥⎥⎤​ Rz=[sin⁡αcos⁡α00cos⁡α−sin⁡α0000000001]R_z=\\begin{bmatrix} \\sin\\alpha &amp; \\cos\\alpha &amp; 0 &amp; 0 \\\\ \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Rz​=⎣⎢⎢⎢⎡​sinαcosα00​cosα−sinα00​0000​0001​⎦⎥⎥⎥⎤​ 请注意 y 轴中 sinαsin\\alphasinα 的正负号与其他情况不同。 这是因为旋转矩阵的循环对称性。即 xyzxyz 的矩阵循环中，一个的值等于前面两个的值相乘。所以对 R_y 有 Rz×Rz=RyR_z \\times R_z = R_yRz​×Rz​=Ry​ 而非相反。 绕任意轴旋转 对于任意角度的过原点轴，可以把它分解为三个轴上的角度（欧拉角）。变成三个轴的变换矩阵的乘积。 对绕任意轴 nnn 旋转 α\\alphaα 角，有 Rodrigues' Rotation Formula 如下： R(n,α)=cos⁡(α)I+(1−cos⁡(α))nnT+sin⁡(α)N\\bold{R}(\\bold{n},\\alpha) = \\cos(\\alpha)\\bold{I}+(1-\\cos(\\alpha))\\bold{n}\\bold{n^T}+\\sin(\\alpha)\\bold{N} R(n,α)=cos(α)I+(1−cos(α))nnT+sin(α)N 其中 N=[0−nznynz0−nx−nynx0]\\bold{N}=\\begin{bmatrix} 0 &amp; -n_z &amp; n_y \\\\ n_z &amp; 0 &amp; -n_x \\\\ -n_y &amp; n_x &amp; 0 \\end{bmatrix} N=⎣⎢⎡​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎦⎥⎤​ 其中，称 N\\bold{N}N 为 n 的反对称矩阵，也就是向量 n 的叉积（n⃗×a⃗\\vec{n}\\times\\bold{\\vec{a}}n×a ）的矩阵形式。 对于任意不过原点的旋转，把其分解为平移原点、旋转、平移回去的过程。 引入四元数是为了更好地对旋转进行插值，关于四元数，另行参考。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-2：回顾线代 Next：GAMES101-4：视图和投影变换","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"基本线性变换","slug":"基本线性变换","permalink":"http://example.com/tags/%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"}]},{"title":"GAMES101-2：回顾线代","slug":"GAMES101/GAMES101-2","date":"2023-03-09T06:53:39.000Z","updated":"2024-01-03T16:55:10.205Z","comments":true,"path":"/GAMES10102.html","permalink":"http://example.com/GAMES10102.html","excerpt":"前言 GAMES101-P2：回顾线代：向量、矩阵。","text":"前言 GAMES101-P2：回顾线代：向量、矩阵。 向量 向量： 向量的定义和性质 模与规一化( normalization )a^ = ∥a⃗ ∥a⃗\\hat a = \\frac{\\Vert \\vec a \\Vert}{\\vec a}a^ = a∥a ∥​ 向量相加：三角形法则 / 平行四边形法则、坐标 向量的矩阵形式 AT=(x,y)A^T=(x,y)AT=(x,y) 点乘 a⃗⋅b⃗=∥a⃗∥∥b⃗∥cosθ\\vec{a}\\cdot \\vec{b}=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert cos\\thetaa⋅b=∥a∥∥b∥cosθ。考虑矩阵形式。 投影、找夹角 两个向量方向接近的程度，是否基本同一个方向 叉乘 a×b=−b×a=∥a⃗∥∥b⃗∥sinθa\\times b=-b\\times a=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert sin\\thetaa×b=−b×a=∥a∥∥b∥sinθ 右手定则与右手坐标系。叉乘确定一个平面。不满足结合律。 判断向量的左右关系 判断点与三角形的内外关系：对每条边都在同一侧 矩阵 矩阵 基本运算：乘积 没有交换律。AB≠BAAB\\neq BAAB=BA 转置 TTT (AB)T=B−1A−1(AB)^T=B^{-1}A^{-1}(AB)T=B−1A−1 单位矩阵 III A−1A=IA^{-1}A=IA−1A=I 齐次坐标 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-1：课程总览与笔记导航 Next：GAMES101-3：变换","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"VSCode 的设置系统的粗浅理解","slug":"VScode的设置系统","date":"2022-11-21T05:20:25.000Z","updated":"2023-09-15T14:09:39.099Z","comments":true,"path":"post/20221121132025.html","permalink":"http://example.com/post/20221121132025.html","excerpt":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却……","text":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却…… 我需要一个默认的编译设置 众所周知，VSCode 的推荐或者说设计使用方法是对不同代码建立不同的工作区。这确实是对不同项目、不同语言的代码进行管理的优良方法。但是在学习的过程之中，不是所有情况都是非常理想的“我可以将所有的代码都井井有条的打在一个文件夹（工作区）中”的。学习中，QQ 上接收测试别人的代码、想临时测试某个功能是否如记忆一样等等情况，这样的代码，具有临时性或者独立性，我不希望将其和我固有的代码文件混淆在一起，又不希望记一个层层目录之下的草稿工作区分门别类。因此最理想的情况就是能在不打开特定工作区或文件夹的情况下对单个文件进行编译和调试。也就是一个全局的，或者说更通用的设置。 之前种种原因，对 VSCode 的设置理解停留在了一种一知半解的程度，借此机会，我希望能对此加深理解。 VSCode 中的设置的基本结构 优先级和工作区、文件夹 VSCode 的设置结构优先级由低到高是 “默认设置（不能更改）→ 用户设置 → 工作区设置 → 文件夹设置”。VSCode 会优先使用优先级高的设置，如果没有，就用优先级次高的设置。 知道写到这里我才注意到的一个事实是工作区（workspace）和文件夹（folder）是不一样的存在。我们可以认为一个“文件夹”是一个项目，一个工作区则是同类项目的集合点。例如所有的 Python 项目为一个工作区，而对其中的任意一个项目设置为单独的一个文件夹。Python 项目的共通性设置放于“工作区设置”中，而项目如果有特殊设置则放在“文件夹设置”里。 需要注意的是，如果只有一个文件夹，那么这个文件夹本身就是一个工作区。VSCode 会把这个文件夹设置显示为工作区设置，这也是为什么我会一开始没有发现这俩是不同概念的原因。 下面是工作区和文件夹在 VSCode 资源管理侧栏界面的对比，工作区会额外注明工作区二字。 设置文件的存储格式 所有这些设置，都是以 JSON 文件存储在电脑上的文件中的（尽管工作区文件不以.JSON结尾）。JSON（JavaScript Object Notation） 是一种独立于 语言的轻量级数据交换格式，采用键和值的格式存储数据。 而VSCode 的每一项设置都是一对键和值。 其中，用户设置位于 VSCode 的数据目录下( C 盘 appData 文件夹下)；工作区设置会是一个名为&#123;名字.code-workspace的文件（此文件不一定位于工作区文件夹内）；如果是文件夹，则会存储于文件夹下自动生成的.vscode文件夹下。 插件的设置 使用 VSCode 的时候，我们还会添加许多的插件，例如本文的初衷：在非工作区 / 文件夹环境下编译 C/C++ 程序就需要 MS 官方的 C/C++ 插件。这些插件的设置也会被写入到 Uersettings 文件中。因此，所有的插件和软件设置都是对同一个文件的内容的修改。既然目的是更改默认的编译软件，那么我们就是需要修改 Usersettings 文件即可.事情到这一步似乎离解决已经不远了。可是真的是这样吗？ 结论 在设置中，我们找到了下面两个设置。第一个的设置具体还不是很懂，第二个则没有发挥作用（图中值为自己填的）。 所以很遗憾，事情没有以完美解决落幕。依然要选择编译和调试器如图： 不过，至少我搞清楚了为什么这里会有三个选项，在官方文档中提到， The compilerPath search order is: First check for the Microsoft Visual C++ compiler Then look for g++ on Windows Subsystem for Linux (WSL) Then g++ for Mingw-w64. 因此，VSCode 会扫描到 mingw-w64 中的 cpp 和 g++ 两个程序，以及 VS 中带有的的 cl ，因此 VSCode 会有不知道用什么的疑问。但是 cl 被限制为只能在 VS 中使用，这也就导致了此选项实际上不能正常运行。目前的解决办法还得是选一遍，然后 VSCode 会在这一窗口中记住你的选择。 这一选项的原因可能是 VSCode 中的并没有选项能存储此默认设置，它会优先去寻找 launch.json,找不到时，则会发出此疑问。 还没有理解的问题 Q：既然 JSON 文件支持注释，那 JSON 和 JSONC（JSON with comments）有什么区别，为什么要创造 JSONC？VS Code 采用的是 JSON 还是 JSON with comments？","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"如何管理我的文章、笔记","slug":"如何管理我的文章、笔记","date":"2022-11-15T14:58:57.000Z","updated":"2023-06-09T01:22:46.380Z","comments":true,"path":"post/20221115225857.html","permalink":"http://example.com/post/20221115225857.html","excerpt":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。","text":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。 0.我的笔记环境 各类记笔记的软件繁多冗杂、不一而足，由上述两段可见一斑。而在经过两年多的跌打过后，我目前得出的教训是：有的就是好的，没有的就坏的。手上的工具再差，其已经配好了这一特点就胜出许多，因为这一点意味着当拥有想法的时候，你不会工具没有配好没发写而难受。 因此，做事的正确的顺序应该是先写起来，先用起来，习惯起来然后再酌情学习更换。否则就是配这个，踩一遍坑、配那个，踩一遍坑……到头来时间耽误不少，工具用了挺多，产出是一个没有，精通的也一个都没有……或者哪怕找到了趁手的武器，写文章的心境也早没了，只能任由心绪烂在心里。 下面简要介绍我的情况： 我是计算机类大学生，存在记笔记的需要，偶有写文章的冲动，但是依据过去进行判断的话，没有做日记或笔耕不辍的习惯。习惯于使用Markdown。 我目前使用的记录软件包括：小米笔记、Notion、VSC+MPE（就是这个博客）、Goodnotes、Notbility、Obsidian、备忘录（苹果）。 其他有所耳闻的应用还有各类在线博客平台（如CSDN、知乎专栏、掘金）、logseq、OneNote、typora等。 下面依次对我使用的工具的职责和功能进行介绍和明晰。 1.小米笔记：便捷的文字集散地 小米笔记用于我的 MIUI 手机上。其实功能不少，界面也很美观。既可以添加待办，也可以很方便的写一些短文字，还有思维笔记的功能。格式相似于 Markdown ，主要是荧光笔、触屏涂鸦和中/左对齐等功能，不过不支持 Markdown 语法。 显然这个就是主打轻量化的软件。由于手机一般就在身边，因此想到什么就马上开记，不要了就删掉是其最大的好处。 此外，小米笔记还有摘录功能，即复制后在侧滑功能栏里可以直接添加到笔记。或者也可以先侧滑打开摘录功能，然后接下来复制的多段文字均会在结束的时候被添加到同一个笔记中。 目前我对他的定位是做一个简单的快速记录软件、日记软件。将其分为了“垃圾话”、“灵感”和未分类三个部分。 “垃圾话”存储的是一些突然涌现的思绪，例如突然涌上心头的后悔、思念、思考、感悟……“灵感”则存一些更有价值的创造，比如说现在里面有的一篇小故事。我深知我无法将其扩写成一篇完美而精致的小说。但是我依然可以在小米笔记里把梗概存下来。至于未分类则就更是乱七八糟了，临时记录的东西。例如预备购买的手机的优缺点、给别人发一大段话前组织语言……这是笔记的默认分类。 至于隐私空间，则是一个简单的生活秘密空间。例如某个密码锁的密码，可以存在这里以防万一。从而使得应用本身并不需要上锁。 2.Notion：基于云端的长文字集散地 Notion 的好处很多，不过展开了说就有些长了，再说了我也没有完全摸透，大体上看是可以简单担任日历、待办、笔记、备忘录等等功能……（我甚至在拿它记账！）。总的来说，Notion 是极富有野心也极强大的的网络云笔记平台。支持类 Markdown 语法、按段落拖动等都是他的的优势。尽管如此，它也不是十全十美的。 其基于云端本身就意味着访问不稳定和隐私风险的等问题的存在。而且在国内特定的网络环境下，直接后果就是你需要开启代理，否则从一开始就不能登录，即使登录了，丢字、光标移动不稳定等问题依然会不时的困扰着人，这也是我尝试 Obsidian 和转移到 iPad 的原因之一。（另一原因是手写笔记的排版自由）。 尽管如此，一些具有多端阅读需求和多端编辑需求的文章还是可以放在 Notion 上。例如读书笔记或者单纯的笔记之类的。我曾经使用 Notion 作为课堂笔记过相当长一段时间。 3.Obsidian：移动端的 Markdown 基于移动端的 Markdown 写作平台，很可惜的是需要付费才能解锁多端同步的问题。因此，Obsidian 主要是作为小米笔记的 MarkDown 补全品出现。（文本迁移到 Notion 有格式转化的一大堆问题，不能作为 Notion 的补全品。但是可以作为 Notion 的替代品。具体来说就是一个小说的写作地。 4.Leeka的酒馆（VS Code）：成熟文章的集合 通过VS Code + MPE，可以进行较长篇幅的文章写作。同时，虽然没有人看，但是公开网站的性质也使得这里不适合放一些强隐私性的东西。这里主要堆积的是完成度高、成体系、长的文章。通过 Markdown 进行编辑可以使得我专注于内容本身。至于缺点则是虽然发布内容可以全平台浏览，但只能在电脑上进行编辑，而且会想折腾各种写作环境。目前来说，新建文章的方式也不够优雅。 5.Goodnotes &amp; Notebility：上课笔记、下课草稿（iPad） 目前的分工是 Goodnotes 记录课堂笔记，Notebility 负责一些更不正式、预备稿、涂鸦、灵感一类的东西。这里的一大原因是 Notebility采取了昂贵的订阅制，虽然可以白嫖朋友的 classic 版，但是说到底还是不适合与之深度绑定。 Goodnotes 等的缺点在于，除非导出为 PDF，否则不能在 iPad 以外的设备上进行查看，而且本身是手写用的。 6.备忘录（iPad） 备忘录的优势在于双击启动，虽然写起来不如 G 或者 N 爽，但是用来写一些用后即焚的东西（例如打草稿）还是有一定优势的。","categories":[{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"}],"tags":[{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Take You Down ---至少不能让你受我连累","slug":"TakeYouDown","date":"2022-04-17T06:52:25.000Z","updated":"2023-09-15T08:28:26.764Z","comments":true,"path":"post/20220417145225.html","permalink":"http://example.com/post/20220417145225.html","excerpt":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？","text":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？ 背景故事 《Take You Down》是收录于 ILLENIUM 的第三张录音室专辑《ASCEND》的一首歌。在《Take You Down》作为《Ascend》的先行曲发布时， Nick 在 YouTube 的介绍页写下了长长的一段话，告诉了粉丝自己过去和毒瘾战斗的艰辛过往，并感谢这一过程中音乐、母亲和其他爱他的人给他的激励。 如今，31岁的 Illenium 是全球最有名的 DJ 和电子音乐制作人之一，《ASCEND》曾登上得 Billboard 电子舞曲专辑的第一名的位置，而凭借第四专《Fallen Embers》，他赢得了一项格莱美音乐提名。而他则和家人、女朋友、朋友生活在美国丹佛。 以下是他在 Youtube 上写下的感悟： Yo Fam, I've been wanting to share something super personal for a while and just wasn't exactly sure how to do it. I'm at the point now where I've heard countless stories from you. Some of you have said my music changed your life, helped you through depression, addiction, a lost loved one, the list goes on. Honestly, I feel bad because you don't know how much that truly means to me, because I've been there too... In the depths. Six years ago I overdosed on heroin. I struggled with opiate addiction from a young age. I was trapped in it, had no passion, no direction, and truly hated myself. It was such a dark time for me and my family because when it gets bad enough, hope begins to dim and there's no escaping reality. I'm not telling you to preach or say how I found some magical cure or that everyone needs to live like I do. I'm the biggest advocate for people living their own lives and spreading their own love in their own ways. I'm just sharing my story and relating because music saved my life too. With everything that has been going on with my career, I always keep reminding myself of that. My main goal with music is to try and help people overcome their struggles and also enjoy the moment. With all that said , 'Take You Down' is about my struggles with addiction and what it can do to families and loved ones. It's more specifically about my mom, and how no matter what, she never gave up on me and always continued to see the good even though all I was doing was messing up. To anyone struggling like I did, not just with addiction but anything in life, I hope you guys can find peace in your struggles and know that anything can be overcome. I've been clean since that overdose and I owe that to finding my passion and being surrounded by the most loving people I could ever ask for. Thank you for always listening and being open. Thank you for sharing your own stories and your love of music with me. Love you all forever : ) 翻译 嗨，朋友们： 我一直想和你们分享一下一些完全私人的情感，但是却不知道该如何开口。眼下，我已从你们那儿听到了许许多多的故事。有的人告诉我，我的音乐改变了他的生活，帮助他渡过了诸如抑郁、药物成瘾、失恋……种种人生坎坷。老实说，我的感觉并不好，因为你们根本不知道这对我意味着什么：我也曾生活在那种糟糕境况中……深陷其中。 六年前，我遭遇吸食海洛因过量的事。我还很年轻的时候就和阿片药物成瘾对抗着。我踩进了毒品的圈套，生活没有热情、没有方向、自我厌恶。这对我和我的家庭都是一段非常黑暗的岁月，因为成瘾太深以后，就很难再回避事实了：戒毒的希望已经很渺茫。我不是要给你们讲大道理或者要说我找到了什么神奇的戒毒方法，又或者是要大谈什么你们都应该像我一样生活。我完全赞成每个人应该有自己生活和表达爱的方式。我只是想和你们分享一下我的相关遭遇，因为音乐也拯救了我的生命。当我的职业生涯日益发展，我也总是不断提醒着自己这一点。我做音乐的主要目标就是试着帮助人们克服遇到的困难，并享受当下。 总而言之，‘Take You Down’讲的是我和毒瘾的抗争以及这种抗争对我的家人和所爱的人的影响。尤其是我的母亲，无论发生了什么，她从未对我失去信心，总是以积极的一面看我——尽管我干的事就是把一切都搞砸了。对于那些像过去的我一样反抗着什么的人——不仅仅毒瘾，也包括人生中的其他种种问题——我希望你们能在反抗的过程中寻得心灵的栖身之所，而且能相信没有什么困难是克服不了的。自从那次吸毒过量以后，我再也没有碰过毒品。我也明白我得找回生命的激情并和那些我能寻求到的最有爱的人呆在一起。谢谢你们一直以来对我和我的音乐的支持。欢迎和我分享你的故事以及你对音乐的爱。永远爱你们 : ) 歌词翻译 I didn't mean to hurt you when I hurt myself 当我伤害自己，我无意连你一起伤害 It's just an empty voice screaming out for help 空洞又凄厉的哀叫只是 为寻求帮助 No, I didn't mean to scare you 不，我不曾想让你失措 But I couldn't see 但我不明了： That when I went to hell I was taking you with me 当我迈向深渊，我也在将你推入其中 When I close my eyes 而当我闭上眼… I'm climbing in the dark 就仿佛正在黑暗中攀登 Trying not to fall apart 竭力只求不要跌落 Sometimes I get so high 看到脚下的万丈深渊 Falling is the only out I see 坠落好似我唯一的出路 And I don't wanna take you down with me 而我不愿牵连你一同坠落 You're the love in my heart 只因我真心地爱你 Only love in my heart 你是我最爱的人 Take you down 坠下崖…… Take you down with me 与我一同坠崖 Don't wanna take you down 绝不愿你与我一同 Take you down 落入深渊 Take you down with me 落入痛苦的无底深渊 #Drop# This life is like a razor 这样的生活就如一把利刃 When it cuts, I bleed 令我伤痕累累 But it's in my hand 但这是我的抉择 And I'm doing it to me 是我在不断地伤害自己 Sometimes it's like an ocean 有时它又如一片幽邃的深渊 And it gets too deep 而我深没其中 And there's no way that now you could rescue me 如今你已没有办法拯救我 When I close my eyes 而当我闭上眼 I'm fighting in the dark 就仿佛正在黑暗中搏斗 Trying not to break your heart 竭力不要让你伤心 Sometimes I get so high 有时在我恍登极乐 Falling is the only out I see 堕落是我唯一可见的未来 And I don't wanna take you down with me 而我不愿你与我一同堕落 You need to let it go now 如今你该放下这一切 Before you drown 趁你尚未被牵连太深 I know that you won't understand 我知道你不会理解这些 But you need to let go of these hands 但啥时候放开拉着我的双手了 'Cause I'm going down 因为我无药可救 And I don't wanna take you down with me 可我不想牵连你一同饱受痛苦 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) #drop# And I don't wanna take you down with me 可我不愿牵连你一同跌入深渊 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) Take you down, down with me 怎愿致你痛苦，和我一样痛苦","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"}]},{"title":"用批处理简化hexo命令操作","slug":"用批处理简化hexo命令操作","date":"2022-03-23T16:19:24.000Z","updated":"2024-01-04T08:28:46.901Z","comments":true,"path":"post/20220324001924.html","permalink":"http://example.com/post/20220324001924.html","excerpt":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？","text":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？ 背景 搭建好博客网站后，之所以长时间没有更新，当然是因为本人懒狗，不过除此之外，hexo 糟糕的新建博文方法也是一大原因。 有两种方法可以新建一篇博文： 在博客的本地地址建立一个新的 Markdown 文件，然后依次修改它的各部分内容。 在博客的本地地址右键选择 git bash，然后输入命令进行操作。 第一个简单，但是糟糕的地方是头部信并不是自动生成的，需要从老博文里面复制。麻烦不说，时间戳不是自动生成的、混用 _drafts 和_posts 也总让我感觉有些难受。 第二个能自动生成头部信息，但是需要输入命令然后再关掉窗口打开编辑器，实际上也很麻烦。 但是，既然每次输入的命令都是类似的，这就自然让人想到能不能用例如 bat 批处理脚本来自动化这个过程。 答案是可以的， bat 脚本事实上就是一连串的命令。在 bat 文件中写 hexo help 和 新建一个 cmd 黑窗口输入 hexo help 没有任何差别。 使用批处理以后，可以从重复而繁琐的命令中解放时间，更好的专注于写作本身、也可以让草稿和博文真正的很清楚（而我还没有搞清楚hexo的开发者的初始设想到底是如何使用？想必不是让用户自己写批处理XD) 下面是脚本代码 实现 新建博文草稿并用编辑器打开 newDraft.bat 12345678@echo off@REM 跳转到博客地址D:cd D:\\***\\***@REM 输入文件名set /p name= input Name: @REM 新建文件、唤起第二个脚本hexo new draft %name% &amp;&amp; call openEditor.bat %name% openEditor.bat 1234echo the input is %1set name=%1echo %name%start /d &quot;C:\\***\\***\\VSCode的安装地址\\&quot; Code.exe &quot;D:\\博客的本地地址\\source\\_drafts\\%name%.md&quot; 这里，第一个脚本建立草稿文件，并唤起第二个脚本用编辑器（这里是VS Code）打开新建的 Markdown 文件。为什么不能写成一个文件这里我还不是非常清楚，似乎bat文件会在运行到 hexo ***后自动结束导致后面的命令运行不了。 发布（Publish）文章 publish.bat 123@echo offset /p publishBlog=hexo publish %publishBlog% 此脚本将指定名字的 blog 发布到 _post 文件夹中。 上传到博客网站 deploy.bat 1234start clean.batstart /min /w mshta vbscript:setTimeout(&quot;window.close()&quot;,2000)start generateAndDeploy.batexit 分别调用clean和generateAndDeploy，清理缓存、生成并部署。 clean.bat 123@echo offhexo cleanexit generateAndDeploy.bat 12hexo g -dexit 总结 有效激发了本人的写作热情，写好脚本以后当场写（水）了这篇博文。 算是对 bat 有了一点粗浅的认识，当然还有搞不懂的地方，例如为什么运行到hexo ***以后就退出了呢？还是需要以后再看，今天鉴于时间因素，还是就此暂停了。 自己用命令测试的时候请记住要用 CMD 运行！powershell的话你大概会遇到因为在此系统上禁止运行脚本的错误,这里是可能的参考解决方法。 这篇文章是向CSDN上“蓝蓝223”的这篇文章:《bat批处理脚本自动部署Hexo博客》学习后的成果。我对代码进行了一点无关痛痒的小改动。 代码块在MPE上预览要敲 batch 才有高亮，但是要生成的网页有中有高亮得敲 dos…… 我不理解orz","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"批处理脚本","slug":"批处理脚本","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Heavenly Side ---我愿与你逃向天国","slug":"歌词翻译/Heavenly Side个人翻译","date":"2022-02-14T15:59:59.000Z","updated":"2023-07-11T00:41:37.974Z","comments":true,"path":"post/20220214235959.html","permalink":"http://example.com/post/20220214235959.html","excerpt":"前言 Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。","text":"前言 Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。虽然之前吐槽水啊水之类的，但是没想到这首歌比feat Nurko的Sideways让我上头多了。虽然网易云音乐的翻译也未必没有可取之处，但是个人感觉还是略显谜语人和机翻，在“没有人比我更懂歌词内涵”的思想下，写了这个翻译。由于写的时候考虑到能否唱出来而硬拗了一些词，不足之处欢迎指正。 翻译 《Heavenly Side》 -ILLENIUM -《Fallen Embers》 I've got an anger problem 我总是喜怒无常 I've got a selfish need 还变得自私自利 I like to burn my focus 我在琐事中忙碌 Just to watch my true colors bleed 只为将真我遗弃 I've got a taste for failure 我已饱尝失败的滋味 I find it in everything 生活中处处碰壁 But I hear the voice inside you 但我却听到你内心的声音 Say I could be more than need 告诉我存在的意义 You can't let go if you want to 若愿意你可永不放手 'Cause I love you all the same 只因我的爱永不改变 It's a long way down from here（Oh, Oh, Oh, Oh ） 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我美好的一面随时为你展现 And I killed myself last year(Oh, oh, oh, oh) 与过去的我一刀两断 My heavenly side is comin' alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我温柔的一面随时为你展现 If you want me 只要你愿意 I know that I'm the problem 我知道我就是麻烦所在 I know that I'm to blame 我知道我应该饱受谴责 But I hear the heart inside you 但我也听到你内心的声音 And it's calling out my name 正呼唤着我的名字 You can't let go if you want to 若愿意你可永不放手 'Cause I love you all the same 因为我的爱永不改变 It's a long way down from here 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me 若你愿意我美好的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin' alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意 It's a long way down from here 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me 只要你愿意我天使的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin' alive if you want me 只要你愿意我恶魔的一面将会永埋心中 Don't you let go 不要放手 I found my soul 是你将我挽救 Don't you let go 不要放手 I found my soul 灵魂怎可弄丢 My heavenly side is comin' alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"天国王朝语摘","slug":"天国王朝","date":"2022-01-15T06:13:35.000Z","updated":"2024-01-04T08:26:31.416Z","comments":true,"path":"post/20220115141335.html","permalink":"http://example.com/post/20220115141335.html","excerpt":"天国王朝语摘，自翻与所看版本的翻译","text":"天国王朝语摘，自翻与所看版本的翻译 What man is a man who does not make the world better ? trans：大丈夫生于世当造福苍生 Be without fear in the face of your enemies; Be brave and upright that God may love thee; Speak the truth always, even if it leads to your death; Safeguard the helpless and no wrong; that is your oath. trans（LEEKA）： 临敌不惧 神佑勇义 护良扶弱 纵死不诳 这就是你的册封誓言 trans： 强敌当前 无畏不惧 果敢忠义 无愧上帝 耿直正言 宁死不诳 保护弱者 无怪天理 这是你的誓词","categories":[{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98/"},{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"VSCode 中自定义代码模板（snippet）","slug":"VS code中建立代码模板","date":"2022-01-05T14:01:55.000Z","updated":"2024-01-03T14:37:44.211Z","comments":true,"path":"post/20220105220155.html","permalink":"http://example.com/post/20220105220155.html","excerpt":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。","text":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。 具体操作倒也不难，如下： 1.打开VS code，选择文件 =&gt; 首选项 =&gt; 用户片段 =&gt;选择对应的语言 在弹出的以下窗口中选择对应的语言、文件夹或全局，则，仅会在该语言环境、该文件夹抑或全局触发补全该代码片段。此处我以C++为例了。 2.输入代码 在弹出的窗口中，你能看到已经有数行注释如下 12345678910111213// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected.// Example:// &quot;Print to console&quot;: &#123;// &quot;prefix&quot;: &quot;log&quot;,// &quot;body&quot;: [// &quot;console.log(&#x27;$1&#x27;);&quot;,// &quot;$2&quot;// ],// &quot;description&quot;: &quot;Log output to console&quot;// &#125; 事实上这段英语教程已经说得比较清楚，但是作为英语苦手，还是有一定的理解苦难，这就是这篇博文诞生的原因。下做翻译补充： 每一个“代码片段”都应该由如下三部分构成，前缀（prefix）、主干和描述。 前缀是代码片段的触发器，当你在编辑代码时输入前缀（的部分），VS code 就会联想到你的对应代码片段； 主干是被补全的内容，也就是“模板”部分。你应该把代码分行写在 body 的中括号内，并把它们用双引号包括起来，同时在引号外别忘了添加逗号。即 1&quot;your code here;&quot;, 描述被用来描述代码片段的作用，当你有多个相近名字的代码片段时，这无疑有助于你区分它们。此外，这部分也允许你输入中文，或干脆不写（尽管不建议）。 需要额外注意的是最后提到的由 $ 开头的这个小功能。 它的写法是 $加一个数字或在 $ 后的大括号内依次写入”数字”“冒号”和“占位字符串”。如 123$0$&#123;1&#125;$&#123;1:spaceholder&#125; 在补全代码后，你的光标会首先停在数值最小的一个 $ 字符处，随后每次按 Tab 依次停在次小的 $ 处，最后停在代码片段的末尾或你指定的 $0 处。（尽管测试下来允许数字不连贯，但是我建议还是使用连贯的从1开始的数字比较好）。如果有多个相同数字的地方，那么光标会同时存在于这些地方。 在上方 spaceholder 部分，你可以填入默认的代码，它们在会光标（按 Tab 转移到此处时被选中以备替换）。 3. 实例 接下啦，仿照给出的 Example 在下方输入你的代码即可。 123456789101112131415161718192021222324252627&#123;//这个括号是默认生成的 &quot;Print to sample&quot;://sample字段可被替换，还没找到其意义 &#123; &quot;prefix&quot;: &quot;test&quot;,//触发词 &quot;body&quot;: [ &quot;#include &lt;iostream&gt;&quot;, &quot;#include &lt;cstdio&gt;&quot;, &quot;&quot;,//这是一个空行 &quot;using namespace std;&quot;, &quot;int $&#123;1:i&#125;;&quot;, &quot;$0&quot;, &quot;&quot;, &quot;int main()&quot;, &quot;&#123;&quot;, &quot; scanf(\\&quot;%d\\&quot;, &amp;$1);&quot;,//在上方写了占位符后，这里可以只写一个数字 &quot; return 0;&quot;, &quot;&#125;&quot;, ], &quot;description&quot;: &quot;一般性简单cpp模板&quot; &#125;,//逗号在有多个片段的时候有意义 &quot;Print to another_sample&quot;: &#123; ... &#125;&#125; @import &quot;D:\\Users\\uftx\\Documents\\hexo\\source_posts\\avatar.jpg&quot;","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"中国游戏产业现状————思政课堂演讲稿","slug":"中国游戏产业反思","date":"2021-10-26T09:40:33.000Z","updated":"2023-06-09T01:22:46.377Z","comments":true,"path":"post/20211026174033.html","permalink":"http://example.com/post/20211026174033.html","excerpt":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿","text":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿 谈谈中国游戏产业的监管和未来 中国的电子游戏产业是怎样的？ 中国的电子游戏产业为什么是这样的？ 中国的电子游戏产业在往哪个方向发展？ 我们如何看待它？我们能明白什么？我们如何改进它？ 注意： 如无特殊说明，主流游戏指代的是当今世界上的主流游戏形式，即以主机为、PC为主要发行渠道的各类大型电子游戏。 如无特别说明，游戏指的是在主机，PC，掌机，手机等各类平台运行的电子游戏。 中国的电子游戏产业是怎样的？ 中国游戏产业发达 我们有丰富的证据说明中国游戏市场的发达： 中国目前已经成为世界上最大的游戏市场，游戏用户高达6.6亿，实际销售收入两千七百多亿。是世界第一大游戏市场，有超过1/4的游戏用户都在中国。 中国腾讯是世界第二赚钱的游戏公司（2020），王者荣耀、英雄联盟、穿越火线、刺激战场都是堪称全民级游戏。 中国是电竞大国，数度在英雄联盟、DOTA2等领域捧回冠军。例如2018年，现象级的IG夺冠事件（英雄联盟S10），又如，已经成功举办9九届的Dota 2Ti赛事中，中国除2013年 Ti 3外，始终占据前三之一，在2012、2014、2016年更是夺得世界冠军。 中国游戏产业艺术属性、文化属性缺失 但是，中国游戏业的发达之下，掩盖的问题是，中国游戏缺乏艺术性，难以做出让中国人叫号的游戏；缺乏文化属性，难以做到对外输出中国影响。 自从《征途》之后，国内主流的游戏类型成了基于电脑的网络游戏，而大约十年前，国内主流又变成了手机游戏。以至于有些不太关心游戏的人甚至觉得现在没人玩电脑游戏了。 这并不是说网络游戏、手机游戏低人一等，相反，从商业的角度来说，它们是更先进、更发达的形式。但是我们也需要指出，只点“网络游戏”、“移动游戏”的科技树的后果是，国产游戏并没有完全发挥游戏作为文娱产品其艺术一面的功效。 这是因为，从本质上来是，单机游戏和网络游戏是两个不一样的东西。前者卖的是产品，后者卖的是服务。单机游戏作为产品，它在内容体验上是完整的、大致固定的。而网络游戏作为服务，为了让用户持续的玩下去，体验是不完整的、持续时间是不定的。而且，这意味着，如果我们想用游戏来阐述一个富有魅力、打动玩家的故事较为困难。 而且，由于网游是提供服务，吸引玩家充钱，而不是做出好玩的游戏然后吸引玩家交钱。因此网游的重心必然是在吸引充钱上，这也无形中降低了对剧情等内容的重视程度。 尽管有王者荣耀里有对历史原型人物的科普等相对正面的例子，但是整体上我们的游戏业并没有把弘扬中国文化这一块做好。例如，许多外国人对中国三国文化的认识来自于日本的《三国志》等游戏，对内，反映我国群众思想、喜好、生活的游戏也并不多见。 中国游戏长期与社会割裂 由于中国长期以来以PC和移动端为主的网络游戏占市场主流，加上社会对电子游戏存在的较大偏见，导致了社会认知中的游戏和实际上的游戏业是割裂的，带偏见的。 例如，许多人觉得现在没有什么电脑游戏了。 有的人觉得，玩游戏还要买简直不可理喻。 有人觉得游戏就是“电子鸦片”、洪水猛兽。 针对近期新闻出版署公布的未成年防沉迷规定，玩家们就改出了许多不同的梗图以作对“家长”们的嘲讽【此处应有图】 种种和实情相去甚远的偏见不仅使得游戏业的发展受到来自社会舆论方面的较大阻力，也使得监管层迫于舆论压力对行业动手。 中国的电子游戏市场为什么是这样的？ 这个问题可以谈很长， 我们可以批评中国不像美日有深厚的桌游史，因此没有继承游戏文化，才导致畸形发展。 可以批评是血狮为代表的发行商们寒了中国玩家的心，让投资者和玩家都不愿意购买中国单机游戏， 可以批评是以史玉柱的征途为代表的一系列强氪金网游压死了中国游戏商。 可以批评中国家长，他们总是“以孩子玩了怎么办”阻碍中国游戏脱离幼稚的主题和画风。 但是，我们认为中国游戏监管是中国游戏业成为当今形态的主要原因。（请注意，这并不是说监管是唯一原因，也不是说监管方是一切问题的根源） 下面，由三个重要政策的颁布浅窥监管对游戏业的影响。 游戏机禁令： 70年代，雅达利制造出世界上最早的游戏机，电子游戏产业逐渐萌芽。90年代，乘着改革开放的东风，游戏机和游戏文化传入了中国。由于当时政府管制不到位，大量企业依靠山寨外国游戏机（小霸王），盗版或仿制外国游戏起家。在对企业监管都不到位的环境里，对个人的监管就更不可能到位了。在当时，黑网吧、黑街机厅等遍地。不可否认的是，在这类场所，人员往来成分混杂，争吵斗殴不时发生。 2000年，光明日报两度刊文分别以《别让游戏机害了一代人—一位母亲的呼吁》和《观点：电脑游戏是瞄准孩子的“电子海洛因”》批评（黑）游戏机（厅）。文章认为，游戏机是毒害青少年的”电子海洛因“，不仅容易上瘾，而且会诱导逃学、夜不归宿、甚至抢劫等不良行为。这引起了孩子被游戏厅毒害的父母的共鸣，社会上引起轩然大波。六月，国家七部门联合发布《关于开展电子游戏经营场所专项治理的意见》（俗称游戏机禁令）。尽管该意见的对象是街机游戏机（而不是家用机），但是在具体的实行过程中，最终演变成了所有游戏机。 家用机（俗称游戏主机）在中国正规市场的消失，无疑是造成了主机游戏在中国的绝迹的直接原因。而世界的主流游戏形式依然是主机平台为主的。换言之，中国的玩家从此很难玩到大部分国外优质游戏，中国游戏开发商也几乎不会进行主机游戏开发。 这就导致了中国转向以PC和手机等非完全游戏设备上的游戏开发（由于有非游戏需求，不能被禁止）。而PC平台的开放性引发的盗版传播潮，又使得中国的游戏形式转为是以免费内购制联网游戏为主。 这一转向，使得付费单机游戏被中国彻底抛弃。中国单机游戏市场萎靡不振，与百花齐放的国外游戏市场形成鲜明对比。 如今，电子竞技在国内引发热议，不仅受众甚多，国际赛绩不俗，而且电竞专业、电竞酒店、电竞馆、电竞电视剧各类衍生品也层出不穷。某种程度上，也正是游戏机禁令的衍生物。 游戏版号制度 2004年，文化部建立网络游戏内容审查制度，在新华网的一篇采访中提到，审查的目的因为 一是网络游戏产品中存在色情、暴力、赌博、愚昧、迷信以及危害国家安全等不健康内容； 二是未经内容审查的境外网络游戏产品充斥我国网络游戏市场，市场绝大部分为境外产品，大约占８０％以上； 三是容易影响缺乏自制力的未成年人的身心健康，有的深陷其中、不能自拔并诱发一系列社会问题。 而违规内容简单的概括，有：反国辱国、违背社会公德、邪教、谣言、宣扬色情赌博暴力等。 这些规定有问题吗？似乎没有。但是，版号下发数量稀少，具体过审规则暧昧，尤其是在前几年下发还不是依据申报前后、不分企业大小排队的情况下。版号制度事实上极大的打击了中国中小游戏开发商。他们很难拿到版号，即使拿到版号，为了过审，也不得不大量删改内容。 这一制度，给有心做出中国好游戏的中小型开发商又套上一层枷锁，磨灭了独立游戏在国内存在的土壤，加剧了市场中马太效应的作用。 同时，由于文化讨论更容易触犯规则，一个版号吃多年的网络游戏比几年一换的单机游戏申报成本更低，游戏商们也更不愿意做剧情、做价值输出内容。更不凸显网络游戏作为文化产品，其文化和艺术性一面的作用。游戏们变得剧情上乏味而空洞。 最糟糕的是，缺乏正规渠道接触优秀电子游戏使得孩子们认识游戏的渠道极容易出问题——而这又恰恰很有可能导致孩子成绩下滑暴力等问题，因为一些国外认定18+甚至的血腥暴力以及色情游戏可以在国内轻易获取。 最近的精神鸦片事件 在2017年PUBG的大热，曾经以CS而为人熟知的Steam平台再次进入大众眼线。 Steam是美国Valve公司开发的游戏平台，由于并非中国企业，在Steam上架游戏并没有版号要求，因此在意识到steam上有广阔的国内和国际市场后，许多独立游戏开发者开始将尝试把自己的游戏上架Steam。于是，我们惊奇地发现，中国游戏产业并非烂泥扶不上墙，并不是没有做出好游戏的能力。 没有雄厚技术和资金的国内独立开发者们做出了包括《中国式家长》、《太吾绘卷》、《戴森球计划》、《烟火》、《暗影火炬城》等题材不同、玩法不同的好游戏，他们中的不少都曾经打入steam周销量榜前十（全球），引起国内外玩家热议，而《动物派对》登陆2021年（全球最大游戏展之一的）E3游戏展微软展台，《黑神话：悟空》得到了几乎整个中国游戏圈子的追捧，更是引来国外众多游戏开发者与玩家的热议…… 不止如此，就在今年七月末公布的《2021-2022年度国家文化出口重点企业和重点项目名单》中，不仅有58家游戏公司在列，还有包括《明日方舟》、《原神》、《贪吃蛇大作战》、《波西亚时光》等八款游戏。 这些在海内外都有巨大反响的游戏，证明了中国开发者完全有能力做出优秀的游戏。然而… 就在公布上述名单后不久，央媒经济参考报发文《“精神鸦片”竟长成数千亿产业》短短四个小时内，腾讯股价下跌约9%，心动网络下跌约13%，网易下跌约15%，中手游下跌约20%……各大厂商累计蒸发市值约三千亿。 尽管四个小时后，这篇被炮轰“来自二十年前”的文章就遭到删除。但是腾讯当天依然迅速推出双减双打政策进一步限制未成年人游玩。后面的事情大家都知道，30号，国家新闻出版署出台政策将未成年人的游玩时间杀到每周三个小时。而八月开始，八、九、十三个月游戏版号无原因的停发了。而上一次（2018年）大半年的停发，仅腾讯市值蒸发1500亿美元，最低时，仅有停发前的约六成。 当今游戏监管的不确定性和对游戏市场的影响力可见一斑。 如何看待中国游戏产业？ （当下：）游戏已经成为年青人的生活方式 在2020年，中国已经超越美国，成为世界第一游戏产品消费国，其中主力是18-22岁的青年人。不少人以前不玩游戏，但是却被身边的人带入了王者荣耀全民电竞“坑”，又或者开始了解原神是怎么回事。在游戏平台steam上，中国已经成为最大的购买来源群体。越来越多的外国游戏开始将中文、尤其是简体中文作为游戏标配，甚至有独立游戏开发者抱怨因为没有成本进行中国的本地化工作导致游戏遭到差评轰炸等问题。 而各类游戏的新闻在社交媒体上也都相当有话题度和二创活力。游戏内的一些术语例如白嫖、氪金、肝帝、开黑、PK、欧皇等词汇也早就超出游戏范畴，成为日常生活的一部分。 不仅如此，通过二创和衍生周边等，游戏还带动了网络文学、动漫、电影、电视剧、广告、电竞、网络直播和VR等产业的发展。 而在开发者一侧，越来越多的人开始对游戏制作感兴趣。各类小型团队活跃在taptap、steam等游戏平台上。甚至也不乏游戏科学这样从腾讯离职创业的团队。他们今年八月末的视频，截至10月12日依然有100多人看，斩获两千多万的播放量（仅B站）。 从这个角度来看，游戏产业和青年人联系紧密，是一个极其活跃的群体。 （未来：）游戏产业正期待变革 首先，我们需要指出的是，尽管我们前面写了许多监管的不好。但这绝不意味着游戏业是不需要监管的。游戏业是一种文化产业。无论中外、无论古今，都必须受到监管。这才是对游戏及其他任何文化产品负责任的做法。 而正如刚刚我们所说，游戏产业是一个广受当代青年、少年、孩子喜爱的的产业。无论我们承不承认游戏是所谓第九艺术，游戏作为一种新兴的、与国家未来们密切相关的行业，都需在正确的、合理的监管下健康发展。而这正是我们目前所缺乏的。 一方面，历史上的错误决策导致了如今腾讯网易形成垄断，在缺乏竞争的市场环境下，它们缺乏创新动力。大厂没有创新意愿等问题，进一步的就导致国内游戏业人才凋零、技术落后，削弱国产游戏竞争力。 另一方面，如今又一次趋严、趋保守的监管，对游戏业过于严苛，不仅甚至有可能抹杀现有的游戏出海热等繁荣状态，而且政策上的消极，也会加重社会上部分媒体、家长对游戏本就存在的偏见，使得“电子海洛因”的形象更深入人心。 作为一个庞大而年轻的产业，游戏业的发展离不开监管层对审核标准的进一步放开。越来越开放的的中国、日益热闹的游戏开发行业和广大的游戏玩家们，也呼唤着更规范而开放的监管层的出现。 而监管层呢，近年来也在有意放松，例如，2015年，游戏机禁令取消，我们能在正规渠道买到游戏机了。2020年，游戏适龄提示上线，有了些游戏分级的影子，甚至新闻出版署的未成年游玩限制新规出台，玩家们都疯传这样一种说法：新规意在堵住觉得游戏是坏东西的部分家长一口。而对于家长更开明的那些孩子而言，家长并不会介意帮助实名，因此不会受到影响。【此处需要图】 因此我们有理由相信，游戏产业监管正需要且正迎来一场变革，游戏监管一定会更加合理。使得游戏产业不仅有机会成为拉动经济增长的新力量，也成为我国文化输出的一大亮点。 （过去：）游戏（的监管史）是代际隔阂的当代写照 任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分。任何在我15-35岁之间诞生的科技都是将会改变世界的革命性产物。任何在我35岁之后诞生的科技都是违反自然规律要遭天谴的。 以《银河系漫游指南》闻名的科幻小说作家道格拉斯·亚当斯曾经写下上述这个著名的“科技三定律”。这虽然夸大而滑稽，却深刻反映了许多问题，例如，世风日下、人心不古这两个词语是怎么来的。例如，为什么金庸的武侠小说从孩子们偷着看变成了老师的推荐数目，周杰伦从“话都念不清楚”的差劲流行歌手变成了当代流行音乐天王。 有个网民【未知】曾经辛辣的讽刺： 我们不需要知道电子游戏是什么，它会不会造成近视，它会不会上瘾, 我们只需要一个背锅侠，一个可以掩盖家庭教育失败、 学校教育失败、社会教育失败的东西， 现在它叫游戏， 十五年前它是早恋, 三十年前它是偶像, 三十五年前它是香港电影， 四十年前它是武侠小说 这指出了部分家长的甩锅心理，但是我们要说的，他们之所以甩锅给游戏，正是因为他们带着偏见的眼光中，游戏是不好的。当代游戏产业的许多不合理之处，我们骂莫名其妙的监管、贪婪无度的游戏公司、骂不明事理的熊娃家长……说到底，就是在骂那些觉得游戏是“违反自然遭天谴的”，骂那些觉得自己不懂的产业就带着原罪的人。试想：如果监管者觉得游戏是大毒草，游戏的审核又怎么能公平合理呢？如果游戏公司老板觉得游戏就是一个捞快钱的地方，我们的游戏又怎么可能会吸引到玩家的注意力呢？如果家长觉得游戏是电子海洛因，又怎么可能在孩子成绩下降后不怪罪呢？ 如果我们今天只谈游戏产业受到了歧视和偏见，也许有朝一日随着玩游戏的一代人长大，游戏不会再被污名化，但是却会有其他产业被污名化。(例如短视频?）。从这个角度来看，游戏产业不过是当代文化产业快速发展大格局下，被推出来背“世风日下”这口大锅的那个。这是游戏产业的悲哀，也是每一个新兴文化的悲哀。 当然，正如我们也能看到一些开明的家长，一些孩子高三了家长帮忙上号代打的新闻等等，所谓“科技三定律”其实并非“定”律。这是可以改变的。一方面，做为玩游戏的青年人，我们有义务为游戏（和其他的新媒体、新文化）正名，为之发声，让更多家长辈的人明白、理解，游戏其实并不特殊，它不过是当代的一种新娱乐方式而已。另一方面，作为反思，我们是不是也在不知不觉中犯了类似的错误呢？生为00后的我们，对10后的娱乐是否又认真了解过，而不是简简单单的一句“哼，小孩子玩的”带过呢？ 愿我们都能多一些理解，少一些理所当然和“世风日下、人心不古”。 【报告结束】","categories":[{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"}]},{"title":"古埃及旅游指南 || 三、古埃及的一些事物与文化","slug":"古埃及旅游指南：文化篇","date":"2021-01-18T11:17:30.000Z","updated":"2024-01-03T05:42:54.298Z","comments":true,"path":"post/20210118191730.html","permalink":"http://example.com/post/20210118191730.html","excerpt":"提要 ~~这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。~~这里目前是一个草稿","text":"提要 ~~这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。~~这里目前是一个草稿 古埃及的墓穴和葬仪 在古埃及对国王和大多数社会阶层而言，在思想上进行统治的一个非常重要的方面就是丧葬祭仪。不朽的陵墓建筑和丧葬祭仪象征着国家和统治机构。有些坟墓周围埋有陪葬者。例如埃及第一王朝第三任国王哲尔，他的墓穴周围有300多个陪葬者，这也是埃及历史上唯一用活人陪葬的时期。第二王朝的国王不再采用这种仪式。 木乃伊 木乃伊虽然不是古埃及的专利，但是古埃及的木乃伊无疑是最有名的。埃及神话相信死者会再次苏生，所以想方设法的保护死者的躯体也就成了一件重要的事。 不仅是法老，一般人的死也会经历木乃伊化的过程，尽管不同年代、不同阶层有很多区别，但是粗略来说，古埃及人会把死者的内脏等清理干净、涂上油防腐、还要裹上亚麻布。然后和其他的陪葬品一同安葬。 木乃伊也不是人的专属，很多的动物，尤其是猫，不仅是神圣的女神巴斯特的象征，还能抓耗子保护谷物，还可爱。 也经常被做成猫乃伊。 石棺铭文 虽然君主的权威在不断增强，但古王国末期和第一中间期的混乱局面大大削弱了王权在人们心中的地位。王权不再像过去那么神圣，在宗教上的权威地位也大打折扣。从人们去往来生世界的某种更为民主化的形式，可以明显的看出这一点。包含在金字塔铭文中的咒语经文，不再是国王和王后所独享的特权，而是只要买得起，任何人都可以将其刻在棺柩上。这就是我们所说的“石棺铭文”。中王国时期，铭文的数量激增，为我们提供了比古王国更多更直接的历史资料。这一时期的语言成了古埃及时期的标准经典语言，即中古埃及语。预言书，道德故事，赞美诗等叙事体文学作品大放异彩，成为中王国时期重要的文化成就之一。这些作品中最著名的是《西努赫流亡记》和《遇难水手的故事》，在中王朝结束很久之后，这两个故事仍然为人们所传播 古埃及丧葬习俗（英文）： https://en.wikipedia.org/wiki/Ancient_Egyptian_funerary_practices 医药 如果单就文字的运用而言，有许多时候和一般所谓的文学不同的实用性文字，埃及人的实用性格在这类文献中有清楚的表现。首先是医药方面的作品，用现代的概念来说，有属于医理方面的手册，包括对疾病的判断，或者治疗疾病的方法，也有属于药方之类的作品，虽然其中有时不免有巫术之类的手段。在一卷有关外科手术的文献中，我们可以看到以下记载：若你检查一个头部受伤者，伤势深入头骨，但并没有伤口，你应该轻触他的伤处。如果你发觉他的头骨没有受损，没有穿洞，没有裂痕或破碎，你应该对他做如下的诊断：“此人头上有伤，伤口没有裂开，虽然伤势深入头骨。这个伤我可以治。”你应该在第一天时将伤处用新鲜的肉敷住，而后每天施以油脂，蜂蜜，绷带，直到他康复。在古代世界中，埃及的医学的确是相当著名，许多希腊时代的作品都提到埃及医学和药物对他们的影响。而埃及人制作木乃伊的习俗也很可能与埃及医学中外科医学的发达有某种关系。 数学和几何 埃及人在建造金字塔和神庙这类的建筑活动中显然必须依靠相当精确u的数学计算，否则不可能成功。不过埃及的数学基本是从实用着眼，只求能够解决实际的问题，而没有理论上的兴趣。我们目前有关埃及数学的了解主要来自中王国时代的两份草纸文书，以及一些较晚而零散文献。基本上，埃及数学以十进位，而他们只用单位分数，如1/2,1/3,1/4等等，唯2/3例外。因而3/4是以1/2加1/4来表示。而数学的基本运算是以加法和倍数为基础，例如13乘以17，埃及人的写法是： ![img](file:///C:/Users/uftx/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg) 答案是将左边取1+4+8=13，右边相应地取17+68+136=221，结果为13*17=221。除法也用相似的方法，只是倒过来。至于几何学，埃及人的水平也大致限于简单的面积和体积的计算，但显然这些已足够让埃及人得到实用的数据。 法老的胡须 毛发是容易藏污纳垢的地方，所以爱干净的古埃及人就想了聪明的办法：把原来的毛发剃掉，然后戴上假发和假胡须。就能美观又干净了【如下图】 一个小细节是，法老在世时的胡须是直的，逝去的法老的胡子则和神的一样是弯的。这是因为法老去世是被认为回归神明之列。 参考 古埃及练习曲，头发与假发（上），（繁体字） 知乎，法老的胡子有什么特殊的含义吗？ 努比亚人 努比亚人是埃及人的南方邻居，和埃及关系密切。埃及第25王朝就是努比亚人的王朝。而八爷担任的职务：守护者，职责最初就来自努比亚人的文化。 芦苇（莎草）、芦苇船、莎草纸 在埃及的绿洲边，常常能发现一种高大的草，这就是莎（suo）草，也被称做芦苇。（尽管生物学上来说芦苇和莎草是不同的）。有芦苇，就有水，有绿洲和肥沃的土地。因此古埃及人特别喜爱芦苇。 他们不仅用它做出了莎草纸、芦苇船，用芦苇的根茎作为神的贡品，对于死后天堂的描述也是一片长满芦苇肥沃的土地——芦苇原。 莎草纸，也许是世界上最早的一类纸，古埃及人从公元前3000年开始就用这种纸书写（这个时候，中国真处于尧舜禹的时代，再过三千年多年，东汉蔡伦才改进造纸术）。 不过，因为莎草只长在埃及地区，又不耐潮湿，在埃及以外的区域普及度并不高。所以在羊皮纸和更后来的中国纸的普及下莎草纸就逐渐失传了。不过，经过上个世纪的一个埃及工程师的研究，人类重新发明了莎草纸的制法。（尽管并没有什么使用价值就是了） 芦苇船，字面意思，就是用芦苇编成的船。在游戏中有两种小船，一种是士兵们坐的木制兵船，另一种则是平民们划的装满蔬果的芦苇船，如果用带火的箭头靠近船身，很快就会看到船被点燃。 参考： 维基百科，莎草纸：https://zh.wikipedia.org/wiki/%E8%8E%8E%E8%8D%89%E7%BA%B8 维基百科，纸莎草：https://zh.wikipedia.org/wiki/%E7%B4%99%E8%8E%8E%E8%8D%89 三桨座战船 游戏里出现频率最高的战船（兵营），古代希腊人和罗马人的一种战船，所谓三桨座的就是一边有三排桨。 参考： 刺客维基，三列桨座战船 三个桨的排布可参考维基百科下图【插入维基图片】 战象 大象皮糙肉厚，体型庞大，无论是实际战力还是对人的压迫力都极强。因此波斯帝国在和印度交战的过程中，学会了驯化大象进行战斗。之后，这一技巧又被与之交战亚历山大大帝学到。托勒密王朝最后从亚历山大人那里继承这一手段。此外，罗马人的老对手，迦太基人也点出了驯化非洲象作战的技能，并在布匿战争中被罗马人学会。这就是为什么我们能在特定的兵营里挑战罗马的战象。 埃及王冠 正如我们在历史篇中提到，埃及是由上下埃及两片构成。上下片无论是地形水土还是文化都有一定差别，因此，埃及王冠由上下埃及王冠合在一起构成的，表示法老同时统治上下埃及。 外圈是下埃及之冠，由于颜色，它也被叫做“红冠”。 内圈是上埃及之冠，由于颜色，它也被叫做“白冠”。 所以完整的王冠也就可以简单粗暴地叫做“红白双冠”。 同时，为了表示神的庇佑，在王冠前端还有上下埃及守护女神的象征，眼镜蛇（下埃及女神瓦吉特）和秃鹫（上埃及女神奈赫美特）。需要提醒的是，秃鹫女神奈赫美特不是母狮女神塞赫美特。 圣书体 圣书体顾名思义，是书“圣”的字体。这是一种用于给祭司们书写祭祀等神圣之事的字体。在游戏神庙的墙上就能看到。虽然随着古埃及文化的消亡，圣书体最终失传，但是它是世界上几乎所有字母系统（例如英语中的ABCD）的起源。 埃赫那顿事件（要不要放进游戏后篇呢） 埃赫那顿是新王国时期的十八王朝的一位法老。在他在位的年代，他干了一件惊世骇俗的事情：对宗教进行改革，否认拉、荷鲁斯、阿蒙等神的存在，认为世界上只有一个神，也就是太阳神阿顿，有人认为这是世界最早的一神论——要知道这个时候是公元前1000多年前！不仅如此，埃赫那顿还把都城由底比斯迁到新修的埃赫塔顿（这个名字也是为了纪念阿顿神） 不仅如此，他的王后也不同寻常。王后娜芙蒂蒂美貌惊人，而且很有能力，她和丈夫一同推进宗教改革、而且拥有一些以往只有法老自己独占的权利，甚至有埃及学家怀疑埃赫那顿的继位者斯门卡瑞就是娜芙蒂蒂化名。 尽管埃赫那顿统治了不短的时间，但是在他去世后，宗教改革成果还是迅速被不满的祭祀们破坏了。斯门卡瑞短暂的统治之后，法老之位传到了埃赫那顿的儿子图坦卡蒙手上。年幼的图坦卡蒙即位后，立即将名字由图坦卡顿（也就是“阿顿的人间化身”）改为图坦卡蒙（“阿蒙的人间化身”），他还把首都迁回底比斯、把父亲的墓改迁回传统的帝王谷、恢复祭司们的职位……而埃赫那顿、阿顿等名字也被刻意的从碑文上抹除，成为一段被刻意避讳和遗忘的历史。 图坦卡蒙的墓 在古埃及王室，近亲结婚现象非常普遍，即使到了八爷的托勒密时代也是如此。而图坦卡蒙，是埃赫那顿和他的姐妹（被埃及学家称为“年轻女士”）的孩子。近亲结婚的后果之一，就是严重的遗传病，根据科学研究，图坦卡蒙有包括脊椎侧弯和兔唇、骨组织坏死等种种疾病，年纪轻轻就需要拄拐杖，最后19岁就英年早逝。 图坦卡蒙之墓在上世纪20年代被英国的一行考古团队找到。保存得极其完好的图坦卡蒙墓不仅成为考古学的大发现，还引起全球轰动。而数位早期探险家的早逝，也引发“法老的诅咒”这一谣言，给古埃及文化戴上一层神秘魔幻的面纱。从那以后，的电影、小说、游戏在使用古埃及的文化形象。某种程度上来说，今天能玩到刺客信条起源，也离不开那次图坦卡蒙之墓被发掘的影响。 为什么游戏里图坦卡蒙和娜芙蒂蒂的死后世界入口在一个墓里呢？这是因为在2015年，科学家们发现图坦卡蒙之墓似乎是改建于在一个女性的墓，而这个女性，就极有可能是被祭司们试图抹杀存在的娜芙蒂蒂王后之墓。 参考： 维基百科-图坦卡蒙 古埃及练习曲，2015年度風雲人物──圖坦卡門","categories":[{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"}]},{"title":"搭建个人博客 || 二、域名跳转和写博客","slug":"搭建博客/个人博客上岸回顾(二)","date":"2021-01-18T11:17:30.000Z","updated":"2024-01-03T05:42:54.298Z","comments":true,"path":"post/20210118191730.html","permalink":"http://example.com/post/20210118191730.html","excerpt":"提要：如何把域名解析到自己的网址和输出内容","text":"提要：如何把域名解析到自己的网址和输出内容 前言 首先声明，把域名解析到自己的网址不是必要的，扔在 GitHub 就挺好。不过为了简洁好记和个（耍）性（帅），而且手上“恰好”有一个域名，那干嘛不折腾一下呢？并不是因为重新入坑所以把后期内容提上来了 确实还有很多事想做的！换背景、加音乐、换主题……但是内容永远是第一位的。所以，我们先讨论如何写博客。 写博文 关于Markdown hexo 下博文以 Markdown 格式存储于本地，也就是 part 1 中我们一开始新建的文件下。因此，我们需要一款 Markdown 文本编辑器。目前我的 Typora 使用手感尚好。够简洁优雅，” 所见即所得 “ 的特性对萌新也够友好。你可以从官网下载到它。 至于 Markdown 的语法，建议花五分钟在百度上，然后熟能生巧即可。额外一提的是，hawa130 那学到的在字母数字前后空一个空格的习惯很棒，建议养成。 文章的模板 你一定注意到，正如这篇博文，有创建日期、标签和目录等信息，这些非正文内容存在于文章的开头，形式如下： 这一部分由 hexo 生成，在 Git Bash 中使用 hexo new postname 生成一篇名为 postname 的新博文 。 而其模板在博客根目录\\scaffolds\\post.md 文件中。推荐添上 categories 和并在正文中写下““””文章在此处折叠）。 当然，此处还有 draft 和 page 两个模板，由于本人目前写文章是写好一篇更新一次，所以 draft 等没有用上。目测 draft 是上传至 GitHub 但不发表，page 则不知道由什么用。 写好以后，打上合适的 tags 和 categories ，再重新部署（hexo d）一下，就可以在博客上看到自己的新文章了！（顺便一提，多 tag 的格式如图哦） 域名解析","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]},{"title":"搭建个人博客 || 一、在本地搭好博客","slug":"搭建博客/个人博客上岸回顾","date":"2020-10-26T16:37:19.000Z","updated":"2024-01-03T05:42:54.299Z","comments":true,"path":"post/20201027003719.html","permalink":"http://example.com/post/20201027003719.html","excerpt":"前言 本博客搭建于大一 2020，同时写的教程，已于 2023 年重新编辑。","text":"前言 本博客搭建于大一 2020，同时写的教程，已于 2023 年重新编辑。 介绍 关于这个博客：本博文的目的，与本博客本身，是一个托管于 Github Pages，基于 Hexo 的静态博客网，主要参考资料是本文末中的第一个视频。搭建时的主要目的是完成 MSC Web组的初面。 关于这篇文章：本文首次发布于 2020 年 10 月，初衷是为了回顾厘清懵懵懂懂、混混沌沌的搭建过程。而且那会还幻想着会有人来看（当然也不能说现在没有在幻想）。现在回过头来看不免觉得很多地方由于本身的理解不到位而表达含混甚至错误、还有一些刚刚搭建好博客带来的自我意识过剩，而且最后还烂尾了。因此近期终于感觉有时间和足够的理解后决定重新编辑并补完，但是我的目标仍然是尽力将其写成完全小白向的风格。 配置 hexo 环境 OS：Windows 10 生成：Node.js + hexo 托管：GitHub Node.js 在官网下载安装即可。安装完成后，在控制台（例如 cmd 和 PowerShell ）运行node -v和npm -v应当可以看到 node.js 和 npm 的版本号。（关于控制台、终端和shell，可以参见【占位符】） Node.js 是一个开源的 Javascript 运行环境，它由 OpenJS 基金会维护和持有。所谓运行环境，可以说成是前置条件或者说充分条件，一个更好理解的例子是 C 的环境：一个文本编辑器（写代码）和一个编译器（把 C 代码转换为机器语言）。我们使用 Node.js 运行 JS 脚本。 NPM 是 Node.js 的包管理器。大概可以理解为“插件管理器”，类似的包管理器还有 python 中的 pip 和Linux 下的 apt。在控制台（ cmd 和 PowerShell ）运行node -v和npm -v应当可以看到 node.js 和 npm 的版本号。 Git 官网下载。使用 git -v 检查是否安装成功与安装版本。 Git 是一个分布式版本控制软件。关于通过使用版本控制来管理博文，可以参见后续的文章【占位符】。在这里，我们的主要目的是通过 git 将我们的文章推送到远端 GitHub 仓库。 cnpm 与 npm Node.js 是由 OpenJS 基金会持有的软件，但其附带的包管理器 npm 则属于 npm 公司（已被 Github 收购）。npm 的默认下载源是从 npm 公司的公开下载源：https://registry.npmjs.org/ 进行下载（下载源的官方用词是 registry，注册表）。它收录 npm 账户用户公开发布的包。如果好奇关于注册表和在 npm 上发布包的问题，可以参见下面的官方文档： registry | npm Docs Creating and publishing scoped public packages | npm Docs 不过这就离题太远，就此打住。 普适地说，直接使用 npm 就可以下载安装 hexo 了。不过在国内使用默认注册表通常都会存在下载速度的问题。常见的解决方法有配置 Node 的代理（配置方法网络上很多，这里不叙）和更换下载源。许多组织会维护官方镜像站，他们同步官方站点。这样如果不便访问官方站点，就可以把下载源换为镜像站的源。 更换下载源的三种方式(第二类中所有方式我都没有尝试) 临时切换：npm install your-package --registry http://your.registry.source 长期切换： 命令行：npm config set registry http://your.registry.source; 环境变量：NPM_CONFIG_REGISTRY中写入https://registry.npmmirror.com; .npmrc文件中写入：registry=https://registry.npmmirror.com。 使用cnpm：这是我们采取的方式。 需要注意的是长期切换中的所有方法我都没有用过，仅是作为一个简单记录。 cnpm 是阿里云推出的的另一个 npm 客户端，它和 npm 的功能完全一致，只是没有 publish 功能。使用 cnpm 的优点在于可以使用 cnpm 的默认国内源进行下载，同时在需要使用官方源的时候不用修改下载源。 在命令行界面下，键入npm install -g cnpm --registry=https://registry.npm.taobao.org，从https://registry.npm.taobao.org 安装 cnpm。 使用 npm config get registry 检查 npm 的下载源，cnpm config get registry检查 cnpm 的下载源。可以发现 npm 的默认下载源没有改变，cnpm 的默认下载源不同于 npm。 hexo cnpm 安装完成后，使用 cnpm install -g hexo-cli 安装 hexo。（如果没有使用 cnpm 是把 cnpm 换为 npm）。 运行hexo -v检查版本和安装是否成功。 配置博客 我们先简单阐述本博客中 hexo + Github 的工作原理，然后再详述具体步骤： hexo 是一个使用 Markdown 写作的静态博客框架。这句话的意思是，我们使用 Markdown 编写文章，编写完成后，hexo 将文章渲染为网页，具体来说就是 html、CSS、Javascript 三大件，hexo 在这一步用到了 Node.js。在这一步完成后，我们就可以在本地启动一个服务器，然后在本地浏览博客了。当然我们的目的是在公网访问，因此我们需要将生成后的文件托管到远端。我们采用 Github Pages，GitHub Pages 是 GitHub 推出的静态站点托管服务，其可以将你托管到 GitHub 特定仓库的网页文件渲染成网页。我们用 Git 将生成的内容推送到 GitHub 远端仓库，然后让 Github Pages 充当远端服务器，将文件渲染成网站。这样我们就可以随时随地访问到我们的网站了。 初始化一个博客 在合适的地方新建文件夹，此文件夹是博客的本地仓库，后续所有的操作都会是在此文件夹进行。 可以考虑建立一个专门存放各类文章/代码的文件夹，将 hexo 文件夹放在此文件夹内。通过 Windows 文件管理器左侧的“快速访问栏”快速抵达。 在此文件夹内启动终端 Shell： 在文件夹内右键选择 Git Bash Here 在其他地方启动 cmd、power shell、git bash，然后跳转到此文件夹。 如果你是 Windows 11，右键选择在终端中打开（Windows 10 需要在应用商店下载）。 在 Shell 中输入hexo init将此文件夹初始化（initialize）为 hexo 博客（如果建在一些特殊的地方，可能需要命令前加上sudo使用管理员权限）。 本地访问 hexo 初始化的博客是包含有默认文章的生成网页的，因此继续输入hexo s（s：server ）启动一个本地服务器，就可以通过端口 4000 localhost:4000 访问网页了。 Github Pages托管 当然存在其他的托管服务，例如国内的 gitee pages 托管。不过国内公开仓库都要先审核的环境嘛……emmmm。下面阐述步骤： 首先需要一个 GitHub 账号。 新建仓库：GitHub 的政策是每个账户只能拥有一个 GitHub Pages 站点，且站点文件必须存储在格式为 YourGithubAccountName.github.io 的仓库（Repository）内。因此，点选网站上 Repository 边的 New 新建一个库。 安装 Git 部署插件：回到命令行，在博客目录下输入cnmp install hexo-deployer-git安装部署插件。这一步的目的是使得我们可以将把博客部署（推送）到远端的服务器上，就本例而言，即 Github 仓库上 Note1：大一的时候我只能混沌地意识到 Git 与 Github 的不同但是说不清楚。建议读者可以先单独地使用一下 Git 和 GitHub 以更好地理清二者关系。 Note2：参考视频给的命令是cnmp install --save hexo-deployer-git，多出来的--save含义是安装好此插件后将其自动作为依赖（dependencies）添加到我们的 hexo 博客目录下的packages.json文件中。但是在 2017 年 5 月的 npm 5.0 后，不用写此选项也会自动添加了。因此这一选项可以删去了。 修改配置文件：在博客目录下找到 _config.yml 用任意文本编辑器打开 。滑到最低端找到 deploy 。把 type 后面引号中写入 git 。然后换行写上：repo： YourGIthubRepoAddress，再换行写上branch: master 。 这一步的目的是指定 hexo 的部署方式是使用 git，部署地址是我们指定的 git 远端仓库的 master 分支（主分支）。 编写博文：以前面说的 hexo 目录为根目录（./目录）下的./source/_posts文件夹下新建 Markdown 文件，使用 Markdown 编写（测试）博文。 部署：用hexo g将写好的博客生成（generate）对应的网页文件（HTML、JS、CSS），配置 Git 身份，键入hexo d 来部署（deploy）到远端。下面详述配置 Git 用户身份： Git 是一个版本管理工具。因此每一次上传都要求可追溯。上传前需要配置用户名和邮箱。这样协作者（对于开源项目，可能是陌生人）就可以联系到你并直到如何称呼你。 GitHub 使用你 Git 上传的邮箱来确定用户，所以这里我们应该保证邮箱以及用户名与 GitHub 账户一致，避免造成混乱。 如果只有一个GitHub 账户，可以将用户身份配置为全局的：git config --global user.email &quot;YourGithubAccountEmail&quot;和git config --global user.name &quot;YourGithubAccountName&quot;这样就不必每个项目推送到远端时都重新配置用户身份了。 但是我有多个账户，因此我的习惯是删去上述命令中的--global选项，不配置全局身份，这样，每个项目的第一次提交前必须要配置一个身份。 显然，我们在 Git 中配置的身份只是“宣称”我们是谁———— Git 可没有账户密码系统。因此远端托管网站会要求输入你在其网站的账户密码以验证你是否有权限访问你想要读写的远端仓库。因此下一步是在弹出的窗口中输入 Github 账户密码。 核验 Github 账户：有多种验证 GitHub 身份的方式。 Token：一共需要输入两次密码。第一次的时候，你应该输入你的 GitHub 账号和密码，第二次的则须如下获取。 首先GitHub网页点击头像 -&gt; Settings -&gt; Developer Settings -&gt;Personal access tokens -&gt;Generate new token。创建一个新的 token ，设定其权限和名字，随后 GitHub 会分配给它一个 password 。这里的名字和密码才是第二次所需输入的。需要注意的是，你只有一次看到密码的机会，所以一定要保存好。以防日后用到。 检验成功后，Github 就会将文章上传到远端仓库，并使用 Github Actions 将其交给 Github Pages 静态站点渲染为一个网页。以后，访问 YourGithubAccountName.github.io 即可看到和 hexo s 一样的网站页面了。 后言和一些感想 总结一下，本文阐述了如何完全从零：甚至没有 Git 和 Node.js 的前提下如何安装 Git、Node.js 等软件，并利用 Hexo 框架搭建一个静态博客，最后将其部署到 Github Pages 远端的过程。 如果你照着我的、或者别人的教程搭好了这样一个小小的静态博客。首先，相信和我 一样是充满成就感的，Hello World 两个单词仿佛是一个广阔的新世界你面前缓缓展开。其次，你也一定会注意到它是简单的，流程并不复杂，而且我们不曾敲过一行代码，那些真正麻烦的工作，hexo 给我们静静地办好了。无论如何，博客是我们的，我们可以自由的享用它了。 2023：如今回过头来才发现那些当时觉得困难无比的操作如今都稀疏平常。那个时候一个 npm 的下载问题都能要了我老命，什么时候是在用 GitHub、什么时候是在用 Git都晕晕乎乎难以明了。一方面，这大概是出于这并不是一个困难的问题反而导致有很多小白会对其感兴趣（这些人日常并不用 Git 和/或 Node.js 日常干些什么），于是讲解就必须要琐碎、细致且不关心为什么这么做。另一方面，国内的生态环境也就是如此，如果搜索“npm 默认下载源地址”那么大概率搜出来的都是教你如何更换下载源，却少有文章告诉你是哪儿。而使用英语，我们很轻松就可以找到本文上述有关部分给出的那两个官方参考地址。其他各种问题往往也能有各类文档与论坛（如 StackOverflow）解释。这多少有些悲哀。 我现在的博客当然不是默认样式，我们会在之后的系列文章中进一步的优化写作环境点击链接跳转到下一篇文章了解如何优雅地写博文。 感谢与参考 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo bilibili, UP: codesheep hawa同学。身边有有个大佬真好用。 newBing：在我重写此博客时提供了一些参考信息。","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"},{"name":"GAMES104","slug":"GAMES104","permalink":"http://example.com/categories/GAMES104/"},{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"},{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"},{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"},{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"},{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"},{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"WSA","slug":"WSA","permalink":"http://example.com/tags/WSA/"},{"name":"配置环境","slug":"配置环境","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Obsidian","slug":"Obsidian","permalink":"http://example.com/tags/Obsidian/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大作业","slug":"大作业","permalink":"http://example.com/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"粒子","slug":"粒子","permalink":"http://example.com/tags/%E7%B2%92%E5%AD%90/"},{"name":"刚体","slug":"刚体","permalink":"http://example.com/tags/%E5%88%9A%E4%BD%93/"},{"name":"流体","slug":"流体","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93/"},{"name":"计算机动画","slug":"计算机动画","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB/"},{"name":"关键帧","slug":"关键帧","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%B8%A7/"},{"name":"骨骼系统","slug":"骨骼系统","permalink":"http://example.com/tags/%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/"},{"name":"运动学","slug":"运动学","permalink":"http://example.com/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"Rigging","slug":"Rigging","permalink":"http://example.com/tags/Rigging/"},{"name":"颜色","slug":"颜色","permalink":"http://example.com/tags/%E9%A2%9C%E8%89%B2/"},{"name":"色彩空间","slug":"色彩空间","permalink":"http://example.com/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"},{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"光场","slug":"光场","permalink":"http://example.com/tags/%E5%85%89%E5%9C%BA/"},{"name":"透镜","slug":"透镜","permalink":"http://example.com/tags/%E9%80%8F%E9%95%9C/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"光线传播","slug":"光线传播","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E4%BC%A0%E6%92%AD/"},{"name":"程序化生成","slug":"程序化生成","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"反射率","slug":"反射率","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84%E7%8E%87/"},{"name":"折射","slug":"折射","permalink":"http://example.com/tags/%E6%8A%98%E5%B0%84/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"微表面","slug":"微表面","permalink":"http://example.com/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"},{"name":"菲涅尔项","slug":"菲涅尔项","permalink":"http://example.com/tags/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"路径追踪","slug":"路径追踪","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"name":"蒙特卡洛积分","slug":"蒙特卡洛积分","permalink":"http://example.com/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"},{"name":"渲染方程","slug":"渲染方程","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"},{"name":"全局光照","slug":"全局光照","permalink":"http://example.com/tags/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"均匀网格","slug":"均匀网格","permalink":"http://example.com/tags/%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"软阴影","slug":"软阴影","permalink":"http://example.com/tags/%E8%BD%AF%E9%98%B4%E5%BD%B1/"},{"name":"阴影映射","slug":"阴影映射","permalink":"http://example.com/tags/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"},{"name":"Whitted-Style 光线追踪","slug":"Whitted-Style-光线追踪","permalink":"http://example.com/tags/Whitted-Style-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"求交点","slug":"求交点","permalink":"http://example.com/tags/%E6%B1%82%E4%BA%A4%E7%82%B9/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://example.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"},{"name":"B 样条","slug":"B-样条","permalink":"http://example.com/tags/B-%E6%A0%B7%E6%9D%A1/"},{"name":"网格简化","slug":"网格简化","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96/"},{"name":"网格细分","slug":"网格细分","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%BB%86%E5%88%86/"},{"name":"Loop 细分","slug":"Loop-细分","permalink":"http://example.com/tags/Loop-%E7%BB%86%E5%88%86/"},{"name":"Catmull-Clark 细分","slug":"Catmull-Clark-细分","permalink":"http://example.com/tags/Catmull-Clark-%E7%BB%86%E5%88%86/"},{"name":"隐式几何","slug":"隐式几何","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"显式几何","slug":"显式几何","permalink":"http://example.com/tags/%E6%98%BE%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"构造实体几何","slug":"构造实体几何","permalink":"http://example.com/tags/%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95/"},{"name":"距离函数","slug":"距离函数","permalink":"http://example.com/tags/%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"重心坐标","slug":"重心坐标","permalink":"http://example.com/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"},{"name":"Mipmap","slug":"Mipmap","permalink":"http://example.com/tags/Mipmap/"},{"name":"线性插值","slug":"线性插值","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"着色器","slug":"着色器","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"},{"name":"Blinn-Phong 着色模型","slug":"Blinn-Phong-着色模型","permalink":"http://example.com/tags/Blinn-Phong-%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B/"},{"name":"纹理","slug":"纹理","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86/"},{"name":"uv 图","slug":"uv-图","permalink":"http://example.com/tags/uv-%E5%9B%BE/"},{"name":"图形管线","slug":"图形管线","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"GMAES104","slug":"GMAES104","permalink":"http://example.com/tags/GMAES104/"},{"name":"导论","slug":"导论","permalink":"http://example.com/tags/%E5%AF%BC%E8%AE%BA/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"反走样","slug":"反走样","permalink":"http://example.com/tags/%E5%8F%8D%E8%B5%B0%E6%A0%B7/"},{"name":"深度检测","slug":"深度检测","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"Z-Buffer 算法","slug":"Z-Buffer-算法","permalink":"http://example.com/tags/Z-Buffer-%E7%AE%97%E6%B3%95/"},{"name":"画家算法","slug":"画家算法","permalink":"http://example.com/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"},{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算","slug":"云计算","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"},{"name":"Unreal","slug":"Unreal","permalink":"http://example.com/tags/Unreal/"},{"name":"杂录","slug":"杂录","permalink":"http://example.com/tags/%E6%9D%82%E5%BD%95/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"},{"name":"基本线性变换","slug":"基本线性变换","permalink":"http://example.com/tags/%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"批处理脚本","slug":"批处理脚本","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98/"},{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"},{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]}