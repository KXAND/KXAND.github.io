{"meta":{"title":"LeeKa 的酒馆","subtitle":"欢迎，旅人！坐下来享受一下暖烘烘的炉火吧。","description":"代码、音乐和游戏，一起来聊聊吧","author":"LeeKa","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2021-01-19T16:25:11.000Z","updated":"2023-03-15T13:17:05.435Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欢迎来到 LeeKa Pub！ 这个页面提供本网站的一些信息。 这里的作用 这是一个基于 hexo 搭建的个人博客，使用 NexT 主题。 虽然名字有个 Pub，就本质而言，不过是个静态博客。所以除了阅读外还是不要期待有更多的功能 网站内容 基本上是想到什么写什么，主题大概是一下三块：计算机技术、电子游戏、音乐。 关于计算机技术： 基本处于学到什么写什么的状态。 关于电子游戏：目前设想主要分游戏鉴赏和游戏制作两块。游戏鉴赏是对玩过游戏的评价；游戏制作则是独立游戏制作过程中学到的小知识，主要是指 Unity 引擎。 关于音乐：Bloger 对电子音乐比较感兴趣，兼听古典、摇滚、流行、Vocaloid。不过并不打算精通。 关于作者 20多岁，是大学生。目前了解的比较多的地方是区块链和游戏开发。 反馈 作为 LeeKa 的互联网据点，LeeKa 会尽力逐步完善这个 Pub。 如果你在浏览过程中发现问题 / 可改善之处，欢迎通过邮件(leeka.pub@outlook.com)告诉我。"},{"title":"schedule","date":"2020-10-22T06:39:23.000Z","updated":"2023-04-19T08:56:16.410Z","comments":true,"path":"schedule/index.html","permalink":"http://example.com/schedule/index.html","excerpt":"","text":"别想了，我没有日程安排。"},{"title":"目录","date":"2020-10-22T06:35:37.000Z","updated":"2020-10-22T06:38:40.539Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2020-10-22T06:24:10.000Z","updated":"2020-10-22T06:32:40.714Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GAMES101-5：三角形的","slug":"GAMES101/GAMES101-5","date":"2023-07-20T14:58:17.000Z","updated":"2023-07-20T17:45:08.776Z","comments":true,"path":"2023/07/20/GAMES101/GAMES101-5/","link":"","permalink":"http://example.com/2023/07/20/GAMES101/GAMES101-5/","excerpt":"前言GAMES101-P5：光栅化","text":"前言GAMES101-P5：光栅化 本节介绍 MVP 变换之后的操作：光栅化 Rasterize 屏幕与光栅化定义屏幕： 单元为像素的一个二维数组 分辨率：长宽像素 是一种光栅成像设备 光栅化：“画”到屏幕上 像素：显示由 RGB 混合的单一色彩。 pixel 是 picture element 的缩写 raster 其实是德语中的 screen 的意思 屏幕空间：定义方式不一，可以以左下角为（0，0）点第一象限定义空间。 XY方向的投影将经历投影变换得到 $[\\pm 1,\\pm 1]$ 宽高的面拉成屏幕的宽高$[0,w]\\times[0,h]$。变换矩阵： $$\\begin{bmatrix} \\frac{w}{2} &amp; 0 &amp; 0 &amp; \\frac{w}{2} \\ 0 &amp; \\frac{w}{2} &amp; 0 &amp; \\frac{h}{2} \\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 三角形的光栅化光栅化即将多边形劈成数个像素的过程，这个过程中最基础的是三角形。 三角形的良好性质： 最基础的多边形，而且其他多边形都可以拆分为三角形 三角形定义的一定是平面（反例：沿对角线折了的四边形） 清楚的内外定义：没有凹凸之分，通过叉积可以简单判断在里还是外 三角形内点的属性可以由根据离三角形顶点的距离关系进行插值得到 如何判断一个像素该不该被点亮？ 采样抽象地说，采样就是将一个函数离散化。 对像素中心进行采样： 如果像素中心在三角形内，则点亮，否则不点亮。 边界问题：如果落在边上，采取统一的处理方式即可。如①不认为在多边形内左下、②左下认右上不认； 判断点在三角形内：用三条边与点 q 连线进行叉乘。 如 $P_0P_1$、$P_1P_2$、$P_2P_0$ 分别对 $P_0Q$、$P_1Q$、$P_2Q$ 叉乘，得到的结果都在同一侧则说明在三角形内 对判断过程进行加速 包围盒方法：左于最左顶点高于最高顶点的肯定不用考虑。最上下左右的点围成的四边形就是三角形的包围盒。记录边界的所有点。 Extend：关于显示设备隔行扫描：造成画面撕裂 帧缓存（frame buffer）：将内存（显存）中的一块区域存储图像，并映射到屏幕。 LCD：液晶显示。通过液晶过滤指定的波改变光的颜色。 LED：发光二极管。小灯管组合发光。 墨水屏：控制黑色墨水面显示在上还是白色墨水面显示在上，刷新极慢。","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"}]},{"title":"Unity的新按键输入系统","slug":"Unity/Unity的新按键输入系统","date":"2023-07-17T15:39:53.000Z","updated":"2023-07-18T12:29:22.852Z","comments":true,"path":"2023/07/17/Unity/Unity的新按键输入系统/","link":"","permalink":"http://example.com/2023/07/17/Unity/Unity%E7%9A%84%E6%96%B0%E6%8C%89%E9%94%AE%E8%BE%93%E5%85%A5%E7%B3%BB%E7%BB%9F/","excerpt":"前言这是 Unity 新输入系统（input system）的简要笔记。","text":"前言这是 Unity 新输入系统（input system）的简要笔记。 官方文档地址：Input System | Input System | 1.5.1 ActionsAction Type Value 类型：每次值改变的时候触发OnAction报告值；适用于追踪持续改变状态的输入。 Button 类型：每次按下的时候触发； Passthrough 类型：看文档意思是一种冲突解决方案：对所有的控制类型都会响应。 因此，一次按下松开会使 Value 类型调用两次 OnAction，但是只会调用一次 Button 或 Passthrough。 检查 Action 的状态(委托与轮循)可以使用下列三个 Action————此处 Action 是指一参无返的委托，不是 InputAction： action.started action.performed action.canceled 也可以使用下列函数进行轮循： 对于 value 类型： action.ReadValue&lt;T&gt;() action.PerformedThisFrame() 对于 Button 类型： action.IsPressed() action.WasPressedThisFrame() action.WasReleasedThisFrame","categories":[{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"}]},{"title":"Beautiful Times个人翻译","slug":"歌词翻译/Beautiful Times翻译","date":"2023-07-11T00:37:12.000Z","updated":"2023-07-11T00:57:49.648Z","comments":true,"path":"2023/07/11/歌词翻译/Beautiful Times翻译/","link":"","permalink":"http://example.com/2023/07/11/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/Beautiful%20Times%E7%BF%BB%E8%AF%91/","excerpt":"前言Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。","text":"前言Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。 除了旋律的优美与积极，另外一个另我印象深刻的点是排比和押韵的使用。大部分我都使用加粗、斜体、加粗斜体进行标识。这种韵律也是促使我翻译这个歌词的重要原因，尽管不太翻译出了其这一特点，但是这种用心琢磨一下文字的感觉实在让人心情很好。 翻译A spark soaring down through the pouring rain 耀眼的电光穿过瓢泼大雨 And restoring life to the lighthouse 废弃的灯塔被它再次点燃 A slow motion wave on the ocean stirs 激荡的海面逐渐涌起巨浪 My emotion up like a raincloud 我的心绪如雨云一样高飞 When did the sky turn black? 天空什么时候没了光彩？ And when will the light come back? 阳光什么时候才会回来？ A cab driver turned to skydiver 的士司机当了跳伞者 Then to survivor, dying to break down 在幸存之后濒临崩溃 A blood brother,surrogate mother 代孕母亲和她的哥哥 Hugging each other,crying their eyes out 互相拥抱着泣不成声 When did the sky turn black? 世界什么时候没了光彩？ And when will the light come back? 光明什么时候才会回来？ I’m ecstatic like a drug addict 我喜悦的心情好似嗑药 locked in the attic. Strung out and spellbound 困在阁楼，疲惫又热情 I fought all through the night 我整晚都在顽强对抗它 Oh oh, but I made it alive 最后终于让我走了出来 The sun’s starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 这场生的搏斗太难、太难、太难了 But I’m gonna survive 但我会把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 A bad feeling burned through the ceiling 就把消沉的心绪付之一炬 Leaving my healing heart with a new scar 只给我痊愈的心添道新疤 A dead fire rose and rose higher 死亡之火升腾得愈高愈旺 Like a vampire up from the graveyard 如飞起的吸血鬼凌于群鸦 When did the sky turn black? 世界什么时候失去光华？ And when will the light come back? 希望什么时候能够回家？ We all suffer but we recover 我们都饱经磨难但是挺了过来 Just to discover life where we all are 最后明白我们生命的意义在哪 I fought all through the night 我搏斗了整整一夜 Oh oh, but I made it alive 但最后我还是活了下来 The sun’s starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I’m gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I’m gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 My heart’s burning bad and it’s turning black 灼烧的心已焦黑几近焚毁 But I’m learning how to be stronger 但我已学着变得更加强大 And sincerely I love you dearly 亲爱的我真切地爱着你 Oh but I’m clearly destined to wander 但明显地我注定着要流浪","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"}]},{"title":"C# 中 的委托机制(delegate、action、func)","slug":"C#中 的委托机制","date":"2023-07-06T13:40:05.000Z","updated":"2023-07-06T13:41:48.681Z","comments":true,"path":"2023/07/06/C#中 的委托机制/","link":"","permalink":"http://example.com/2023/07/06/C#%E4%B8%AD%20%E7%9A%84%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6/","excerpt":"前言简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是","text":"前言简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是 主要参考了C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili，一个很好的视频。 委托 Delegate委托的底层是一种函数指针。顾名思义委托的作用就是，当一个函数“不方便做某事”的时候，“拜托”另一个函数去做。可以用于实现事件与回调。 所有的委托都派生自 System.Delegate 类。 声明一个委托委托的声明 1delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt; 委托经过声明以后决定其可以引用的方法。方法与声明有相同的参数、返回类型、标签（关于标签参考此 CSDN 博客）。换句话说，委托的声明决定了它能调用什么样的方法，委托是被调用方法的模板。 实例化委托声明完成后，可以用 new 实例化一个委托实例，并且在参数中指定实例调用的方法。如下 1234public delegate void printString(string s);...printString ps1 = new printString(WriteToScreen);printString ps2 = new printString(WriteToFile); 最后向委托中传递参数即可。如下是一个完整的例子（From：runnoob） 1234567891011121314151617181920212223242526272829303132333435363738using System;delegate int NumberChanger(int n);namespace DelegateAppl&#123; class TestDelegate &#123; static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125; public static int MultNum(int q) &#123; num *= q; return num; &#125; public static int getNum() &#123; return num; &#125; static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法 nc1(25); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); nc2(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; &#125;&#125; 委托的多播如果委托对象（即实例）的类型相同，则可以合并、分离委托（使用 + 和 - 运算符），这被称之为委托的多播或组播。如下是一个例子（From：runnoob） 1234567891011121314...static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc; NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); nc = nc1; nc += nc2; // 调用多播 nc(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; FuncFunc 是委托的一种，它固定具有一个参数和一个返回值。格式如下： 1Func &lt;parameter_type,return_type&gt; expression; expression 可以是一个 lambda 表达式，也可以是一个方法。是方法的时候，这个方法和 Func 一样必须有一个传入值和一个返回值。这样，就可以把方法作为参数进行传递，同时不必像委托一样显式的进行定义声明。 lambda 表达式的举例： 1234Func&lt;string, string&gt; convert = s =&gt; s.ToUpper();string name = &quot;Dakota&quot;;Console.WriteLine(convert(name)); 实例化委托方法的举例： 123456789Func&lt;string, string&gt; convertMethod = UppercaseString;string name = &quot;Dakota&quot;;Console.WriteLine(convertMethod(name));string UppercaseString(string inputString)&#123; return inputString.ToUpper();&#125; ActionAction 也是委托的一种，它一定具有一个参数，并且没有返回值。 即： Action &lt;T&gt; name 总的来说，和 Func 差别不大。同样可以给它赋值为 lambda 表达式或方法。只要这个方法有一个参数并且没有返回值。 EventEvent 是一种特殊的委托，但是其复制的权限为delegate。使用 Delegate 的时候，我们不一定想立刻为其赋值。这种情况下，我们可以考虑使用 Event。 事件的声明： 12345 delegate void MyDelegate(); event MyDelegate myEvent;// orevent Action myEvent //Action 的本质是 Delegate 事件声明完成后就是一个实例了（类似变量）。 当作为类成员的时候， event 只能在类中被调用。 Event 的一种用处：让类外成员可以观测到类的私有成员发生了变化。 在类中定义私有成员的 public {get;set;} 变量，set 时，invoke 类中的event；类外事物需要观测时，在 event 中注册函数就会收到通知。 参考 C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili C# 委托（Delegate） | 菜鸟教程 Func&lt;T,TResult&gt; 委托 (System) | Microsoft Learn 三分钟彻底搞懂委托，事件，Action，Func的作用和区别_哔哩哔哩_bilibili 延申 逆变与协变类型请参考：Covariance and Contravariance in Generics | Microsoft Learn lambda 表达式部分参考： Lambda表达式_百度百科 C++ 中的 Lambda 表达式 | Microsoft Learn","categories":[{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"}],"tags":[{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"}]},{"title":"向量数据库技术鉴赏观看记录","slug":"向量数据库技术鉴赏观看笔记","date":"2023-07-01T14:49:55.000Z","updated":"2023-07-04T10:28:45.478Z","comments":true,"path":"2023/07/01/向量数据库技术鉴赏观看笔记/","link":"","permalink":"http://example.com/2023/07/01/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E9%89%B4%E8%B5%8F%E8%A7%82%E7%9C%8B%E7%AC%94%E8%AE%B0/","excerpt":"前言配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。","text":"前言配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。 笔记为什么要有向量数据库？我们可以将几乎所有的事物转化为数个值的组合来进行区别和描述。例如，一个狗={毛发长短，毛发颜色，体格大小，温顺程度……}，于是就可以用向量来表述一个东西。 向量一定程度的推理关系：如果“关系”作为向量的一环，那么我们会发现“警察与小偷”和“猫和老鼠”之间关系的相似性。 向量的应用： 图片领域：描述特征。实现“以图搜图”功能，参考计算机视觉实验和多媒体数据处理实验3（多媒体实验3：基于 BOF 进行相似图片搜索 | LeeKa 的酒馆） 文本向量化：描述一个句子中有多少个x关键词，见上述多媒体数据处理实验3。相似文本内容查找。利于理解文本的实际内容，AI相关。 将相似对话输入给 chatGPT，极大提高输出效果。 问题：传统数据库不适合存储处理向量（在一些云计算的例子中，甚至只提供存储字符串类型）。 传统数据库：通过查询语句进行精准搜索 向量数据库：查询库中与查询向量最相似的向量转化为 KNN 问题，具有一定的模糊性。 向量数据库的核心：KNN（K最近邻算法）距离的定义：欧几里得距离、余弦相似度、海明距离等…… 暴力搜索算法 聚类思想：如果我们先将数据进行分类，那么只在查询点所在类进行搜索，搜索的范围就小多了。 Kmeans 算法 指定聚 n 类，迭代 k 次。 随机生成 n 个代表点，按距离进行分类。 训练：将分类结果的平均点视为新代表点，重复此过程 k 次。 收敛：代表点数值趋于稳定 不能保证聚类不遗漏 近似最近邻 ANN：通常来说，试图提高速度的行为基本上都会带来准确率的下降。例如 Kmeans 中将一个点放入了错误的类中，算法得到的往往是近似的 KNN（参考 LSH 中的结果部分）。 局部敏感哈希算法 LSH：关于欧几里得距离的 LSH，见多媒体实验4：LSH局部敏感哈希 | LeeKa 的酒馆 采用海明距离的LSH 哈希函数：随机一个有正反的超平面。判断点是在正面还是反面，记为0/1。 对两个点点被哈希得到的 01 串计算海明距离 把 01 串进行分段，只要有一个段一致就候选的策略，提高分到同一个桶的概率。 ANN 问题中的内存开销问题：量化与乘积量化（PQ）内存开销问题：一个 128 维，每维一个浮点数（32 bit，4 byte）的向量需要占用 512 字节空间 B 树类数据结构可以为读写庞大数据库减少内存损耗。数据库存储在磁盘中，每次只读取其中的一个结点。见B 树、B+树、二叉搜索树与红黑树 | LeeKa 的酒馆； 乘积量化可以减少一个向量本身占有的空间 用代表点代表类中的所有向量：有损压缩 量化：向量根据码本转化为代表点 使用码本记录代表点，记录码本索引值代替记录向量真实值 如果我们使用一个字节存储码本索引，最多可以记录 256 个代表点，此后的每个向量只需要一个字节即可表示。 维度灾难问题：每一个维度都会拉远点与代表点的距离，高维非常分散。要保证好的效果，就需要大量聚类，码本开销就十分巨大。 乘积量化PQ：用低维子向量拼接代替高维直接量化，缓解维度灾难问题 例如 128 维向量被分割为8 个 16 维向量分别量化，得到结果再拼接。每个子向量有自己的码本。 高维结果实际上是低维量化结果的笛卡尔积，所以叫 PQ。 从指数增长变成了加法增长。 主要减少了内存开销，但是一定程度地提高了速度（$O(n+k\\log k \\log\\log n)$）,与之相比，暴力搜索的时间复杂度是 $O(kn)$。 其他降维方法：主成分分析PCA，见多媒体实验2：PCA主成分分析 | LeeKa 的酒馆 基于图结构的高效 KNN：导航小世界NSW 与 HNSW内存相比于速度和准确度，只能被开发者感知，因此有的时候我们愿意牺牲内存提高ANN的准确性与速度 导航小世界NSW 基于图结构：向量与向量之间的六人理论 图的构建方法： 没有孤立点 如果两个点够近就一定有边相连 边尽可能少 德劳内三角：一种满足 NSW 需要的构建方法 构建方法 将点随机放回空间 每次放回，就将其与最近点相连 最终图中既有一开始生成的较长的边，也有后续生成的较短的边 通过长边，我们可以从随机的查询点快速移动到与待查询点较近的点（直接在点空间构建不具备这种性质） 通过短边，满足德劳内三角的图结构，准确找到待查询点 分层小世界HNSW： 越上层越粗略，快速导航 越下层越仔细，准确查找 算法层面保证了先粗后快的查找过程，数据量扩大时表现更优良，稳定且快速。 本质是对查询的一种跳表化。 小世界算法：没有压缩 + 维护复杂的图结构 = 内存爆炸 其他向量数据库问题向量数据库依然是数据库，和传统数据库产品一样有许多方面需要考虑：访问接口、访问控制、备份、多节点、容错、机器的监控与追踪……","categories":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}]},{"title":"B 树、B+树、二叉搜索树与红黑树","slug":"B树与其他搜索树","date":"2023-06-25T14:47:14.000Z","updated":"2023-07-04T10:27:18.594Z","comments":true,"path":"2023/06/25/B树与其他搜索树/","link":"","permalink":"http://example.com/2023/06/25/B%E6%A0%91%E4%B8%8E%E5%85%B6%E4%BB%96%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"前言B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。","text":"前言B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。 B树的定义与特点如果数据太大，我们就无法在内存中放下整个树，同时我们知道磁盘读取速度远慢于内存。因此这种情况下我们对“读取”操作非常敏感。如果是不够平衡的树，或者深度太深，检索速度就会很慢。这就是为什么我们需要 B 树。 B 树，英文 B-Tree，有的地方还会翻译为 B- 树(不好的翻译,容易误解为和 B 树是两种东西)。B 树的 B 普遍来说被认为是 Balanced 的意思，因为这是一种自平衡树。 B 树不是一种二叉树，它定义如下： 定义一个结点中的值为键。一个节点中有多个键。 定义树的度为 t。 $t\\geq 2$。 每个结点键数： 空树：0个； 根结点:$[1,2t-1]$ 个； 普通结点：$[t-1,2t-1]$个。 非叶子结点的子结点数：自己的键数 +1 个。n 个键在数轴上划分了 n+1 个区间，每个子结点对应一个区间。 叶子结点：都在同一层。 例如：t = 2。此时的 B 树内部节点可以有 2、3 或 4 个孩子，称之为 2-3-4 树。 对 B 树进行操作B 树的检索在树 T 中检索关键字 k 的逻辑如下： 首先，查找 k 和 T 根结点的区间关系。 如果落在一个键上，那么就搜索到了 k 是 T.root 的第 i 关键字。 否则，继续第二步 在 k 落在区间的对应孩子上继续搜索。 当前结点没有孩子，说明没找到。 B 树的插入逻辑： 如果结点的键槽没有满，那就直接给结点添加一个新键。 如果结点满了（2t-1个键）：那把此结点的键分为三份，最中间的键插入到父结点，左右分裂为两个有 t-1 个键的结点。其孩子也对应分配给新分裂出来的结点。 如果父节点也满了：递归重复上面过程。 如果根结点都满了：创建一个空结点为新的根结点，然后分裂根结点 操作：实际我们在确定新键位置的过程中，就沿途分裂了所有遇到的满结点。因此实际上这不是一个递归过程。 B 树的删除假设问题是删除结点 x 中的键 k： 不少于 t-1 个键的叶子结点删除：直接删除； 内部结点： 找到 k 前面的区间对应的子结点 y，看是否有至少 t 个键： 如果 y 至少有 t 个键：找到结点 y 中最后一个键 k’（即 k 的前驱）。执行“删除结点 y 中 k’ 键”的操作。x 中用 k’ 替换 k。 否则：找到 k 后面的区间对应的子结点 z，看是否有至少 t 个键： 如果有：找到结点 z 中最后一个键 k’（即 k 的后继）。执行“删除结点 z 中 k’ 键”的操作。x 中用 k’ 替换 k。 否则：此时 y 和 z 加起来就只有 2t-2 个键。把键 k 和结点 z 都合并进 y。然后再在 y 中删除 k； 由上向下找 k 时如果确定 k 在一颗以 x 为根的子树中，并且 x 只有 t-1 个键，设 x 的父结点为 p： x 的一个相邻兄弟（y/z）结点有至少 t 个键：删除此键。根据是 y 或者 z，从 p 中对应给一个键给 x。从 y/z 中对应给一个键给 p； 相邻兄弟也只有 t-1 个键：合并 x 和 y/z、p 中由两个子结点夹着的键。如果p 是根结点而且本来就只有一个键，那么树的高度就缩减了。 B+ 树B+ 树的特点是在 B 树上做了如下改动： 非叶子结点不存值，只有子结点的头元素的索引 相邻叶子结点之间用指针直接串连 参考 面试官问你B树和B+树，就把这篇文章丢给他 - 好好学java - SegmentFault 思否 算法导论","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"索引，多媒体数据处理","slug":"索引，多媒体数据处理","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"多媒体实验4：LSH局部敏感哈希","slug":"课程报告/多媒体实验4LSH","date":"2023-06-14T03:47:13.000Z","updated":"2023-06-30T15:12:31.512Z","comments":true,"path":"2023/06/14/课程报告/多媒体实验4LSH/","link":"","permalink":"http://example.com/2023/06/14/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AE%9E%E9%AA%8C4LSH/","excerpt":"前言KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。","text":"前言KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。 目的在corel数据集上实现LSH索引并分别进行近邻搜索，查询数据集前1000点的前10个最近邻，并统计搜索算法的性能(召回率，准确率，时间)。 局部敏感哈希的思想常规的哈希思想是通过算法将被哈希后的值作为键去索引原来的值，由于根据值是可以算出键的，所以这就给我们的查找带来了方便。通过哈希，我们可以把一个稀疏矩阵紧密存放，但是又不损失索引的速度。 不过哈希函数也有别的用法，例如密码学哈希函数。这类特别的哈希算法旨在用哈希函数实现加密，因此其哈希值难以推出原值，而且对输入敏感，稍加变动就会彻底改变哈希值。此外，其对抗碰撞的要求也很高，因为碰撞意味着加密的不安全。 而局部敏感哈希则反其道而行之，其非常容易发生碰撞。实际上，这种哈希函数的目的是使邻近的值在经过哈希以后依然邻近，或者说干脆就相等了（这一步可以通过把处理后的值取整实现）。因此，通过局部敏感哈希，我们就相当于对数据集中的数进行了一次分类，这样以后需要搜索 KNN 时，我们就不需要搜索整个数据空间而只对与查询值具有相同哈希值的那些点进行计算即可。 当然，哈希函数不能保证所有被映射到一起的值均是邻近的值，因此 LSH 只能是 KNN 的近似算法，不能保证准确。 一个简单的例子是：令哈希函数为 $h((x，y))= x$ ，即 x 轴值。那么 y 轴方向上距离很大的点依然会被错误的认为是邻近点 为了提高准确性，我们可以试着改变哈希算法的一些参数，使得更多的点映射在一起，相当于扩大了“邻近”的范围从而匹配到更多的点。另一方面，我们也可以采用另外一个不同的哈希函数进行运算，看看结果是否会不同。对于多次哈希的结果，我们可以取邻近点的交集，也可以取邻近点的并集，只要参数适当，都可以取得还不错的结果。事实上，由于处理的数据往往维数很大，所以我们都需要采取多个哈希函数。 例如对于上面的例子，我们采用$h((x，y))= y$ 作为第二个哈希函数算法，并且认为只有两次哈希结果均邻近才能算邻近值（取交集），那么 y 轴方向上距离很大的点就不会被认为是邻近点。 前人们已经总结出了许多的哈希函数，针对不同的要求，例如求的是点的什么距离，我们可以采取不同的哈希方法。因此我们可以不自己构造哈希函数。 总结一下，LSH 思想就是：通过构造哈希函数将相邻近的点映射到一起，用多次哈希提高精确度，用查找哈希值索引到可能的最邻近点并计算距离得出近似最邻近点。当参数取得合适，我们就可以保证 LSH 找到 KNN 的准确性可以接受。 性能评估：准确率、精确率、召回率准确率、精确率、召回率是三个容易混淆的概念。 假设我们的问题是在所有样本中找出所有为真的样本。那么对于机器给出的结果，就有“机器判断正确/错误”和“机器判断是真/假”的组合共计四种情况，记前者为 True/False，后者为 Positive/Negative，并简记为TFPN。那么机器就将样本分为了 TN、TP、FN、FP 四种类别。于是： 准确率（accuracy）指机器对多少样本的判断是正确的，即 $\\frac{TP+TN}{TP+TN+FP+FN}$。准确率只在乎判断得对不对; 精确率/查准率（precision）指预测为真的样本中有多少判断是正确的，也就是 $\\frac{TP}{TP+FP}$，精确率要求没有找到错误的真点，不关心有没有漏找; 召回率/查全率（recall）指实际为真的样本中有多少判断是正确的，也就是究竟找（召）回了多少为真的样本，即$\\frac{TP}{TP+FN}$，召回率只关心有没有找全真点，不关心有没有错误的点。 在灾害预报中，我们应该关心召回率，因为每一次没有预测到灾害都会给社会带来巨大损失；但是如果是人脸识别，那么就应该关心精确率，因为无法识别人脸用户可以使用其他方式继续，但是如果错误识别则可能给用户带来损失。 也可以用语言的角度进行理解，准确无疑是指我们判断对了没有，精确则是判读对了多少。因此前者关心整体的判断，而后者只关心预测为真的样本中的判断。 程序的基本结构在这里，我采取的是计算欧几里得距离，这样，我们的哈希函数就可以形如 $$H(x) = floor(\\frac{(\\vec{r}\\cdot\\vec{p})+b}{H_{size}})$$ 其中 $H_{size}$ 是提前指定的值，$\\vec{p}$ 是输入点的向量形式，$b$ 和 $\\vec{r}$ 是哈希函数中的随机偏移量和随机向量，$b$ 的取值范围在 $(0,H_{size})$ 间。向下取整的 floor 函数负责将邻近的值舍入到一起。 在程序的一开始，我们根据需要的哈希数量和 $H_{size}$ 的值随机生成 $b$ 和 $\\vec{r}$。由于矩阵的性质，我们可以直接将前者生成为一维数组，后者为每列一个 $\\vec{r}$ 的矩阵。然后对点进行计算。 得出计算结果后，我们使用字典列表按哈希值进行分类保存。这样索引就算建立完毕了。 搜索时，首先计算待查询值的哈希值，然后查询索引获得候选最邻近点。对不同哈希给出的候选集可以使用并集的方法，也可以采取交集的方法。最后对给出的所有候选点计算欧几里得距离，排序后选出最近的前 K 个点即可。选择并集或者交集需要适当的修改参数，不过总的来说，并集的效果好一些（见后面结果）。 在本例中，主要可以修改的参数是 $H_{size}$ 是哈希函数的数量。前者决定了对计算结果的区分度， $H_{size}$ 越大，被哈希到一起的邻近点就越多,速度就越慢，但是精确度相应提升。后者则可以从不同方向来判断邻近点，哈希函数越多，邻近点就越多，但是速度也同样会变慢。 为了判断精确度和用时，我们还需要构造一份正确答案。可以采取暴力计算的方式进行。将结果作为 JSON 文件存储于磁盘内，就可以加速在判断 LSH 准确性时的速度。 源代码LSH: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import numpy as npimport jsonimport time# region functionsdef get_hash_para(BUKET_SIZE): offsets = np.random.uniform(0, BUKET_SIZE, [1, BUCKET_NUM]) vectors = np.random.random([32, BUCKET_NUM]) return offsets, vectorsdef calc_LSH_indexes(data, bucket_num): &quot;&quot;&quot;&quot; 进行哈希计算并分配到哈希“桶”中\\\\ 哈希公式 H = （（dot（v·r）+b)）/BUCKET_SIZE）\\\\ 其中r是向量，b是一个数 &quot;&quot;&quot; buckets = [&#123;&#125;for _ in range(bucket_num)] # 结果是68040*15，每个向量在每个桶内映射为一个哈希值 mapped_indexes = np.floor( (np.dot(data, hash_vectors)+hash_offsets)/BUCKET_SIZE) # 由（数据向量值的）索引对应的一串桶中的哈希值，转变为桶中的哈希值对应的索引 # 方便由哈希值找索引 for index, hash_keys in enumerate(mapped_indexes): for j, hash_key in enumerate(hash_keys): buckets[j].setdefault(hash_key, []).append(index) return bucketsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def search(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.union( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef search_with_intersection(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近,交集&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.intersection( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef check_accuracy(chk_res, crrt_res): # 如果check-res中的元素在correct-res则append一个ture correct_num = sum([i in crrt_res for i in chk_res]) TP = correct_num FP = K - correct_num FN = K - correct_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # 变量 COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_RES_PATH = &#x27;./multi/4.10NN.json&#x27; BUCKET_NUM = 5 # 提高哈希量：增加准确性降低速度，时间的增加是几乎线性的 BUCKET_SIZE = 1.5 # （降低数值）提高区分度：降低准确性增加速度 K = 10 buckets = [] mean_precision = 0 mean_recall = 0 total_hash_time = -1 total_bf_time = -1 total_pre_time = -1 # 文件读取 data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) with open(CRRCT_RES_PATH, &#x27;r&#x27;) as f: correct_res_set = json.load(f) # 预处理 pre_start_time = time.time() hash_offsets, hash_vectors = get_hash_para(BUCKET_SIZE) buckets = calc_LSH_indexes(data, BUCKET_NUM) total_pre_time = time.time()-pre_start_time # 查询 hash_start_time = time.time() for query in range(0, 1000): # hash print(&#x27;query index:&#x27;, query) res = search_with_intersection(data[query], K) hash_end_time = time.time() # bf bf_res = correct_res_set[str(query)] # 评估 _, precision, recall = check_accuracy( chk_res=res, crrt_res=bf_res) mean_precision += precision mean_recall += recall total_hash_time += time.time()-hash_start_time + 1 # 结果 mean_precision /= 1000 mean_recall /= 1000 print(&#x27;hash used time:&#x27;, total_hash_time, &#x27;hash preprocess time &#x27;, total_pre_time, &#x27; bf used time:&#x27;, total_bf_time) print(&#x27;precision:&#x27;, mean_precision, &#x27;recall:&#x27;, mean_recall) 暴力： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npfrom sklearn.cluster import KMeansfrom scipy.cluster.vq import vqimport jsonimport timefrom sklearn.metrics.pairwise import cosine_similarity# region functionsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def check_accuracy(check_res, correct_res): accurate_num = sum([i in correct_res for i in check_res]) # false_num = K - accurate_num TP = accurate_num FP = K - accurate_num FN = K - accurate_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # variables COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_PATH = &#x27;./multi/4.10NN.json&#x27; K = 10 # 预处理 hash_pre_time = time.time() data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) hash_pre_used_time = time.time()-hash_pre_time # 查询 mean_accuracy = 0 mean_precision = 0 mean_recall = 0 total_hash_time = 0 total_bf_time = 0 bf_res_set = &#123;&#125; for query_index in range(0, 1000): bf_res = [get_distance(data[i], data[query_index]) for i in range(data.shape[0])] bf_res = np.argsort(bf_res)[1: 11].tolist() bf_res_set[query_index] = bf_res print(query_index) with open(CRRCT_PATH, &#x27;w&#x27;) as f: f.write(&#x27;&#123;\\n&#x27;) for i, (key, value) in enumerate(bf_res_set.items()): f.write(f&#x27; &quot;&#123;key&#125;&quot;: &#123;json.dumps(value)&#125;&#x27;) if i &lt; len(bf_res_set) - 1: f.write(&#x27;,&#x27;) f.write(&#x27;\\n&#x27;) f.write(&#x27;&#125;\\n&#x27;) 准确率与参数参考需要说明是，准确性和时间受随机与性能的影响很大，因此以下结果仅作参考。 候选点交集： 交集num：5 size = 1.5 search_time : 350 preicision: 0.94num：5 size = 1.1 search_time : 168 preicision: 0.84num：5 size = 1.0 search_time : 247 preicision: 0.91num：5 size = 1.0 search_time : 119 preicision: 0.84 //这一步可以看到随机对结果和性能的影响num：5 size = 0.5 search_time : 146 preicision: 0.77num：5 size = 0.5 search_time : 100 preicision: 0.77num：5 size = 0.2 search_time : 11 preicision: 0.53num：5 size = 0.1 search_time : 3.39 preicision: 0.25 取并集： 并集哈希一次num：1 size = 0.02 search_time : 18 preicision:0.25num：1 size = 0.05 search_time : 46 preicision:0.50num：1 size = 0.10 search_time : 90 preicision:0.74num：1 size = 0.20 search_time : 169 preicision:0.87哈希三次num： 3 size = 0.02 search_time : 58 preicision:0.60num： 3 size = 0.05 search_time : 153 preicision:0.96num： 3 size = 0.10 search_time : 230 preicision:0.97哈希五次：num： 5 size = 0.01 search_time : 47 preicision:0.49num： 5 size = 0.02 search_time : 86 preicision:0.72num： 5 size = 0.05 search_time : 189 preicision:0.96num： 5 size = 0.10 search_time : 290 preicision:0.997 参考 xducs/多媒体数据处理/LSH.ipynb at main · silence-tang/xducs · GitHub 一文看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"}]},{"title":"多媒体实验3：基于 BOF 进行相似图片搜索","slug":"课程报告/多媒体实验3图片搜索","date":"2023-06-12T21:10:47.000Z","updated":"2023-07-04T10:20:55.014Z","comments":true,"path":"2023/06/13/课程报告/多媒体实验3图片搜索/","link":"","permalink":"http://example.com/2023/06/13/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AE%9E%E9%AA%8C3%E5%9B%BE%E7%89%87%E6%90%9C%E7%B4%A2/","excerpt":"前言BOF算法是一种通过特征来实现图像检索或分类的算法。","text":"前言BOF算法是一种通过特征来实现图像检索或分类的算法。 目的/要求使用BOF算法，在数据集上实现以图搜图：即输入数据集中某一张图，在剩下的999张图里搜索最邻近的10张图。数据集是按文件夹放好的 10 * 100 张 jpg 图片。 什么是BOFBOF，bag of features 是由自然语言处理领域的 BOW（bag of words）引申而来的。BOW，用一个袋子装起了一个个词，顾名思义就是用（关键）词为单位去处理文章句子。引申到图像领域，就用特征（feature）代替了关键词（words），即通过处理特征来处理图像。 具体地说，BOF的思想是这样的：每个图像的特征多少不一而足，我们将这些特征进行归类，就可以把一个的图像转化“有多少个xx”类特征这样的表述，从而方便计算和表述。这个过程就像是把图像的特征扔进一个个袋子里分类，即 bag of features。 而这就有了三个子问题：1.特征哪来？2.袋子哪儿来？3.咋扔？ 特征的来源很多，我们可以使 SIFT 特征，但是使用其他的特征也并非不可，例如 HOG 等。 袋子哪儿来？袋子并不是凭空出现的。而是根据数据集中的特征进行归类归出来的。这是一个把数据归类的问题，我们可以使用 KMeans 聚类算法把所有的数据归为人指定的 K 类。（K的值可能需要不断调整到最佳值） 扔进袋就是给一个查询点，将其放到最近的袋子中。我们可以使用 scipy 中 vq 来完成这一步。 这样，我们就完成了对一个数据集的初步 BOF 处理。 不过，为了更准确地进行搜索，我们还引入了 TD-IDF 对“单词”进行加权。 TI-IDF想象一下下面两种情况： 在国际新闻中以“美国”为关键词进行搜索：搜索结果数量纷繁。 在国际新闻中以“贸易战”为关键词进行搜索：搜索的结果基本都和近年“中美贸易战”密切相关。 如果我们的目标是查询“2018年中美贸易战”有关的新闻报道，那么“贸易战”是比“美国”更重要的关键词。这是因为“美国”在几乎所有的文章中都频繁出现，而“贸易战”只在贸易战有关的新闻中频繁出现。 为此我们使用 TI-IDF进行评估。TF(term frequency)是某一个词语在一个文件中出现的频率，即词频。IDF（inverse document frequency，逆向文件频率）则衡量一个词语在所有文档中出现的频率。TF-IDF计算方法为： $TF=\\frac{文档中该词数量}{文档总词数}$ $IDF= lg\\frac{文档总数}{包含该词的文档数}$ $TFIDF= TF\\times IDF $ 只有在特定文件中高，但是在整体文件中低的词语，才能取得较高的TF-IDF值。 我们使用 TF-IDF 加权以后的特征来进行搜索以提高准确率。 程序的基本结构有关功能基均有库可调，下面简单叙述我的程序中的各个函数。 get_dictionary()，读入图片，用 opencv 计算 SIFT特征。取特征的描述子使用 sklearn 中 KMeans 聚类，取聚类中心代表类。完成这一步，就相当于我们已经造好了“袋子”并找到了“词”。 corel_bof()：遍历前面保存的词，判断各个词最近的袋子是什么。并把结果存入一个 numpy.histogram 直方图中。这就相当于我们已经把词扔进了袋子，以后就可以用直方图代表此图片了。 tf_idf()：使用 sklearn 对直方图进行 TF-IDF 加权。 以上的步骤耗时较长，而且一经处理不再变动。因此可以将其导出为 JSON 或其他文件，方便后续使用。搜索时则： search_similar()：对搜索图片同样进行上述三步处理。得到结果使用 sklearn 中 cosine_similarity计算其与我们的数据集的 TI-IDF 的余弦相似度。对其排序后返回最相近结果的前 K+1 个。因为我们的图片均来自数据集，因此最像的肯定是自己。 show_result：使用 pillow 显示最像的前 K 个图片。 程序中的一些小点 读入图片可以使用 glob.glob() 递归查找文件目录下的所有图片。 SIFT 的结果只要其中的描述子，这是因为关键点仅包含坐标信息，描述子才真正的表示了一个特征。我们所有的操作都是对描述子进行的。 cv2.imread 默认读入彩图是 BGR 格式，这会导致图片泛蓝。搜索和计算时这并不怎么影响，但是输出时就需要转为 RGB 格式或者直接用 pillow 的 Image.open()。 各个函数的格式要求不一，所以能见到反复转格式。特别是导出为 JSON 时需要转 NDArray 为 list。因为 JSON 是内置的库，但是 numpy 可不是。 试着使用了# region 来折叠代码，不过这不同于 C#，这并不是 python 本身提供的支持。我仅在 VScode 上验证可用。 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import numpy as npimport cv2import globimport jsonfrom PIL import Imagefrom scipy.cluster.vq import vqfrom sklearn.cluster import KMeansfrom sklearn.metrics.pairwise import cosine_similarityfrom sklearn.feature_extraction.text import TfidfTransformer# debugcorel_path = &#x27;./multi/corel/&#x27;query_img_path = &#x27;./multi/query.jpg&#x27;dict_file_path = &quot;./multi/dictionary.json&quot;bof_file_path = &quot;./multi/bof.json&quot;tfidf_file_path = &quot;./multi/tf-idf.json&quot;bag_of_features = []features = []tfidf_feature = []# region preProcessdef get_dictionary(mode): &quot;&quot;&quot; 根据图像生成特征字典：一共有这么多的特征。\\\\ 包含SIFT和KMeans两步 &quot;&quot;&quot; if (mode == &quot;load&quot;): with open(dict_file_path, &#x27;r&#x27;) as f: dictionary = np.array(json.load(f)) return dictionary progress = 0 for imgpath in glob.glob(corel_path+&#x27;*/*.jpg&#x27;): img = cv2.imread(imgpath) # 显示进度 print(&quot;load a pic success:&quot;+(progress+1).__str__()+&quot;/&quot;+&quot;100&quot;) progress += 1 # 获取img的所有描述子,不需要关键点 _, des = cv2.SIFT_create().detectAndCompute(img, None) features.append(des) # vertical stack,垂直堆叠二维数组 all_features = np.vstack(features) # KMeans对象对 all_features 聚类 k = 64 kmeans = KMeans(n_clusters=k, max_iter=300, n_init=10) kmeans.fit(all_features) # 词典即聚类中心 # k*128的二维数组 dictionary = kmeans.cluster_centers_ if (mode == &quot;save&quot;): with open(dict_file_path, &#x27;w&#x27;) as f: # ndarray不能直接输出为json json.dump(dictionary.tolist(), f) return dictionarydef corel_bof(dictionary, mode): &quot;&quot;&quot; 表示出每个图片包含特征字典中的哪些特征&quot;&quot;&quot; bag_of_features = [] if (mode == &#x27;load&#x27;): with open(bof_file_path, &#x27;r&#x27;) as f: bag_of_features = np.array(json.load(f)) return bag_of_features # 遍历所有描述子 for des in features: print(&quot;gennerated a des\\n&quot;) # 使用vq获得图片每个描述子最近的聚类中心（属于哪个聚类中心） code, _ = vq(des, dictionary) # 生成到直方图并归一化 # .shape[0]聚类中心的数量 hist, _ = np.histogram(code, bins=range(dictionary.shape[0]+1)) hist = hist/np.sum(hist) # 添加到列表中1000*64维 bag_of_features.append(hist) if (mode == &quot;save&quot;): with open(bof_file_path, &#x27;w&#x27;) as f: json.dump([arr.tolist() for arr in bag_of_features], f) return bag_of_featuresdef tf_idf(): &quot;&quot;&quot;&quot; 计算TF-IDF\\\\ TF值 = 词在文档中出现的次数 / 文档总词数\\\\ 逆向文件频率：IDF值 = log（语料库中包含某个词的文档总数 / 语料库中文档总数）\\\\ 每个词在每篇文档中的TF-IDF值：TF值*IDF\\\\ 在这篇“文章”中出现得多的且其他文章出现得少的“词”，才是能标明它身份的“词”\\\\ 大部分人都有的特征不算\\\\ &quot;&quot;&quot; # list[NDArray]-&gt;NDArray-&gt;稀疏矩阵-&gt;NDArray-&gt;list # 通过NDArray转化为list以输出 tfidf_feature = TfidfTransformer().fit_transform( np.array(bag_of_features)).toarray().tolist() with open(tfidf_file_path, &#x27;w&#x27;) as f: json.dump(tfidf_feature, f) return tfidf_feature# endregiondef searchSimilar(queryIMG, dictionary): # 对单个图像的ti-idf处理 _, m_des = cv2.SIFT_create().detectAndCompute(queryIMG, None) query_code, _ = vq(m_des, dict) query_hist, _ = np.histogram(query_code, bins=range(dictionary.shape[0]+1)) query_hist = query_hist/np.sum(query_hist) query_hist = np.array(query_hist).reshape(1, -1) query_tfidf = TfidfTransformer() query_tfidf = query_tfidf.fit_transform(query_hist).toarray() # reshape(1, -1)：转化为长度为一行的二维数组 # 返回1*1000的二维矩阵similarity similarity = cosine_similarity(query_tfidf.reshape(1, -1), tfidf_feature) top10_indices = np.argsort(similarity[0])[-11:][::-1] print(top10_indices) return top10_indicesdef show_result(result_array): imgs = [] total_width = 0 max_height = 0 for idx in result_array: img_path = corel_path+str(idx//100)+&quot;/&quot;+str(idx)+&quot;.jpg&quot; img = Image.open(img_path) imgs.append(img) total_width += img.width max_height = max(max_height, img.height) # 创建拼接后的图像 result_image = Image.new(&#x27;RGB&#x27;, (total_width, max_height)) # 拼接所有图像 x_offset = 0 for image in imgs: result_image.paste(image, (x_offset, 0)) x_offset += image.size[0] # 显示拼接后的图像 result_image.show()if __name__ == &#x27;__main__&#x27;: # load or save file_op = &quot;load&quot; # 字典、bof和tf-idf的获取 dict = get_dictionary(mode=file_op) bag_of_features = corel_bof(dict, mode=file_op) tfidf_feature = tf_idf() # 查询 query = cv2.imread(query_img_path, cv2.IMREAD_COLOR) result = searchSimilar(query, dict) # 结果 show_result(result) 参考资料 new bing 你是我爹","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"}]},{"title":"云计算实验：在 Windows 平台搭建 Hadoop","slug":"课程报告/Hadoop构建","date":"2023-05-23T11:00:56.000Z","updated":"2023-07-04T10:32:41.409Z","comments":true,"path":"2023/05/23/课程报告/Hadoop构建/","link":"","permalink":"http://example.com/2023/05/23/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/Hadoop%E6%9E%84%E5%BB%BA/","excerpt":"云计算课程大作业：在本机配置一个 Hadoop 环境","text":"云计算课程大作业：在本机配置一个 Hadoop 环境 准备工作Hadoop 有三种运行模式：本地、伪分布、完全分布。由于这只是一次实验，我选择的是在本机搭建运行 Hadoop 的伪分布模式。此模式下，Hadoop 守护进程运行在本地机器上，模拟一个小规模的集群，形式上与完全分布相同，使用不同端口代表不同的机器。 我选择的平台与版本如下： Windows 11 Java 16.0.1 winutils 3.3.1 Hadoop 3.3.5 实验过程下载在 Apache 官网下载 Hadoop 的已编译版本，解压至指定目录（此处是 C:/Hadoop）中。 由于我已经装了 Java，所以本次实验我省略安装 Java 的步骤。 由于 Windows 不是 Hadoop 的最初开发和运行平台，目前支持还较为有限。为此，需要额外下载工具 winutils。此工具最初由官方社区开发者维护，但是较新版本来自开发者 github/kontext-tech。下载后放入 C:\\hadoop\\bin 文件夹内并复制一份hadoop.dll放到C:\\Windows\\System32下。yarn 已内置于此工具内。 配置文件新建环境变量 HADOOP_HOME 指向 Hadoop 文件夹。Path添加 Hadoop 文件夹下 \\bin 和 \\sbin 文件夹的地址。完成后可以在终端内通过hadoop version检查是否能被正常识别且无错。 在 \\Hadoop 文件夹下新建文件夹如下： \\tmp \\data\\datanode \\data\\namenode 在 \\Hadoop\\etc\\hadoop 文件夹下,修改 core-site.xml 文件如下： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/hadoop-3.1.3/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://your_host_name_or_localhost:9123&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同文件夹下，，修改 hadoop-env.cmd 中的 Java_home 项的值为环境变量中 JAVA_HOME 的值，即指定 JDK 地址。 修改 hdfs-site.xml 文件如下，指定节点数量和实际存储地址。 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/C:/hadoopdata/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改yarn-site.xml 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hahoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 特别地，在完成上述步骤后我遇到了端口冲突的问题，为了解决此问题，在 hdfs-site.xml 文件中继续添加参数如下: 123456789101112&lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9856&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.http.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9857&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9858&lt;/value&gt; &lt;/property&gt; 格式化与启动在终端中输入 1hdfs namenode -format 进行节点格式化。观察到输出末尾有namenode has been successfully formatted 字样即格式化成功。 随后启动 \\hadoop\\sbin 目录下的 start-all.cmd。如果一切正常，那么将会弹出四个终端窗口且无报错。此时即已正常运行 Hadoop。 检查在浏览器输入 localhost:9857 和 localhost:9856，访问 datanode 和 namenode。 使用 hadoop fs -put &lt;local_file&gt; &lt;hdfs_destination&gt; 命令上传文件、hadoop fs -get &lt;hdfs_file&gt; &lt;local_destination&gt;下载文件。创建文件夹（-mkdir）、列出文件（-ls）、删除文件（-rm）等命令与 Linux 系统相似。可以 在namenode中可以观察到上传成功，也可以使用 -ls 命令检查。 遇到的各种问题 winutils 的版本问题 最早的 Wintils 是由 Stevelougran开发的，他是 Hadoop 的提交者（committer）之一。由于忙碌，此仓库停留在了 3.0.0 版本，而后cdarlint继续开发并停留在了 3.2.2 版本，而kontext-tech继续在Fork cdarlint 后开发。 与本次作业的 Hadoop 版本（3.3.5）最接近的是 kontext-tech 的 3.3.1 版本，本次使用的就是此版本。经验证，能正常工作。 yarn --version 无结果 winutils 中包含了运行 Hadoop所需的 yarn，但是这一过程中我们没有给 yarn 配置环境变量，运行上述命令不成功。不过 yarn 实际上已经可以正常运行了。我们可以使用 where yarn（cmd）或where.exe yarn(powershell)来检查 yarn 存在的位置。 JAVA_HOME 的配置细节 需要注意的是，在 cmd 文件中 JAVA_HOME 指向使用的 Java 的地址。此地址不应该包含空格也不能通过打双引号的方式规避空格问题。二者的报错不一样但是均会有影响。前者为”Error JAVA_HOME is incorrectly set.”,后者为”The filename, directory name, or volume label syntax is incorrect hadoop” 针对空格源自 Progame files 的情况，可以通过改写为 PROGRA~1 来表达含义同时规避空格问题。（这是由于早期文件夹名不能包含空格引起的） 此外，电脑上还可能含有多个 Java 版本。通过如问题2所述 where 语句，我们可以检查到底有几个 Java 版本，在环境变量中调整顺序，使得需要的版本最前，即可保证 Java --version的检查结果和后续使用的是同一个版本。 格式化时结尾为”SHUTDOWN_MSG: Shutting down NameNode at xxxx” 这是正常现象，只要在其上可以找到namenode has been successfully formatted即可。 start-all.cmd 时出现”error Couldn’t find a package.json file in \\hadoop-2.7.7\\sbin”错误 这一错误是由于有多个 yarn 引起的。例如 winutils 中包含了 yarn 而自己随后又通过 npm 安装了yarn。我选择了暂时卸载后者即可解决问题。 端口被占用 正常来说，我们可以通过杀死对应端口进程来结束占用。检查端口被进程占用的方法是终端中输入netstat -aon|findstr [端口号] 。然后结束对应进程（如果无返回结果则说明此端口无占用）。 但是奇怪的是我一开始并没有发现有什么进程占用了端口。不过通过上述第二部分改端口配置，可以成功解决 namenode 的端口占用问题。而 datanode 则还加了一次重启的步骤。 运行 start-all.cmd 后，可以通过使用 netstat -aon|findstr [端口号] node 对应端口号的方式确定程序在正常工作：各端口均有一个进程。 一个建议：在配置过程中，不免频繁输入各类命令：例如不断运行 start-all.cmd 同时检查进程。这个过程中可以善用 Windows 终端的多窗口功能，将命令进行分类，使得窗口更加美观。不过，更改了环境变量以后，需要重新打开终端（而非shell）来使其生效。+ 参考资料 WIN10安装配置Hadoop-知乎 如何在windows系统下安装hadoop-CSDN Install Hadoop 3.3.0 on Windows 10 Step by Step Guide hadoop中修改端口号-李悠然-博客园","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算（课程），实验报告","slug":"云计算（课程），实验报告","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%88%E8%AF%BE%E7%A8%8B%EF%BC%89%EF%BC%8C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"《第一行代码》笔记","slug":"AndroidNotes","date":"2023-05-13T12:00:39.000Z","updated":"2023-05-13T13:14:03.795Z","comments":true,"path":"2023/05/13/AndroidNotes/","link":"","permalink":"http://example.com/2023/05/13/AndroidNotes/","excerpt":"注意这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。","text":"注意这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。 结构 Android视图不是真实视图但是屏蔽的文件基本无需修改。 project 目录下主要关心 app 文件夹。app 文件夹下 java：代码文件夹 res：图片、布局等资源 AndroidManifest.xml：项目配置文件 libs：第三方包 AndroidTest：测试","categories":[{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"从 &a+1 说起————数组变量、&和+运算符","slug":"数组名与指针与右值","date":"2023-04-20T15:04:57.000Z","updated":"2023-04-20T15:08:57.535Z","comments":true,"path":"2023/04/20/数组名与指针与右值/","link":"","permalink":"http://example.com/2023/04/20/%E6%95%B0%E7%BB%84%E5%90%8D%E4%B8%8E%E6%8C%87%E9%92%88%E4%B8%8E%E5%8F%B3%E5%80%BC/","excerpt":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？","text":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？ &amp;a+1 == ? 这个问题由和同学聊到这个标题而来，其中 a 是一个数组的名字。 一开始我想当然地认为：&amp;a 取得数组首地址，+1 指向数组首地址的下一个地址（字节）。但是事实并非如此，事实上，上面这个算式指向的数组末尾地址 +1 的那个地址。 为了搞懂这个问题，必须要理解一个在这之前的学习中被忽略的问题，即：数组是什么类型？int 型变量和 int 型数组和长度不同的 int 型数组，属于相同的变量类型吗？进而，我了解到了引用、左值与右值、以及关于指针的一些知识。 开始探索吧。 测试代码 我们以 c++ 来讨论这个问题，为此，定义变量并写下测试程序如下，我们稍后解释测试结果： 1234567891011121314151617181920212223// 数组int a[5];// 非数组变量int t = 2;int *p = &amp;t;// 引用int n = 4;int &amp;nn = n;// 数组值、大小printf(&quot;value: %d %d %d %d %d %d\\n&quot;, a, &amp;a, a + 1, &amp;a + 1, (int *)&amp;a + 1, (char *)&amp;a + 1);printf(&quot;sizeof: %d %d %d %d\\n&quot;, sizeof(a), sizeof(&amp;a), sizeof(a + 1), sizeof(&amp;a + 1)); // 20 8 8 8cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(a + 1).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a + 1).name() &lt;&lt; endl;// 变量cout &lt;&lt; &quot;\\nsingle\\nvalue: &quot; &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p + 1 &lt;&lt; endl;cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(&amp;p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(*p) &lt;&lt; endl;cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(*p).name() &lt;&lt; endl;// 引用cout &lt;&lt; &quot;\\n变量引用\\ntype: &quot; &lt;&lt; typeid(n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(nn).name() &lt;&lt; endl; 在上述代码中，我们使用了 sizeof 来检查输出变量的大小，typeid 运算符检查变量的类型。typeid 的 name 方法输出变量类型的名字。如下解读：A 指代 array，i 指代 int 型，P指代 pointer。其他的没有出现在输出中。 它的输出如下： 1234567891011value: 6487488 6487488 6487492 6487508 6487492 6487489sizeof: 20 8 8 8type: A5_i PA5_i Pi PA5_isinglevalue: 0x62fdb8 0x62fdbc 0x62fdb0 0x62fdb8 2 3sizeof: 8 8 4type: Pi PPi i变量引用type: i Pi i 对测试结果的解释 数组变量和数组退化 在定义一个数组变量，编译器将为数组分配一块连续的地址空间，并且产生一个数组变量 a。在这里，a 是数组名，也即所谓数组变量。数组变量是一种特殊的变量类型，它包含有【数组长度】个【数组单元变量类型】的变量。例如，我们的数组变量 a 就是包含了 5 个 int 型单元的数组变量。它不是一个 int 型变量，也不是含糊其辞的数组型变量。在我们是输出结果中，这被写作A5_i。 在很多情况中，数组变量 a 的表现和一个指向 a[0] 的指针一样，但是它们并不一样：指针不包含长度信息。很显然数组变量指明了数组的长度，但是一个指针并不清楚自己指向了一个数组单元还是一个变量。从数组变量变成指针，我们称之为“数组退化”。 “数组退化”的发生情况很多，最常见的一种是把它作为参数传入以后。为什么要这么设计很好理解：不同长度的数组是不同类型的变量，如果不退化成指针，写函数时就必须指定数组的长度，这很不方便。如果退化成指针，我们只需要再加一个参数指明数组长度就可以解决问题。 左值和右值 另一种会导致数组变化的原因是将其作为了右值。 左值和右值是 c++11 引入的特性。左值指能在内存寻址的值，右值则不是。我们用下面这个例子进行区分： 12int i;i= 12; 很明显我们不能说 12 存储在内存上的哪儿，但是可以说出 i 在内存的地址。 下面是数组变量因为作为右值而退化的例子（或者说，我们认为编译器在这里把数组名解释成了指向数组头的常量指针）。 123int a[5];a++;int *b = a+1 特别需要注意的是，尽管对左值进行自增操作是允许的，但是上面的 a++ 写法事实上是错误的，因为数组变量指向的地址是不可修改的。这也是为什么我们说它退化后是常量指针。 另外一个有意思的地方在于 a++ 和 a 一个返回右值一个返回左值。这是因为 a 操作先取得 a 的值，再返回 a 的值，最后把加一的值赋给 a ，++a 则完成了赋值操作再返回。这导致前者返回的值事实上不是 a 地址的值，所以只是右值。 关于 &amp; 符 &amp; 运算符有两种用法，第一种是取地址，第二种是取引用。 取地址当然就是取得变量地址，这意味着两件事：第一，它的右侧必须跟着一个左值；第二它返回的值的类型是指向某个地址的变量————即指针。 另一种引用是引用。引用相当于给 n 变量取了一个别名 nn。如果改变 n 的值，也就改变了 nn的值。这两个变量的地址是完全一样的，这不同于定义一个指针。nn 并不是一个指针，它和 n 有相同的变量类型和地址。 前面提到了 a++ 和 a ，而 &amp;a 和 &amp;++a 都是错误的，但是原因并不相同。前者是因为返回了右值，后者是因为视图修改常量指针。 指针的 + 运算 指针的 + 运算会得到不同的结果。具体来说就是，指针 +1 时，指的并不是地址 +1 字节，而是 +1 指针指向的变量大小单元。如果是 int 型指针，那么 +1 指的就是 4 字节，如果是 char 型，就是 1 字节。 如前所述，数组是数组类型而不是指针。所以一个指向数组的指针 +1 ，并不是加一个指针大小（64位系统上是 8 字节），而是加一个数组长度。首地址加数组长度，很显然指向的就是数组地址的尾地址 +1 了。 我们通过一个简单的小测试来验证这个说法：输出(int*)&amp;a+1和(cahr*)&amp;a+1。可以发现前者是在首地址基础上 +4，后者是 +1.这是因为数组变量型指针在 +1 前被转换成了 int型和 char 型，从而影响到了后续的 +1 操作的含义。 一个有趣的事情是，+ 运算符的优先级高于 &amp; 运算符。但是在 &amp;a+1 中会先执行 &amp; 运算，这是因为如果先执行 + 运算，返回的右值无法进行 &amp; 运算，出现语法错误，所以编译器隐式转换成了（&amp;a）+1。 总结 这里是前面的总结。 a:数组变量，直接输出得到其存储的数组起始地址。 a+1:数组变量退化成指向数组起始地址的指针常量，再加一个数组内单位长度 &amp;a：取数组变量的地址，会得到值是数组变量的起始地址，但是数据的类型是数组变量型指针 &amp;a+1：等价于 (&amp;a)+1，因此是数组变量地址的邻接地址 &amp;a++:错误,a++ 返回右值，返回值不是真正 a 的值，违反了 &amp; 的要求 &amp;++a:错误,++a返回左值，但是数组变量指向的地址不可修改 &amp;(a+1):错误，a+1是右值 （int*）&amp;a+1: 将数组变量类型指针转换为int型指针再加一个单位","categories":[{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"多媒体实验2：PCA主成分分析","slug":"课程报告/多媒体实验2PCA","date":"2023-04-10T14:47:38.000Z","updated":"2023-07-04T10:20:25.740Z","comments":true,"path":"2023/04/10/课程报告/多媒体实验2PCA/","link":"","permalink":"http://example.com/2023/04/10/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AE%9E%E9%AA%8C2PCA/","excerpt":"前言PCA（Principal Component Analysis）是一种常用的数据分析方法。","text":"前言PCA（Principal Component Analysis）是一种常用的数据分析方法。 从数据压缩说起正如本课的课名所指出的,本课探究的是计算机对多媒体数据的处理分析过程。这个过程中，我们将人类看得懂的各类信息（声、图、文、语言等）输入计算机，期望计算机能对”信息”进行分析，进而发现”知识”，从中学习或者获得智能。把信息在人类载体（上述声、图、文、语言等）和机器载体（比特）之间变换的过程，就是编码和解码。数据压缩，就是在编码的过程中将庞杂的信息转化为更简短和信息，进而方便处理。 例如，对信息 111444444999995，我们可以记为 1#3 4#6 9#5 5#1 从而起到压缩的作用 在这个过程中可以注意到，不是所有的信息都具有相同的价值。压缩数据时，我们希望保留那么有价值的数据，而舍弃那些几乎没有关联的数据。这就带来了如何判断一个数据是否可以被舍弃的问题。 例如人的视觉和听觉中，对高频细节不敏感，可以在变换过程中滤除高频系数，保留低频系数，从而减少数据量。减少处理的难度。一个有名的例子是傅里叶变换。 我们首先定义数据的表示方式，我们记一条数据为一个向量，它的每一维都是一个类别的数据。我们希望对它进行处理，使得向量的维度尽可能的少，同时信息丢失尽可能的少。这个过程被称之为”数据降维”。 如果一个电商平台提供了浏览量和购买量两个数据，二者肯定不等价，但是浏览量高的店铺成交量往往更高。所以我们可以考虑舍弃其中一个数据，这样我们依然可以较好的衡量一个店铺的经营状况。 对此，我们可以采用 PCA。 PCA的思路——–重新发现空间变换我们已经知道 PCA 的目标是数据降维。接下来我们看看是如何做的。开始之前，我们先规定，一条数据是一个向量，多条数据排列就形成了一个矩阵。我们以矩阵为基本单位进行讨论。 以二维空间为例，如果对一个数据集，其点大致分布在直线 y=x 附近。我们可以想到，采用以 y=x 为轴而非 x、y 为轴的话，表示会更加简单。我们忽略 y=-x 方向上的量，把点投影到 y=x 上，此时仍可以基本保持原来的形状，同时，原来二维的数据被降维到了一维。 在这个过程中，我们进行了数据降维。本质上是把一个二维空间给变换到了一个一维空间。在线代中我们已经明白可以采取矩阵乘法进行变换。问题的关键是：我们已知需要变换到 K 维空间。如何选择此 K 维空间的基呢？即如何确定变换矩阵？ 具体来说，我们可以认为两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。 我们的目标是变换后尽量保留最多的原始信息。对此，一种直观的看法是：希望投影后值尽可能分散。 方差与协方差高中阶段我们就已经知道，数学上使用方差来表达分散程度的概念。方差可以被如下表示： $$Var(a)=\\frac{1}{m}\\sum_{i=1}^m{(a_i-\\mu)^2}$$ 预先对矩阵进行处理使得均值为 0 ，则有 $$Var(a)=\\frac{1}{m}\\sum_{i=1}^m{a_i^2}$$ 多个维度中，我们希望尽可能多的表示原始信息，所以维度之间不应该存在相关性，否则它们的信息就会有重复。我们使用协方差衡量相关性。 $$Cov(a,b)=\\frac{1}{m}\\sum_{i=1}^m{a_ib_i}$$ 相互之间协方差为 0 时，相关性最弱。所以我们需要选择相互之间协方差为 0 且字段方差尽可能大的一组向量作为基底。 在数学上，有：设 m 个 n 维数据记录排列成 $n\\times m$ 的矩阵X，而 $$C=\\frac{1}{m}XX^\\mathsf{T}$$ 则 C 是一个对称矩阵。其对角线分别个各个字段的方差，而第 i 行 j 列和 j 行 i 列元素相同，表示 i 和 j 两个字段的协方差。 由前面的分析可知，我们使 C 非对角线为 0（协方差为 0 ），对角线由上到下递减。那么我们选取 X （而非 C ）的前 K 行，就得到了我们需要的变换矩阵。我们对 C 操作的这个过程被叫做矩阵的对角化。 现在问题变成了：如何使协方差矩阵对角化？ 特征值一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量，设这n个特征向量为 $e_1,e_2,\\cdots,e_n$ ，我们将其按列组成矩阵 E。对特征向量矩阵 E 和协方差矩阵 C，有： $$ E^\\mathsf{T}CE =\\Lambda =\\begin{pmatrix} \\lambda_1 &amp; &amp; &amp; \\ &amp; \\lambda_2 &amp; &amp; \\ &amp; &amp; \\ddots &amp; \\ &amp; &amp; &amp; \\lambda_n \\end{pmatrix} $$ 进而我们需要的矩阵 P 有： $$P=E^\\mathsf{T}$$ P 是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是 C 的一个特征向量。如果设P按照 $\\Lambda$ 中特征值的从大到小，将特征向量从上到下排列，则用 P 的前 K 行组成的矩阵乘以原始数据矩阵 X ，就得到了我们需要的降维后的数据矩阵 Y 。 总结总结 PCA 的思路。 目的：我们需要数据压缩，为此，将数据进行降维，删去那些没有带来额外信息或者带来信息极少的维度，即数据降维。 投影：我们将 M 维数据尽可能分散地投影到 K 维空间上。因为越聚集就代表投影以后（该方向）丢失的信息越多，得到的数据的信息越趋同。着我们尽可能让每个点的信息都被记录下来就需要分散。 例如: 在纸上画出一个立体图像的时候，我们会选用一个倾斜的角度展现三个面，而不是三视图中的一个面； 三维空间的直线投影到二维应该最好是投影成直线而不是一个点。 我们使用方差来衡量一个方向的数据分散程度，使用协方差来保证每个方向都是正交（相关性低）的。 我们使用特征值向量矩阵选取协方差矩阵中方差最大的 K 个正交方向（主成分），再把原始数据变换刚刚求出的 K 维空间中去即可。 PCA的具体步骤我们可以把上述过程总结为下述步骤： 设有 m 条 n 维数据，我们将其排成 n 行 m 列（ n*m ）的矩阵 X，按一下步骤对齐进行 PCA： 将X的每个属性字段进行零均值化，即减去这一列的平均值（如果我们排成 m 行 n 列，也可以是减去行的均值）。 求出协方差矩阵 $C=\\frac{1}{m}XX^\\mathsf{T}$ 求出协方差矩阵的特征值及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 k 行组成矩阵 P 对 X 左乘矩阵 P，有 $Y=PX$ 即为降维到k维后的数据。 PCA的python实现我们可以使用 numpy 进行矩阵计算；使用 pandas 读取 ASC 文件中的数据 此外，scikit-learn 库中的 PCA 模块可以直接实现 PCA，我们可以使用它验证我们的代码。 具体来说，我们使用到了 numpy 的以下方法： np.mean() :求解行/列均值用于零均值化 np.dot(): 点积运算 instance.shape:获取行数、列数等数据 np.linalg.eig()：特征值 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport pandasdef PCA(x, k): # n维n列 # m条m行 # m*n的矩阵 # 1\\. 形成样本矩阵，样本零均值化 # 压缩0轴（行），得到1轴（列）的均值 mean mean = np.mean(x, axis=0) x -= mean # 2\\. 计算样本矩阵的协方差矩阵 x_col = x.shape[1] cov = np.dot(x.T, x)/x.shape[0] # 3\\. 对协方差矩阵进行特征值分解 eig_vals, eig_vecs = np.linalg.eig(cov) # 对应特征值与特征向量 eig_pairs = [] for i in range(0, x_col): eig_val_i = np.abs(eig_vals[i]) eig_vec_i = eig_vecs[:, i] eig_pairs.append((eig_val_i, eig_vec_i)) # 选取最大的p个特征值对应的特征向量组成投影矩阵 eig_pairs.sort(reverse=True) feature = [] for i in range(0, k): feature.append(np.array(eig_pairs[i][1])) # 4\\. 对原始样本矩阵进行投影，得到降维后的新样本矩阵 reduced_data = np.dot(x, np.transpose(feature)) return reduced_dataFILEPATH = &quot;D:\\DocumentsSet\\ColorHistogram.asc&quot;data = pandas.read_csv(FILEPATH, sep=&#x27; &#x27;, header=None, index_col=0).valuesresult = PCA(data, 5)print(result) 参考资料 CodingLabs - PCA的数学原理","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"多媒体实验1：算术编码的 python 实现","slug":"课程报告/多媒体实验1算术编码","date":"2023-04-06T14:59:08.000Z","updated":"2023-07-04T10:20:42.114Z","comments":true,"path":"2023/04/06/课程报告/多媒体实验1算术编码/","link":"","permalink":"http://example.com/2023/04/06/%E8%AF%BE%E7%A8%8B%E6%8A%A5%E5%91%8A/%E5%A4%9A%E5%AA%92%E4%BD%93%E5%AE%9E%E9%AA%8C1%E7%AE%97%E6%9C%AF%E7%BC%96%E7%A0%81/","excerpt":"前言算术编码是一种编码算法，它比哈夫曼编码更高效。","text":"前言算术编码是一种编码算法，它比哈夫曼编码更高效。 由哈夫曼编码说起哈夫曼编码对于更高频的符号，使用更短的编码。由于编码的前缀是不一致的（短编码不是长编码的前缀），所以我们可以保证唯一确定一个编码的长度不发生混淆。 可以通过构造一个特殊的二叉树的方式求哈夫曼编码，这个树就是哈夫曼树。下面是一个哈夫曼树示例。 香农的信息熵公式指出 $$H(x)=-\\sum\\limits_{x} P(x)log_{2}[P(x)]$$ 其中 $H(x)$ 为信息熵， $P(x)$ 为每个符号出现的频次（概率）。 哈夫曼采用整数进行符号编码的，使得其不能更好的逼近信息熵极限。 例如，如果 A 的出现频次是 0.5，B 的出现频次是 0.4，C 的出现频次是 0.1。那么我们应该期待 B 的编码长度接近于 A，而不是 C，但是事实上 B 的编码长度和 C 一样长，是 A 的编码的两倍长。因此，其达不到最佳的编码长度。 一个更好的办法是：改用算术编码。 算术编码的原理算术编码的本质思想，也是对于高频的字符进行短编码。但是具体实现并不相同。 设想一个区间被划分若干段。任给一个数字，通过比较我们就不难判断出其属于哪一个段。现在我们统计每个字符的频次，并将其依次对应到 $[0,1)$ 区间内同样长度的一段内。编码一个字符，我们就找出对应的区间，并把区间内的一个数字作为编码值，就能唯一确定这个编码。 例如: 假设对字符 A、B、C，有 P(A) = 0.5 P(B) = 0.4 P(C) = 0.1 则对应到区间如下 $A:[0, 0.5)\\ B:[0.5, 0.9)\\ C:[0.9, 1)$ 假设有编码值 E = 0.75，由于 0.75 在区间 $[0.5, 0.9)$ 之间，所以对 E 进行解码就有解码值 D = “B” 在一个字符串内，我们重复这个过程，每次都在之前的编码区间内继续按比例进行划分。这样，我们就得到了为一确定了一个区间可以代表原来的文本。在区间里，按”取二进制值最短的数作为编码值”的原则取编码，就能得到算术编码的编码值。 解码的时候，我们进行上述操作的逆操作即可：不断划分区间，看编码在那个区间内，就继续对齐划分区间。 特别需要注意的是，在取编码值的时候，我们只考虑其编码值最短，这会引起一个解码时的问题，即我们不知道能解码多少位。因为所有以 MSG 为前缀的信息 MSG’ 都处在 MSG 的编码区间内，我们难以确定是否 E 是 E(MSG),还是 E(MSGA) 或者 E(MSGB)。（吗） 算术编码的实现下面给出我的算术编码代码思路。 decimal库：算术编码需要高精度的小数，在通常的浮点数运算中，很容易出现精度不够或者计算误差的情况（例如本应得到 0.3 但是实际内存中的值是 0.2999999999 或 0.3000000000041）。我们通过引入库 decimal 来解决计算位数和精度上的问题。 预设的比例区间 编码函数 encode：在上述区间内计算，得到一个结果区间。 解码函数 decode：对编码值转换为十进制，在上述区间内计算，确定属于什么区间，不断解码出信息。 十、二进制转换函数：我们使用十进制进行表示和计算，但是最终希望得到的编码是二进制值，因此，我们需要二者间的进制转换作为编码与解码的基础。特别的，bin() 求解的是区间（value。valueUp）区间内的最短值。具体来说，我们对左右区间不断转换二进制并比较，检查到二者的第一个相异位，此时左边界此为 0，右边界为1。我们取此位为 1。则得到最短编码值。只要我们认定编码值均小于等于右侧边界，就不会造成问题 源代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import decimal# use Decimal for high precisiondef bin(value, valueRange): result = list() valueUp = D(value+valueRange) value = D(value) while 1: value *= D(&quot;2&quot;) valueUp *= D(&quot;2&quot;) # 均大于 if value &gt;= 1: value -= D(&#x27;1&#x27;) valueUp -= D(&#x27;1&#x27;) result.append(1) # 均小于 elif valueUp &lt; 1: result.append(0) # low0up1 else: if valueUp == D(&#x27;1&#x27;): result.append(0) result.append(1) break while 1: i = result.pop() if i: result.append(i) break return resultdef dec(value: list) -&gt; decimal.Decimal: w = D(&#x27;1&#x27;) result = D(&#x27;0&#x27;) for i in range(0, len(value)): w *= D(&#x27;0.5&#x27;) result += w*value[i] return resultdef encode(): encode_str = input() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) for i in encode_str: index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) return bin(l, nowRange) # h = thedict.get(encode_str[i]) # print(h)def decode(codebin: list, codelenth): codedec = dec(codebin) result = str() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) st = D(&#x27;0&#x27;) for j in range(0, codelenth): for i in range(1, len(low)): st = (low[i])*nowRange+l # ed = st + nowRange if codedec &lt; st: index = i-1 # index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) result += chars[index] break return resultif __name__ == &#x27;__main__&#x27;: D = decimal.Decimal decimal.getcontext().prec = 32 chars = input(&quot;Dict:&quot;).split(&#x27;,&#x27;) # if default if chars[0] == &quot;0&quot;: chars = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] distribute = [D(&#x27;0.1&#x27;), D(&#x27;0.4&#x27;), D(&#x27;0.2&#x27;), D(&#x27;0.3&#x27;)] else: distribute = input(&quot;Distribute:&quot;).split(&quot;,&quot;) ans = encode() print(str(ans)) ans = decode(ans, 7) print(ans) 参考资料 什么是算术编码 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"}]},{"title":"2022 Seed 训练营笔记收录","slug":"Seed训练营笔记收纳","date":"2023-03-24T14:47:43.000Z","updated":"2023-03-27T15:12:21.089Z","comments":true,"path":"2023/03/24/Seed训练营笔记收纳/","link":"","permalink":"http://example.com/2023/03/24/Seed%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0%E6%94%B6%E7%BA%B3/","excerpt":"前言 这是去年参加 Seed 训练营的笔记。一直没有整理，如今实习压力当前，借机整理。另附 Seed 训练营感想。","text":"前言 这是去年参加 Seed 训练营的笔记。一直没有整理，如今实习压力当前，借机整理。另附 Seed 训练营感想。 开发系列课 1.架构 架构的意义是什么？ 划定边界 生物属于动物，但是哪些东西能判定一个生物是动物？ 玩家操作player，玩家不能操作NPC，Bot属于NPC还是player？其他玩家属于player还是NPC？ 只有划定边界才能解决这个问题 设计就是不断的重新划定边界 例子：建筑师需要定义规格 建筑师的设计需要有极多的国家规范 软件项目也需要规格，设计者就是一种建筑师 例如player设计可能有三米高，但是建模只能允许两米以下的player进入 只有严格的物理计算参数才能有和谐的演示效果 设计可能存在的问题 性能的过度冗余：明明只有1000的在线，却考虑1000K的在线性能 功能的过度冗余：明明只需要打电话，却也考虑了打游戏的功能。 讨论架构需要画图 1.5.实现架构 抄 ￮ 面向项目内代码编程 ￮ 面向GitHub/Stack overflow编程 依葫芦画瓢 2.模块的基本目标 问题：区分边界：这个函数该在这个模块还是那个？ 要求：用词准确：没有二义性、也不过于繁琐失去宏观性。 困难：语言本身却存在模糊性 解决方案： 减少词的二义性： 形成团队共识 使用最基本的共识：自从词语最基本最字面的意思来使用。 举例：不使用“持有”而使用“拥有”或“在手上”。 注意：如果一个模块囊括了太多不同的功能，模块也就失去了它的意义（state controller） 反复绕来绕去的逻辑是bug的温床 2.5模块间的关系 关系A：关联、泛化、细化、依赖 关系B：聚合、组合 模块之间相互用到信息或服务 脚本可能是一个模块，模块和模块之间还可能构成一个更大的模块。不能忽视后者的存在。（如玩家移动模块和玩家背包模块可能同时构成玩家模块） 如果一个模块已经被聚合了，对外界应该是一个统一的模块。这就是说，外界应该统一从一个地方调用模块内部接口，而非在深入了解后从各自的地方调用。这样可以避免同步的问题等等。 3. Debug bug的三步走 重现bug 打断点是最快最方便的定位方法 有时过多断点需要通过条件过滤断点 分析原因 重新设计 避免不一致的设计 如果闻到“bad smell”那一定有什么不对劲 内部用户的易用性也是非常重要的，即使改动非常小 4. 项目程序规范 不提交无关的文件 删除调试代码 一次提交一个bug 提交时的注释很重要 注释中文还是英文：从大家利于理解的角度 有、统一最重要，是什么不重要。 命名规范 代码风格 其他内容 创意与原型：创意部分 A.困惑 如何快速产生大量创意？ 如何清晰快速有感觉的展示？ 如何判断创意是否靠谱？ B.发现创意 step1：一个主题+三个词 标准：使用名词或动词,不使用形容词。因为每个人对形容词的感受是不一致的。 step2：一个名字+三句话 用三句话写明短中长期的玩家历程体验 step3：图文一页展示 找图片：要求贴合三句话、画风一致、符合自己的想法（包括对画风的想法） 排版等 step4：电梯演说概述游戏 电梯演说：高效地表达自己的想法 提高演说力：乔布斯的模拟演讲 e.g:“我想做一个野炊式画风崩坏式战斗的弱联机开放世界…“ C.设定Box 划出你的边界，游戏创意不能超出这个边界 如何设定box？ 从自己出发:兴趣、擅长 从市场出发:行业数据、市场调研 创意与原型：原型部分 原型不等于游戏：它只是解答问题、验证想法的游戏的部分模拟。 游戏demo又或者纸面原型。 A.明确问题 例如 sf4中，什么是玩家需要抉择的？ 皇室战争中，玩家会如何搭建自己的卡组？ PUBG，玩家会如何选择开局？带来什么体验？ 头脑风暴 rules： 头脑风暴不管对错，不做评价 头脑风暴时，点子越多越好 即使有人讲错了，只需要往最终的方向带就行 需要存在一个主持人 原型头脑风暴只为最终体验服务 不同类型的交通工具消耗成本、运载容量等数据固然重要，究竟是摩托车还是电瓶车却是更直观具象的游戏体验。 头脑风暴为游戏提供所需的元素 B.明确范围 以SF4为例： 时长：模拟的是一个回合的瞬间？还是一个回合？还是若干回合？ 时期：模拟游戏早期？末期？ C.明确形式 原型准备： 玩家输入 接单、过单… 系统输出 -出单、奖励…… 桌游 开票 跑团 玩 自己和自己 和策划 设计师眼中的游戏 1.游戏是构建体验的系统 为什么游戏是构建体验的系统 最核心的目标就是构建体验，但是为什么是游戏？ 游戏的互动性 **体验大于玩法，玩法服务于体验。**同样的玩法，换一个设定，也许吸引的人就完全不一样。 构建体验的四要素 机制、设定、美学、技术 2. 体验从理解人类开始 A.理解用户 人的注意力是有限的 模式认知：人脑会自动识别抽象。 ￮ 容易认知模式 ￮ 不容易掌握 对比产生美 可塑的大脑：越练习，越熟练 情感黑盒：吊桥效应 大脑的偏见：看上去不一样长的线实际上一样长 人是千差万别的 男女差异、MBTI、职业、游戏经历…… 用户的动机 quanticfoundry的玩家动机理论，九种玩家 B.理解市场 市场是多变的，也是可预测的 市场的特点： 市场竞争 游戏是非竞争性商品 游戏可以被轻易的复制，不会因为我玩别人就没办法玩 马太效应 强者恒强，强力的游戏可以轻易吸走冷门游戏的用户 创新者的困境 巫师三让市场对2077有过高期待 英雄联盟让拳头难以花时间精力推出新的游戏 船大难调头 细分市场：细分市场是信息流转充分发达情况下的必然结果：适合大部分人的 80 分产品也许吸引不了大部分人，适合小部分人的95分产品却很有可能吸引小部分人中的大部分人。 未被开发的细分市场就是蓝海市场。 B.市场定位（竞争） 自我定位 在细分市场的定位 蓝海？还是红海？ 竞品？ 自己在和什么游戏对比？ 市场会拿来和什么游戏对比？ 哪些地方更好了？哪些地方可以被放弃? 3. 什么是好的游戏 A.好的体验 强烈的情感体验：高光时刻 心流体验：这个玩家太难，那个玩家也许太简单 沉浸： B.可持续发展 利润=营收-开发成本-营销成本 营收=用户规模*用户付费 营销也是产品设计的一部分：广告、买量、主播直播、黑魂是数值不平衡的垃圾游戏还是有挑战性的硬核游戏？（hook成本） 积累=提升质量、降低成本 作品管理入门（以三周的 Seed 项目为例） 如何把想法落地？ 排期表 开发流程前决定谁是 PM 玩法验证 不要复合验证，不要着眼于验证中新产生的想法 开发过程注意 完整流程与工作项的 mapping 优先交付高价值的部分 敏捷开发 晨会制度：同步成果、目标、困难 展示会 回顾会 情感表现 好的剧本可以拍出好的电影，但是好的剧本不一定能拍好电影 同样的事情，想要传达不同的情感会深刻改变游戏的： 场景调度 隐喻：破案感、发现穿帮镜头的兴奋感 节奏（情绪曲线）：好莱坞三段式… 引发回忆：引发群体回忆、各年度回顾 灯光：主光辅光轮廓光的软度硬度 转场 设计流程 学会根据需求预估工作量 多少模块？ 多长时间？ 多少行代码？ 需求分析 理解、分析、注意约束 未表达的要求 潜在的限定 • 未来可能的发展变化 系统责任和对外交互 逐个完成模块设计，然后汇合 需要的话，画状态图和（或）流程图辅助代码设计----“盖大楼”的“脚手架” 可能的设计方向 以点带面（最常见） 自顶向下（技术要求高） 自顶向上，逐步拼装 自中向下，在逐步拼中为大 要达到更高的技术要求，就要有从“以点带面”向“自中而下”靠拢的行动力。 不太重要的 不太重要，或者说我没太记的一些笔记。 音频 游戏中音乐类型 音效与音乐 音乐功能设计 氛围营造： 闪避效果：人声压背景 分轨设计：转阶段后不断叠加分轨音乐细节更加丰富 反馈信息： RTPC：实时根据游戏参数反馈改变音乐 娱乐效果： 游戏音乐内容制作 主流中间件： Wwise，Criware… 快捷制作 audio editor插件 心理 情绪曲线 心理需求 丰富的体验 消极情绪+积极情绪 消极情绪的作用：快速参与代入、高强度的代入 推荐 心理学家的面相术 情绪（蓝色粉笔字封面） emotionpolygon 游戏数据 制作是不断优化选择的过程 手上有多少东西可以选？ 游戏源自生活 电影和游戏 电影：剧本 游戏：机制+剧本 游戏： 纯机制的游戏是存在的 剧本可以辅助理解游戏机制 表达情感","categories":[{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"},{"name":"拾遗","slug":"拾遗","permalink":"http://example.com/tags/%E6%8B%BE%E9%81%97/"}]},{"title":"GAMES101-4：视图和投影变换","slug":"GAMES101/GAMES101-4","date":"2023-03-18T09:14:50.000Z","updated":"2023-07-20T17:45:59.417Z","comments":true,"path":"2023/03/18/GAMES101/GAMES101-4/","link":"","permalink":"http://example.com/2023/03/18/GAMES101/GAMES101-4/","excerpt":"前言GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5","text":"前言GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5 如何拍一张照片：MVP变换 Model Transformation:摆好位置 View Transformation：找好拍照角度 Projection Transformation：拍照。 视图变换：View思考：任何情况下进行拍照，照片都只和物体相对于相机的坐标有关。 所以建立一个新的坐标系（相机坐标系）规定 相机处于原点； 相机的向上方向是 Y （up at Y）； 相机看向 -Z 方向。 将坐标转换： 平移相机至原点 旋转使向上方向为 Y，旋转使相机看向的方向为 -Z。 求此处旋转矩阵，可以求坐标轴旋转为相机轴的旋转矩阵，然后转置。 投影变换：Projection两种投影方式： Orthographic Projection：正交投影 Perspective Projection：透视投影 透视投影更接近人眼成像，会有“近大远小”、“平行线相交于一点”等效果。 在如下图所示的模型中，透视事实上就是拍下了锥形视野内的 [n,f] 内的一段区间内的物体，正交则是相机处于无限远处的一个特例。 正交投影 构建相机坐标系 构建一个包含所有物体的空间立方体，描述它为 $[l,r]×[b,t]\\times [f,n]$ 的一个立方体（左右下上远近）。是由远及近是由于右手坐标系且看向 -Z 方向导致远处 Z 坐标更小。 将结果规范化在一个 $[\\pm1,\\pm1, \\pm1]$ 的方块内 矩阵形式：中心移至原点，再缩放$$M_z=\\begin{bmatrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix} \\times\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\ 0 &amp; 1 &amp; 0 &amp; -\\frac{b+t}{2}\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 透视投影 对如上图的透视，定义近平面 n 和远平面 f，有： 近平面保持不变，其余地方进行“挤压”使得其与近平面一样大。使上图左侧变成右侧形状。 进行正交投影 透视投影的变换矩阵这里有一个需要注意的地方是，挤压以后，坐标的 Z 轴值“可能”会发生变化。对此我们规定： n 平面上的坐标不变 f 平面上的坐标 Z 轴不变，且平面中点坐标不变 对于任意的点 $(x,y,z)$ ，对应到一个 n 平面上的点 $(x’,y’,z’)$。相似三角形有 $$\\begin{align} y’ =\\frac{n}{z}y\\x’=\\frac{n}{z}x\\end{align}$$ 接下来求解 Z 轴的变换方程，即矩阵的第三行。 假设变换矩阵为 M，有： $$M(x,y,z,1)^T=(\\frac{n}{z}x,\\frac{n}{z}y,z_1,1)^T=(nx,ny,z_2,z)^T$$ 其中 $z_1,z_2$ 未知。 $z_1$ 的值的变换向量是 M 矩阵中的第三行，所以可以只关心第三行。又因为 Z 坐标值显然和 XY 没有关系，所以此行可以写为 $(0,0,A,B)$ 其中 A、B 未知。 n 平面上的点满足变换矩阵且 Z 坐标不变。所以 n 平面上的坐标可以写成 $(x,y,n,1)^T$ 。同时乘以坐标 n，代表的点依然不变：$(nx,ny,n^2,n)^T$。 所以有 $(0,0,A,B)(x,y,n,1)^T=n^2$ f 平面同样中点 $(0,0,f,1)$ 满足变换矩阵且 Z 坐标不变。于是 $$(0,0,A,B)(0,0,f,1)^T=f^2$$ 于是可以联解 $$\\begin{align} An+B =n^2\\ Af+B =f^2\\end{align}$$得$$\\begin{align} A = n+f\\ B = -nf\\end{align}$$ 所以解出 Z 轴变换方程值， M 矩阵 $$\\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; n &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; n+f &amp; -nf \\ 0 &amp; 0 &amp; 1 &amp; 0\\end{bmatrix}$$ 近平面的表示方法：可视角度我们通常认定近、远平面的深度（z轴）是已知的，所以现在的问题是如何描述近平面： 指定近平面四个点的坐标 指定宽高比和可视角度。下图为 y 轴可视角度的表示，根据 y 轴可视角度和宽高比可以求出 x 轴的可视角度 两种表示是可以互相转换的，如下： 其中近平面的范围为$[\\pm r,\\pm t]$，aspect 为宽高比。","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"}]},{"title":"GAMES101-3：变换","slug":"GAMES101/GAMES101-3","date":"2023-03-10T05:28:27.000Z","updated":"2023-07-20T17:47:09.221Z","comments":true,"path":"2023/03/10/GAMES101/GAMES101-3/","link":"","permalink":"http://example.com/2023/03/10/GAMES101/GAMES101-3/","excerpt":"前言GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。","text":"前言GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。 对图形进行各种变换，可以相当于对其左乘对应矩阵。 基本线性变换 缩放矩阵 $\\begin{bmatrix} s_x &amp; 0\\ 0 &amp; s_y \\end{bmatrix}$ 切变 （Shear） 矩阵:$\\begin{bmatrix}1 &amp; a\\0 &amp; 1\\end{bmatrix}$切变的本质就是将矩形变成平行四边形。坐标不变的一条边称之为依赖轴，变换称之为方向轴。下图为一个 y 为依赖轴的例子： 旋转：旋转点通常是原点。$\\begin{bmatrix}cos\\theta &amp; -sin\\theta \\sin\\theta &amp; cos\\theta\\end{bmatrix}$对旋转矩阵，其反方向旋转的对应矩阵为其逆矩阵同时也是转置矩阵。 齐次坐标和仿射变换使用 $n+1$ 维坐标表示 $n$ 维坐标。其中，对于点，记为 $(x,y,1)^T$，对于向量，记为 $(x,y,0)^T$由于平移，不能写成左乘形式进而与其余变换统一。所以我们引入齐次坐标，使得平移矩阵为 $\\begin{bmatrix} 1 &amp; 0 &amp; t_x \\ 0 &amp; 1 &amp; t_y \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$ 思考：为什么向量和点的第三维不一样？ 对于向量，具有平移不变性，我们不希望其左乘平移矩阵得到的结果是新的向量，对于点的想法则相反。因此向量的最后一维应为 0 使得其不受平移矩阵影响。进一步地，有： 向量 + 向量 = 向量 向量 + 点 = 点 点 - 点 = 向量 点 + 点 = 二者中点 ……可以发现向量为 0 而点为 1 的情况对于上述现象也可以解释得很好。 仿射变换定义仿射变换：仿射变换 = 线性变换 + 平移。使用齐次坐标可以表示仿射变换。齐次坐标等于多个线性变换矩阵、平移变换矩阵左乘后的结果。$$M=\\begin{bmatrix} a &amp; b &amp; t_x \\ c &amp; d &amp; t_y \\ 0 &amp; 0 &amp; 1\\end{bmatrix}$$ 其中 $a,b,c,d$ 表示旋转、缩放、切变，$t_x,t_y$ 表示平移。 逆矩阵对于仿射变换矩阵 M，定义逆矩阵：$$MM^{-1} = E$$其中 E 为单位矩阵。M 的逆矩阵恰好对应原来仿射变换的逆变换。特别的，对于旋转变换，其逆矩阵和转置矩阵相同，使得求其逆变换变得方便。逆矩阵等于转置矩阵的矩阵被称为正交矩阵。 矩阵不满足交换律，变换也不满足交换律。变换的顺序很重要。 绕任意点的旋转设任意点为 P，将旋转分解为：把 P 平移回原点、旋转 α 度、平移 P 回 P 点。于是有变换矩阵：$$T = T(P)T(\\alpha)T(-P)$$ (注意顺序是由右到左表示的) 三维变换对于三维变换，可以简单地写出缩放和平移，重点关注旋转。 绕轴旋转考虑简单的旋转：绕一个轴在一个平面内旋转。$$R_x=\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 \\ 0 &amp; \\sin\\alpha &amp; \\cos\\alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$$$R_y=\\begin{bmatrix} \\cos\\alpha &amp; 0 &amp; \\sin\\alpha &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ -\\sin\\alpha &amp; 0 &amp; \\cos\\alpha &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$$$R_z=\\begin{bmatrix} \\sin\\alpha &amp; \\cos\\alpha &amp; 0 &amp; 0 \\ \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}$$请注意 y 轴中 $sin\\alpha$ 的正负号与其他情况不同这是因为旋转矩阵的循环对称性。即 xyzxyz 的矩阵循环中，一个的值等于前面两个的值相乘。所以对 R_y 有$R_z \\times R_z = R_y$ 而非相反。 绕任意轴旋转对于任意角度的过原点轴，可以把它分解为三个轴上的角度（欧拉角）。变成三个轴的变换矩阵的乘积。对绕任意轴 $n$ 旋转 $\\alpha$ 角，有 Rodrigues’ Rotation Formula 如下：$$\\bold{R}(\\bold{n},\\alpha) = \\cos(\\alpha)\\bold{I}+(1-\\cos(\\alpha))\\bold{n}\\bold{n^T}+\\sin(\\alpha)\\bold{N}$$其中$$\\bold{N}=\\begin{bmatrix} 0 &amp; -n_z &amp; n_y \\ n_z &amp; 0 &amp; -n_x \\ -n_y &amp; n_x &amp; 0\\end{bmatrix}$$其中，称 $\\bold{N}$ 为 n 的反对称矩阵，也就是向量 n 的叉积（$\\vec{n}\\times\\bold{\\vec{a}}$ ）的矩阵形式。对于任意不过原点的旋转，把其分解为平移原点、旋转、平移回去的过程。引入四元数是为了更好地对旋转进行插值，关于四元数，另行参考。","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"笔记，基本线性变换","slug":"笔记，基本线性变换","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"}]},{"title":"GAMES101-3：回顾线代","slug":"GAMES101/GAMES101-2","date":"2023-03-09T06:53:39.000Z","updated":"2023-07-20T17:47:42.109Z","comments":true,"path":"2023/03/09/GAMES101/GAMES101-2/","link":"","permalink":"http://example.com/2023/03/09/GAMES101/GAMES101-2/","excerpt":"前言GAMES101-P2：回顾线代：向量、矩阵。","text":"前言GAMES101-P2：回顾线代：向量、矩阵。 向量 向量： 向量的定义和性质 模与规一化( normalization )$\\hat a = \\frac{\\Vert \\vec a \\Vert}{\\vec a}$ 向量相加：三角形法则 / 平行四边形法则、坐标 向量的矩阵形式 $A^T=(x,y)$ 点乘 $\\vec{a}\\cdot \\vec{b}=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert cos\\theta$。考虑矩阵形式。 投影、找夹角 两个向量方向接近的程度，是否基本同一个方向 叉乘 $a\\times b=-b\\times a=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert sin\\theta$ 右手定则与右手坐标系。叉乘确定一个平面。不满足结合律。 判断向量的左右关系 判断点与三角形的内外关系：对每条边都在同一侧 矩阵 矩阵 基本运算：乘积 没有交换律。$AB\\neq BA$ 转置 $T$ $(AB)^T=B^{-1}A^{-1}$ 单位矩阵 $I$ $A^{-1}A=I$ 齐次坐标","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"VSCode 的设置系统的粗浅理解","slug":"VScode的设置系统","date":"2022-11-21T05:20:25.000Z","updated":"2023-03-15T13:41:09.380Z","comments":true,"path":"2022/11/21/VScode的设置系统/","link":"","permalink":"http://example.com/2022/11/21/VScode%E7%9A%84%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F/","excerpt":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却……","text":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却…… 我需要一个默认的编译设置 众所周知，VSCode 的推荐或者说设计使用方法是对不同代码建立不同的工作区。这确实是对不同项目、不同语言的代码进行管理的优良方法。但是在学习的过程之中，不是所有情况都是非常理想的“我可以将所有的代码都井井有条的打在一个文件夹（工作区）中”的。学习中，QQ 上接收测试别人的代码、想临时测试某个功能是否如记忆一样等等情况，这样的代码，具有临时性或者独立性，我不希望将其和我固有的代码文件混淆在一起，又不希望记一个层层目录之下的草稿工作区分门别类。因此最理想的情况就是能在不打开特定工作区或文件夹的情况下对单个文件进行编译和调试。也就是一个全局的，或者说更通用的设置。 之前种种原因，对 VSCode 的设置理解停留在了一种一知半解的程度，借此机会，我希望能对此加深理解。 VSCode 中的设置的基本结构 优先级和工作区、文件夹 VSCode 的设置结构优先级由低到高是 “默认设置（不能更改）→ 用户设置 → 工作区设置 → 文件夹设置”。VSCode 会优先使用优先级高的设置，如果没有，就用优先级次高的设置。 知道写到这里我才注意到的一个事实是工作区（workspace）和文件夹（folder）是不一样的存在。我们可以认为一个“文件夹”是一个项目，一个工作区则是同类项目的集合点。例如所有的 Python 项目为一个工作区，而对其中的任意一个项目设置为单独的一个文件夹。Python 项目的共通性设置放于“工作区设置”中，而项目如果有特殊设置则放在“文件夹设置”里。 需要注意的是，如果只有一个文件夹，那么这个文件夹本身就是一个工作区。VSCode 会把这个文件夹设置显示为工作区设置，这也是为什么我会一开始没有发现这俩是不同概念的原因。 下面是工作区和文件夹在 VSCode 资源管理侧栏界面的对比，工作区会额外注明工作区二字。 设置文件的存储格式 所有这些设置，都是以 JSON 文件存储在电脑上的文件中的（尽管工作区文件不以.JSON结尾）。JSON（JavaScript Object Notation） 是一种独立于 语言的轻量级数据交换格式，采用键和值的格式存储数据。 而VSCode 的每一项设置都是一对键和值。 其中，用户设置位于 VSCode 的数据目录下( C 盘 appData 文件夹下)；工作区设置会是一个名为&#123;名字.code-workspace的文件（此文件不一定位于工作区文件夹内）；如果是文件夹，则会存储于文件夹下自动生成的.vscode文件夹下。 插件的设置 使用 VSCode 的时候，我们还会添加许多的插件，例如本文的初衷：在非工作区 / 文件夹环境下编译 C/C++ 程序就需要 MS 官方的 C/C++ 插件。这些插件的设置也会被写入到 Uersettings 文件中。因此，所有的插件和软件设置都是对同一个文件的内容的修改。既然目的是更改默认的编译软件，那么我们就是需要修改 Usersettings 文件即可.事情到这一步似乎离解决已经不远了。可是真的是这样吗？ 结论 在设置中，我们找到了下面两个设置。第一个的设置具体还不是很懂，第二个则没有发挥作用（图中值为自己填的）。 所以很遗憾，事情没有以完美解决落幕。依然要选择编译和调试器如图： 不过，至少我搞清楚了为什么这里会有三个选项，在官方文档中提到， The compilerPath search order is: First check for the Microsoft Visual C++ compiler Then look for g++ on Windows Subsystem for Linux (WSL) Then g++ for Mingw-w64. 因此，VSCode 会扫描到 mingw-w64 中的 cpp 和 g++ 两个程序，以及 VS 中带有的的 cl ，因此 VSCode 会有不知道用什么的疑问。但是 cl 被限制为只能在 VS 中使用，这也就导致了此选项实际上不能正常运行。目前的解决办法还得是选一遍，然后 VSCode 会在这一窗口中记住你的选择。 这一选项的原因可能是 VSCode 中的并没有选项能存储此默认设置，它会优先去寻找 launch.json,找不到时，则会发出此疑问。 还没有理解的问题 Q：既然 JSON 文件支持注释，那 JSON 和 JSONC（JSON with comments）有什么区别，为什么要创造 JSONC？VS Code 采用的是 JSON 还是 JSON with comments？","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"如何管理我的文章、笔记","slug":"如何管理我的文章、笔记","date":"2022-11-15T14:58:57.000Z","updated":"2023-03-15T12:29:52.807Z","comments":true,"path":"2022/11/15/如何管理我的文章、笔记/","link":"","permalink":"http://example.com/2022/11/15/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E6%88%91%E7%9A%84%E6%96%87%E7%AB%A0%E3%80%81%E7%AC%94%E8%AE%B0/","excerpt":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。","text":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。 0.我的笔记环境 各类记笔记的软件繁多冗杂、不一而足，由上述两段可见一斑。而在经过两年多的跌打过后，我目前得出的教训是：有的就是好的，没有的就坏的。手上的工具再差，其已经配好了这一特点就胜出许多，因为这一点意味着当拥有想法的时候，你不会工具没有配好没发写而难受。 因此，做事的正确的顺序应该是先写起来，先用起来，习惯起来然后再酌情学习更换。否则就是配这个，踩一遍坑、配那个，踩一遍坑……到头来时间耽误不少，工具用了挺多，产出是一个没有，精通的也一个都没有……或者哪怕找到了趁手的武器，写文章的心境也早没了，只能任由心绪烂在心里。 下面简要介绍我的情况： 我是计算机类大学生，存在记笔记的需要，偶有写文章的冲动，但是依据过去进行判断的话，没有做日记或笔耕不辍的习惯。习惯于使用Markdown。 我目前使用的记录软件包括：小米笔记、Notion、VSC+MPE（就是这个博客）、Goodnotes、Notbility、Obsidian、备忘录（苹果）。 其他有所耳闻的应用还有各类在线博客平台（如CSDN、知乎专栏、掘金）、logseq、OneNote、typora等。 下面依次对我使用的工具的职责和功能进行介绍和明晰。 1.小米笔记：便捷的文字集散地 小米笔记用于我的 MIUI 手机上。其实功能不少，界面也很美观。既可以添加待办，也可以很方便的写一些短文字，还有思维笔记的功能。格式相似于 Markdown ，主要是荧光笔、触屏涂鸦和中/左对齐等功能，不过不支持 Markdown 语法。 显然这个就是主打轻量化的软件。由于手机一般就在身边，因此想到什么就马上开记，不要了就删掉是其最大的好处。 此外，小米笔记还有摘录功能，即复制后在侧滑功能栏里可以直接添加到笔记。或者也可以先侧滑打开摘录功能，然后接下来复制的多段文字均会在结束的时候被添加到同一个笔记中。 目前我对他的定位是做一个简单的快速记录软件、日记软件。将其分为了“垃圾话”、“灵感”和未分类三个部分。 “垃圾话”存储的是一些突然涌现的思绪，例如突然涌上心头的后悔、思念、思考、感悟……“灵感”则存一些更有价值的创造，比如说现在里面有的一篇小故事。我深知我无法将其扩写成一篇完美而精致的小说。但是我依然可以在小米笔记里把梗概存下来。至于未分类则就更是乱七八糟了，临时记录的东西。例如预备购买的手机的优缺点、给别人发一大段话前组织语言……这是笔记的默认分类。 至于隐私空间，则是一个简单的生活秘密空间。例如某个密码锁的密码，可以存在这里以防万一。从而使得应用本身并不需要上锁。 2.Notion：基于云端的长文字集散地 Notion 的好处很多，不过展开了说就有些长了，再说了我也没有完全摸透，大体上看是可以简单担任日历、待办、笔记、备忘录等等功能……（我甚至在拿它记账！）。总的来说，Notion 是极富有野心也极强大的的网络云笔记平台。支持类 Markdown 语法、按段落拖动等都是他的的优势。尽管如此，它也不是十全十美的。 其基于云端本身就意味着访问不稳定和隐私风险的等问题的存在。而且在国内特定的网络环境下，直接后果就是你需要开启代理，否则从一开始就不能登录，即使登录了，丢字、光标移动不稳定等问题依然会不时的困扰着人，这也是我尝试 Obsidian 和转移到 iPad 的原因之一。（另一原因是手写笔记的排版自由）。 尽管如此，一些具有多端阅读需求和多端编辑需求的文章还是可以放在 Notion 上。例如读书笔记或者单纯的笔记之类的。我曾经使用 Notion 作为课堂笔记过相当长一段时间。 3.Obsidian：移动端的 Markdown 基于移动端的 Markdown 写作平台，很可惜的是需要付费才能解锁多端同步的问题。因此，Obsidian 主要是作为小米笔记的 MarkDown 补全品出现。（文本迁移到 Notion 有格式转化的一大堆问题，不能作为 Notion 的补全品。但是可以作为 Notion 的替代品。具体来说就是一个小说的写作地。 4.Leeka的酒馆（VS Code）：成熟文章的集合 通过VS Code + MPE，可以进行较长篇幅的文章写作。同时，虽然没有人看，但是公开网站的性质也使得这里不适合放一些强隐私性的东西。这里主要堆积的是完成度高、成体系、长的文章。通过 Markdown 进行编辑可以使得我专注于内容本身。至于缺点则是虽然发布内容可以全平台浏览，但只能在电脑上进行编辑，而且会想折腾各种写作环境。目前来说，新建文章的方式也不够优雅。 5.Goodnotes &amp; Notebility：上课笔记、下课草稿（iPad） 目前的分工是 Goodnotes 记录课堂笔记，Notebility 负责一些更不正式、预备稿、涂鸦、灵感一类的东西。这里的一大原因是 Notebility采取了昂贵的订阅制，虽然可以白嫖朋友的 classic 版，但是说到底还是不适合与之深度绑定。 Goodnotes 等的缺点在于，除非导出为 PDF，否则不能在 iPad 以外的设备上进行查看，而且本身是手写用的。 6.备忘录（iPad） 备忘录的优势在于双击启动，虽然写起来不如 G 或者 N 爽，但是用来写一些用后即焚的东西（例如打草稿）还是有一定优势的。","categories":[{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"}],"tags":[{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Take You Down ---至少不能让你受我连累","slug":"TakeYouDown","date":"2022-04-17T06:52:25.000Z","updated":"2023-03-16T12:33:26.954Z","comments":true,"path":"2022/04/17/TakeYouDown/","link":"","permalink":"http://example.com/2022/04/17/TakeYouDown/","excerpt":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？","text":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？ 背景故事 《Take You Down》是收录于 ILLENIUM 的第三张录音室专辑《ASCEND》的一首歌。在《Take You Down》作为《Ascend》的先行曲发布时， Nick 在 YouTube 的介绍页写下了长长的一段话，告诉了粉丝自己过去和毒瘾战斗的艰辛过往，并感谢这一过程中音乐、母亲和其他爱他的人给他的激励。 如今，31岁的 Illenium 是全球最有名的 DJ 和电子音乐制作人之一，《ASCEND》曾登上得 Billboard 电子舞曲专辑的第一名的位置，而凭借第四专《Fallen Embers》，他赢得了一项格莱美音乐提名。而他则和家人、女朋友、朋友生活在美国丹佛。 以下是他在 Youtube 上写下的感悟： Yo Fam, I've been wanting to share something super personal for a while and just wasn't exactly sure how to do it. I'm at the point now where I've heard countless stories from you. Some of you have said my music changed your life, helped you through depression, addiction, a lost loved one, the list goes on. Honestly, I feel bad because you don't know how much that truly means to me, because I've been there too... In the depths. Six years ago I overdosed on heroin. I struggled with opiate addiction from a young age. I was trapped in it, had no passion, no direction, and truly hated myself. It was such a dark time for me and my family because when it gets bad enough, hope begins to dim and there's no escaping reality. I'm not telling you to preach or say how I found some magical cure or that everyone needs to live like I do. I'm the biggest advocate for people living their own lives and spreading their own love in their own ways. I'm just sharing my story and relating because music saved my life too. With everything that has been going on with my career, I always keep reminding myself of that. My main goal with music is to try and help people overcome their struggles and also enjoy the moment. With all that said , 'Take You Down' is about my struggles with addiction and what it can do to families and loved ones. It's more specifically about my mom, and how no matter what, she never gave up on me and always continued to see the good even though all I was doing was messing up. To anyone struggling like I did, not just with addiction but anything in life, I hope you guys can find peace in your struggles and know that anything can be overcome. I've been clean since that overdose and I owe that to finding my passion and being surrounded by the most loving people I could ever ask for. Thank you for always listening and being open. Thank you for sharing your own stories and your love of music with me. Love you all forever : ) 翻译 嗨，朋友们： 我一直想和你们分享一下一些完全私人的情感，但是却不知道该如何开口。眼下，我已从你们那儿听到了许许多多的故事。有的人告诉我，我的音乐改变了他的生活，帮助他渡过了诸如抑郁、药物成瘾、失恋……种种人生坎坷。老实说，我的感觉并不好，因为你们根本不知道这对我意味着什么：我也曾生活在那种糟糕境况中……深陷其中。 六年前，我遭遇吸食海洛因过量的事。我还很年轻的时候就和阿片药物成瘾对抗着。我踩进了毒品的圈套，生活没有热情、没有方向、自我厌恶。这对我和我的家庭都是一段非常黑暗的岁月，因为成瘾太深以后，就很难再回避事实了：戒毒的希望已经很渺茫。我不是要给你们讲大道理或者要说我找到了什么神奇的戒毒方法，又或者是要大谈什么你们都应该像我一样生活。我完全赞成每个人应该有自己生活和表达爱的方式。我只是想和你们分享一下我的相关遭遇，因为音乐也拯救了我的生命。当我的职业生涯日益发展，我也总是不断提醒着自己这一点。我做音乐的主要目标就是试着帮助人们克服遇到的困难，并享受当下。 总而言之，‘Take You Down’讲的是我和毒瘾的抗争以及这种抗争对我的家人和所爱的人的影响。尤其是我的母亲，无论发生了什么，她从未对我失去信心，总是以积极的一面看我——尽管我干的事就是把一切都搞砸了。对于那些像过去的我一样反抗着什么的人——不仅仅毒瘾，也包括人生中的其他种种问题——我希望你们能在反抗的过程中寻得心灵的栖身之所，而且能相信没有什么困难是克服不了的。自从那次吸毒过量以后，我再也没有碰过毒品。我也明白我得找回生命的激情并和那些我能寻求到的最有爱的人呆在一起。谢谢你们一直以来对我和我的音乐的支持。欢迎和我分享你的故事以及你对音乐的爱。永远爱你们 : ) 歌词翻译 I didn't mean to hurt you when I hurt myself 当我伤害自己，我无意连你一起伤害 It's just an empty voice screaming out for help 空洞又凄厉的哀叫只是 为寻求帮助 No, I didn't mean to scare you 不，我不曾想让你失措 But I couldn't see 但我不明了： That when I went to hell I was taking you with me 当我迈向深渊，我也在将你推入其中 When I close my eyes 而当我闭上眼… I'm climbing in the dark 就仿佛正在黑暗中攀登 Trying not to fall apart 竭力只求不要跌落 Sometimes I get so high 看到脚下的万丈深渊 Falling is the only out I see 坠落好似我唯一的出路 And I don't wanna take you down with me 而我不愿牵连你一同坠落 You're the love in my heart 只因我真心地爱你 Only love in my heart 你是我最爱的人 Take you down 坠下崖…… Take you down with me 与我一同坠崖 Don't wanna take you down 绝不愿你与我一同 Take you down 落入深渊 Take you down with me 落入痛苦的无底深渊 #Drop# This life is like a razor 这样的生活就如一把利刃 When it cuts, I bleed 令我伤痕累累 But it's in my hand 但这是我的抉择 And I'm doing it to me 是我在不断地伤害自己 Sometimes it's like an ocean 有时它又如一片幽邃的深渊 And it gets too deep 而我深没其中 And there's no way that now you could rescue me 如今你已没有办法拯救我 When I close my eyes 而当我闭上眼 I'm fighting in the dark 就仿佛正在黑暗中搏斗 Trying not to break your heart 竭力不要让你伤心 Sometimes I get so high 有时在我恍登极乐 Falling is the only out I see 堕落是我唯一可见的未来 And I don't wanna take you down with me 而我不愿你与我一同堕落 You need to let it go now 如今你该放下这一切 Before you drown 趁你尚未被牵连太深 I know that you won't understand 我知道你不会理解这些 But you need to let go of these hands 但啥时候放开拉着我的双手了 'Cause I'm going down 因为我无药可救 And I don't wanna take you down with me 可我不想牵连你一同饱受痛苦 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) #drop# And I don't wanna take you down with me 可我不愿牵连你一同跌入深渊 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) Take you down, down with me 怎愿致你痛苦，和我一样痛苦","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"}]},{"title":"用批处理简化hexo命令操作","slug":"用批处理简化hexo命令操作","date":"2022-03-23T16:19:24.000Z","updated":"2023-03-15T12:33:12.886Z","comments":true,"path":"2022/03/24/用批处理简化hexo命令操作/","link":"","permalink":"http://example.com/2022/03/24/%E7%94%A8%E6%89%B9%E5%A4%84%E7%90%86%E7%AE%80%E5%8C%96hexo%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","excerpt":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？","text":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？ 背景 搭建好博客网站后，之所以长时间没有更新，当然是因为本人懒狗，不过除此之外，hexo 糟糕的新建博文方法也是一大原因。 有两种方法可以新建一篇博文： 在博客的本地地址建立一个新的 Markdown 文件，然后依次修改它的各部分内容。 在博客的本地地址右键选择 git bash，然后输入命令进行操作。 第一个简单，但是糟糕的地方是头部信并不是自动生成的，需要从老博文里面复制。麻烦不说，时间戳不是自动生成的、混用 _drafts 和_posts 也总让我感觉有些难受。 第二个能自动生成头部信息，但是需要输入命令然后再关掉窗口打开编辑器，实际上也很麻烦。 但是，既然每次输入的命令都是类似的，这就自然让人想到能不能用例如 bat 批处理脚本来自动化这个过程。 答案是可以的， bat 脚本事实上就是一连串的命令。在 bat 文件中写 hexo help 和 新建一个 cmd 黑窗口输入 hexo help 没有任何差别。 使用批处理以后，可以从重复而繁琐的命令中解放时间，更好的专注于写作本身、也可以让草稿和博文真正的很清楚（而我还没有搞清楚hexo的开发者的初始设想到底是如何使用？想必不是让用户自己写批处理XD) 下面是脚本代码 实现 新建博文草稿并用编辑器打开 newDraft.bat 12345678@echo off@REM 跳转到博客地址D:cd D:\\***\\***@REM 输入文件名set /p name= input Name: @REM 新建文件、唤起第二个脚本hexo new draft %name% &amp;&amp; call openEditor.bat %name% openEditor.bat 1234echo the input is %1set name=%1echo %name%start /d &quot;C:\\***\\***\\VSCode的安装地址\\&quot; Code.exe &quot;D:\\博客的本地地址\\source\\_drafts\\%name%.md&quot; 这里，第一个脚本建立草稿文件，并唤起第二个脚本用编辑器（这里是VS Code）打开新建的 Markdown 文件。为什么不能写成一个文件这里我还不是非常清楚，似乎bat文件会在运行到 hexo ***后自动结束导致后面的命令运行不了。 发布（Publish）文章 publish.bat 123@echo offset /p publishBlog=hexo publish %publishBlog% 此脚本将指定名字的 blog 发布到 _post 文件夹中。 上传到博客网站 deploy.bat 1234start clean.batstart /min /w mshta vbscript:setTimeout(&quot;window.close()&quot;,2000)start generateAndDeploy.batexit 分别调用clean和generateAndDeploy，清理缓存、生成并部署。 clean.bat 123@echo offhexo cleanexit generateAndDeploy.bat 12hexo g -dexit 总结 有效激发了本人的写作热情，写好脚本以后当场写（水）了这篇博文。 算是对 bat 有了一点粗浅的认识，当然还有搞不懂的地方，例如为什么运行到hexo ***以后就退出了呢？还是需要以后再看，今天鉴于时间因素，还是就此暂停了。 自己用命令测试的时候请记住要用 CMD 运行！powershell的话你大概会遇到因为在此系统上禁止运行脚本的错误,这里是可能的参考解决方法。 这篇文章是向CSDN上“蓝蓝223”的这篇文章:《bat批处理脚本自动部署Hexo博客》学习后的成果。我对代码进行了一点无关痛痒的小改动。 代码块在MPE上预览要敲 batch 才有高亮，但是要生成的网页有中有高亮得敲 dos…… 我不理解orz","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"批处理脚本，hexo","slug":"批处理脚本，hexo","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%8Chexo/"}]},{"title":"Heavenly Side ---我愿与你逃向天国","slug":"歌词翻译/Heavenly Side个人翻译","date":"2022-02-14T15:59:59.000Z","updated":"2023-07-11T00:41:37.974Z","comments":true,"path":"2022/02/14/歌词翻译/Heavenly Side个人翻译/","link":"","permalink":"http://example.com/2022/02/14/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/Heavenly%20Side%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91/","excerpt":"前言Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。","text":"前言Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。虽然之前吐槽水啊水之类的，但是没想到这首歌比feat Nurko的Sideways让我上头多了。虽然网易云音乐的翻译也未必没有可取之处，但是个人感觉还是略显谜语人和机翻，在“没有人比我更懂歌词内涵”的思想下，写了这个翻译。由于写的时候考虑到能否唱出来而硬拗了一些词，不足之处欢迎指正。 翻译《Heavenly Side》 -ILLENIUM -《Fallen Embers》 I’ve got an anger problem 我总是喜怒无常 I’ve got a selfish need 还变得自私自利 I like to burn my focus 我在琐事中忙碌 Just to watch my true colors bleed 只为将真我遗弃 I’ve got a taste for failure 我已饱尝失败的滋味 I find it in everything 生活中处处碰壁 But I hear the voice inside you 但我却听到你内心的声音 Say I could be more than need 告诉我存在的意义 You can’t let go if you want to 若愿意你可永不放手 ‘Cause I love you all the same 只因我的爱永不改变 It’s a long way down from here（Oh, Oh, Oh, Oh ） 此后还有漫漫长路要走 My heavenly side is comin’ alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我美好的一面随时为你展现 And I killed myself last year(Oh, oh, oh, oh) 与过去的我一刀两断 My heavenly side is comin’ alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我温柔的一面随时为你展现 If you want me 只要你愿意 I know that I’m the problem 我知道我就是麻烦所在 I know that I’m to blame 我知道我应该饱受谴责 But I hear the heart inside you 但我也听到你内心的声音 And it’s calling out my name 正呼唤着我的名字 You can’t let go if you want to 若愿意你可永不放手 ‘Cause I love you all the same 因为我的爱永不改变 It’s a long way down from here 此后还有漫漫长路要走 My heavenly side is comin’ alive if you want me 若你愿意我美好的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin’ alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意 It’s a long way down from here 此后还有漫漫长路要走 My heavenly side is comin’ alive if you want me 只要你愿意我天使的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin’ alive if you want me 只要你愿意我恶魔的一面将会永埋心中 Don’t you let go 不要放手 I found my soul 是你将我挽救 Don’t you let go 不要放手 I found my soul 灵魂怎可弄丢 My heavenly side is comin’ alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"天国王朝语摘","slug":"天国王朝","date":"2022-01-15T06:13:35.000Z","updated":"2023-03-24T14:41:40.533Z","comments":true,"path":"2022/01/15/天国王朝/","link":"","permalink":"http://example.com/2022/01/15/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/","excerpt":"天国王朝语摘，自翻与所看版本的翻译","text":"天国王朝语摘，自翻与所看版本的翻译 What man is a man who does not make the world better ? trans：大丈夫生于世当造福苍生 Be without fear in the face of your enemies; Be brave and upright that God may love thee; Speak the truth always, even if it leads to your death; Safeguard the helpless and no wrong; that is your oath. trans（LEEKA）： 临敌不惧 神佑勇义 护良扶弱 纵死不诳 这就是你的册封誓言 trans： 强敌当前 无畏不惧 果敢忠义 无愧上帝 耿直正言 宁死不诳 保护弱者 无怪天理 这是你的誓词","categories":[{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘，非技术","slug":"语摘，非技术","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98%EF%BC%8C%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"VSCode 中自定义代码模板（snippet）","slug":"VS code中建立代码模板","date":"2022-01-05T14:01:55.000Z","updated":"2023-03-15T13:22:13.577Z","comments":true,"path":"2022/01/05/VS code中建立代码模板/","link":"","permalink":"http://example.com/2022/01/05/VS%20code%E4%B8%AD%E5%BB%BA%E7%AB%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/","excerpt":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。","text":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。 具体操作倒也不难，如下： 1.打开VS code，选择文件 =&gt; 首选项 =&gt; 用户片段 =&gt;选择对应的语言 在弹出的以下窗口中选择对应的语言、文件夹或全局，则，仅会在该语言环境、该文件夹抑或全局触发补全该代码片段。此处我以C++为例了。 2.输入代码 在弹出的窗口中，你能看到已经有数行注释如下 12345678910111213// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected.// Example:// &quot;Print to console&quot;: &#123;// &quot;prefix&quot;: &quot;log&quot;,// &quot;body&quot;: [// &quot;console.log(&#x27;$1&#x27;);&quot;,// &quot;$2&quot;// ],// &quot;description&quot;: &quot;Log output to console&quot;// &#125; 事实上这段英语教程已经说得比较清楚，但是作为英语苦手，还是有一定的理解苦难，这就是这篇博文诞生的原因。下做翻译补充： 每一个“代码片段”都应该由如下三部分构成，前缀（prefix）、主干和描述。 前缀是代码片段的触发器，当你在编辑代码时输入前缀（的部分），VS code 就会联想到你的对应代码片段； 主干是被补全的内容，也就是“模板”部分。你应该把代码分行写在 body 的中括号内，并把它们用双引号包括起来，同时在引号外别忘了添加逗号。即 1&quot;your code here;&quot;, 描述被用来描述代码片段的作用，当你有多个相近名字的代码片段时，这无疑有助于你区分它们。此外，这部分也允许你输入中文，或干脆不写（尽管不建议）。 需要额外注意的是最后提到的由 $ 开头的这个小功能。 它的写法是 $加一个数字或在 $ 后的大括号内依次写入”数字”“冒号”和“占位字符串”。如 123$0$&#123;1&#125;$&#123;1:spaceholder&#125; 在补全代码后，你的光标会首先停在数值最小的一个 $ 字符处，随后每次按 Tab 依次停在次小的 $ 处，最后停在代码片段的末尾或你指定的 $0 处。（尽管测试下来允许数字不连贯，但是我建议还是使用连贯的从1开始的数字比较好）。如果有多个相同数字的地方，那么光标会同时存在于这些地方。 在上方 spaceholder 部分，你可以填入默认的代码，它们在会光标（按 Tab 转移到此处时被选中以备替换）。 3. 实例 接下啦，仿照给出的 Example 在下方输入你的代码即可。 123456789101112131415161718192021222324252627&#123;//这个括号是默认生成的 &quot;Print to sample&quot;://sample字段可被替换，还没找到其意义 &#123; &quot;prefix&quot;: &quot;test&quot;,//触发词 &quot;body&quot;: [ &quot;#include &lt;iostream&gt;&quot;, &quot;#include &lt;cstdio&gt;&quot;, &quot;&quot;,//这是一个空行 &quot;using namespace std;&quot;, &quot;int $&#123;1:i&#125;;&quot;, &quot;$0&quot;, &quot;&quot;, &quot;int main()&quot;, &quot;&#123;&quot;, &quot; scanf(\\&quot;%d\\&quot;, &amp;$1);&quot;,//在上方写了占位符后，这里可以只写一个数字 &quot; return 0;&quot;, &quot;&#125;&quot;, ], &quot;description&quot;: &quot;一般性简单cpp模板&quot; &#125;,//逗号在有多个片段的时候有意义 &quot;Print to another_sample&quot;: &#123; ... &#125;&#125; @import &quot;D:\\Users\\uftx\\Documents\\hexo\\source_posts\\avatar.jpg&quot;","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"中国游戏产业现状————思政课堂演讲稿","slug":"中国游戏产业反思","date":"2021-10-26T09:40:33.000Z","updated":"2023-03-15T13:42:57.917Z","comments":true,"path":"2021/10/26/中国游戏产业反思/","link":"","permalink":"http://example.com/2021/10/26/%E4%B8%AD%E5%9B%BD%E6%B8%B8%E6%88%8F%E4%BA%A7%E4%B8%9A%E5%8F%8D%E6%80%9D/","excerpt":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿","text":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿 谈谈中国游戏产业的监管和未来 中国的电子游戏产业是怎样的？ 中国的电子游戏产业为什么是这样的？ 中国的电子游戏产业在往哪个方向发展？ 我们如何看待它？我们能明白什么？我们如何改进它？ 注意： 如无特殊说明，主流游戏指代的是当今世界上的主流游戏形式，即以主机为、PC为主要发行渠道的各类大型电子游戏。 如无特别说明，游戏指的是在主机，PC，掌机，手机等各类平台运行的电子游戏。 中国的电子游戏产业是怎样的？ 中国游戏产业发达 我们有丰富的证据说明中国游戏市场的发达： 中国目前已经成为世界上最大的游戏市场，游戏用户高达6.6亿，实际销售收入两千七百多亿。是世界第一大游戏市场，有超过1/4的游戏用户都在中国。 中国腾讯是世界第二赚钱的游戏公司（2020），王者荣耀、英雄联盟、穿越火线、刺激战场都是堪称全民级游戏。 中国是电竞大国，数度在英雄联盟、DOTA2等领域捧回冠军。例如2018年，现象级的IG夺冠事件（英雄联盟S10），又如，已经成功举办9九届的Dota 2Ti赛事中，中国除2013年 Ti 3外，始终占据前三之一，在2012、2014、2016年更是夺得世界冠军。 中国游戏产业艺术属性、文化属性缺失 但是，中国游戏业的发达之下，掩盖的问题是，中国游戏缺乏艺术性，难以做出让中国人叫号的游戏；缺乏文化属性，难以做到对外输出中国影响。 自从《征途》之后，国内主流的游戏类型成了基于电脑的网络游戏，而大约十年前，国内主流又变成了手机游戏。以至于有些不太关心游戏的人甚至觉得现在没人玩电脑游戏了。 这并不是说网络游戏、手机游戏低人一等，相反，从商业的角度来说，它们是更先进、更发达的形式。但是我们也需要指出，只点“网络游戏”、“移动游戏”的科技树的后果是，国产游戏并没有完全发挥游戏作为文娱产品其艺术一面的功效。 这是因为，从本质上来是，单机游戏和网络游戏是两个不一样的东西。前者卖的是产品，后者卖的是服务。单机游戏作为产品，它在内容体验上是完整的、大致固定的。而网络游戏作为服务，为了让用户持续的玩下去，体验是不完整的、持续时间是不定的。而且，这意味着，如果我们想用游戏来阐述一个富有魅力、打动玩家的故事较为困难。 而且，由于网游是提供服务，吸引玩家充钱，而不是做出好玩的游戏然后吸引玩家交钱。因此网游的重心必然是在吸引充钱上，这也无形中降低了对剧情等内容的重视程度。 尽管有王者荣耀里有对历史原型人物的科普等相对正面的例子，但是整体上我们的游戏业并没有把弘扬中国文化这一块做好。例如，许多外国人对中国三国文化的认识来自于日本的《三国志》等游戏，对内，反映我国群众思想、喜好、生活的游戏也并不多见。 中国游戏长期与社会割裂 由于中国长期以来以PC和移动端为主的网络游戏占市场主流，加上社会对电子游戏存在的较大偏见，导致了社会认知中的游戏和实际上的游戏业是割裂的，带偏见的。 例如，许多人觉得现在没有什么电脑游戏了。 有的人觉得，玩游戏还要买简直不可理喻。 有人觉得游戏就是“电子鸦片”、洪水猛兽。 针对近期新闻出版署公布的未成年防沉迷规定，玩家们就改出了许多不同的梗图以作对“家长”们的嘲讽【此处应有图】 种种和实情相去甚远的偏见不仅使得游戏业的发展受到来自社会舆论方面的较大阻力，也使得监管层迫于舆论压力对行业动手。 中国的电子游戏市场为什么是这样的？ 这个问题可以谈很长， 我们可以批评中国不像美日有深厚的桌游史，因此没有继承游戏文化，才导致畸形发展。 可以批评是血狮为代表的发行商们寒了中国玩家的心，让投资者和玩家都不愿意购买中国单机游戏， 可以批评是以史玉柱的征途为代表的一系列强氪金网游压死了中国游戏商。 可以批评中国家长，他们总是“以孩子玩了怎么办”阻碍中国游戏脱离幼稚的主题和画风。 但是，我们认为中国游戏监管是中国游戏业成为当今形态的主要原因。（请注意，这并不是说监管是唯一原因，也不是说监管方是一切问题的根源） 下面，由三个重要政策的颁布浅窥监管对游戏业的影响。 游戏机禁令： 70年代，雅达利制造出世界上最早的游戏机，电子游戏产业逐渐萌芽。90年代，乘着改革开放的东风，游戏机和游戏文化传入了中国。由于当时政府管制不到位，大量企业依靠山寨外国游戏机（小霸王），盗版或仿制外国游戏起家。在对企业监管都不到位的环境里，对个人的监管就更不可能到位了。在当时，黑网吧、黑街机厅等遍地。不可否认的是，在这类场所，人员往来成分混杂，争吵斗殴不时发生。 2000年，光明日报两度刊文分别以《别让游戏机害了一代人—一位母亲的呼吁》和《观点：电脑游戏是瞄准孩子的“电子海洛因”》批评（黑）游戏机（厅）。文章认为，游戏机是毒害青少年的”电子海洛因“，不仅容易上瘾，而且会诱导逃学、夜不归宿、甚至抢劫等不良行为。这引起了孩子被游戏厅毒害的父母的共鸣，社会上引起轩然大波。六月，国家七部门联合发布《关于开展电子游戏经营场所专项治理的意见》（俗称游戏机禁令）。尽管该意见的对象是街机游戏机（而不是家用机），但是在具体的实行过程中，最终演变成了所有游戏机。 家用机（俗称游戏主机）在中国正规市场的消失，无疑是造成了主机游戏在中国的绝迹的直接原因。而世界的主流游戏形式依然是主机平台为主的。换言之，中国的玩家从此很难玩到大部分国外优质游戏，中国游戏开发商也几乎不会进行主机游戏开发。 这就导致了中国转向以PC和手机等非完全游戏设备上的游戏开发（由于有非游戏需求，不能被禁止）。而PC平台的开放性引发的盗版传播潮，又使得中国的游戏形式转为是以免费内购制联网游戏为主。 这一转向，使得付费单机游戏被中国彻底抛弃。中国单机游戏市场萎靡不振，与百花齐放的国外游戏市场形成鲜明对比。 如今，电子竞技在国内引发热议，不仅受众甚多，国际赛绩不俗，而且电竞专业、电竞酒店、电竞馆、电竞电视剧各类衍生品也层出不穷。某种程度上，也正是游戏机禁令的衍生物。 游戏版号制度 2004年，文化部建立网络游戏内容审查制度，在新华网的一篇采访中提到，审查的目的因为 一是网络游戏产品中存在色情、暴力、赌博、愚昧、迷信以及危害国家安全等不健康内容； 二是未经内容审查的境外网络游戏产品充斥我国网络游戏市场，市场绝大部分为境外产品，大约占８０％以上； 三是容易影响缺乏自制力的未成年人的身心健康，有的深陷其中、不能自拔并诱发一系列社会问题。 而违规内容简单的概括，有：反国辱国、违背社会公德、邪教、谣言、宣扬色情赌博暴力等。 这些规定有问题吗？似乎没有。但是，版号下发数量稀少，具体过审规则暧昧，尤其是在前几年下发还不是依据申报前后、不分企业大小排队的情况下。版号制度事实上极大的打击了中国中小游戏开发商。他们很难拿到版号，即使拿到版号，为了过审，也不得不大量删改内容。 这一制度，给有心做出中国好游戏的中小型开发商又套上一层枷锁，磨灭了独立游戏在国内存在的土壤，加剧了市场中马太效应的作用。 同时，由于文化讨论更容易触犯规则，一个版号吃多年的网络游戏比几年一换的单机游戏申报成本更低，游戏商们也更不愿意做剧情、做价值输出内容。更不凸显网络游戏作为文化产品，其文化和艺术性一面的作用。游戏们变得剧情上乏味而空洞。 最糟糕的是，缺乏正规渠道接触优秀电子游戏使得孩子们认识游戏的渠道极容易出问题——而这又恰恰很有可能导致孩子成绩下滑暴力等问题，因为一些国外认定18+甚至的血腥暴力以及色情游戏可以在国内轻易获取。 最近的精神鸦片事件 在2017年PUBG的大热，曾经以CS而为人熟知的Steam平台再次进入大众眼线。 Steam是美国Valve公司开发的游戏平台，由于并非中国企业，在Steam上架游戏并没有版号要求，因此在意识到steam上有广阔的国内和国际市场后，许多独立游戏开发者开始将尝试把自己的游戏上架Steam。于是，我们惊奇地发现，中国游戏产业并非烂泥扶不上墙，并不是没有做出好游戏的能力。 没有雄厚技术和资金的国内独立开发者们做出了包括《中国式家长》、《太吾绘卷》、《戴森球计划》、《烟火》、《暗影火炬城》等题材不同、玩法不同的好游戏，他们中的不少都曾经打入steam周销量榜前十（全球），引起国内外玩家热议，而《动物派对》登陆2021年（全球最大游戏展之一的）E3游戏展微软展台，《黑神话：悟空》得到了几乎整个中国游戏圈子的追捧，更是引来国外众多游戏开发者与玩家的热议…… 不止如此，就在今年七月末公布的《2021-2022年度国家文化出口重点企业和重点项目名单》中，不仅有58家游戏公司在列，还有包括《明日方舟》、《原神》、《贪吃蛇大作战》、《波西亚时光》等八款游戏。 这些在海内外都有巨大反响的游戏，证明了中国开发者完全有能力做出优秀的游戏。然而… 就在公布上述名单后不久，央媒经济参考报发文《“精神鸦片”竟长成数千亿产业》短短四个小时内，腾讯股价下跌约9%，心动网络下跌约13%，网易下跌约15%，中手游下跌约20%……各大厂商累计蒸发市值约三千亿。 尽管四个小时后，这篇被炮轰“来自二十年前”的文章就遭到删除。但是腾讯当天依然迅速推出双减双打政策进一步限制未成年人游玩。后面的事情大家都知道，30号，国家新闻出版署出台政策将未成年人的游玩时间杀到每周三个小时。而八月开始，八、九、十三个月游戏版号无原因的停发了。而上一次（2018年）大半年的停发，仅腾讯市值蒸发1500亿美元，最低时，仅有停发前的约六成。 当今游戏监管的不确定性和对游戏市场的影响力可见一斑。 如何看待中国游戏产业？ （当下：）游戏已经成为年青人的生活方式 在2020年，中国已经超越美国，成为世界第一游戏产品消费国，其中主力是18-22岁的青年人。不少人以前不玩游戏，但是却被身边的人带入了王者荣耀全民电竞“坑”，又或者开始了解原神是怎么回事。在游戏平台steam上，中国已经成为最大的购买来源群体。越来越多的外国游戏开始将中文、尤其是简体中文作为游戏标配，甚至有独立游戏开发者抱怨因为没有成本进行中国的本地化工作导致游戏遭到差评轰炸等问题。 而各类游戏的新闻在社交媒体上也都相当有话题度和二创活力。游戏内的一些术语例如白嫖、氪金、肝帝、开黑、PK、欧皇等词汇也早就超出游戏范畴，成为日常生活的一部分。 不仅如此，通过二创和衍生周边等，游戏还带动了网络文学、动漫、电影、电视剧、广告、电竞、网络直播和VR等产业的发展。 而在开发者一侧，越来越多的人开始对游戏制作感兴趣。各类小型团队活跃在taptap、steam等游戏平台上。甚至也不乏游戏科学这样从腾讯离职创业的团队。他们今年八月末的视频，截至10月12日依然有100多人看，斩获两千多万的播放量（仅B站）。 从这个角度来看，游戏产业和青年人联系紧密，是一个极其活跃的群体。 （未来：）游戏产业正期待变革 首先，我们需要指出的是，尽管我们前面写了许多监管的不好。但这绝不意味着游戏业是不需要监管的。游戏业是一种文化产业。无论中外、无论古今，都必须受到监管。这才是对游戏及其他任何文化产品负责任的做法。 而正如刚刚我们所说，游戏产业是一个广受当代青年、少年、孩子喜爱的的产业。无论我们承不承认游戏是所谓第九艺术，游戏作为一种新兴的、与国家未来们密切相关的行业，都需在正确的、合理的监管下健康发展。而这正是我们目前所缺乏的。 一方面，历史上的错误决策导致了如今腾讯网易形成垄断，在缺乏竞争的市场环境下，它们缺乏创新动力。大厂没有创新意愿等问题，进一步的就导致国内游戏业人才凋零、技术落后，削弱国产游戏竞争力。 另一方面，如今又一次趋严、趋保守的监管，对游戏业过于严苛，不仅甚至有可能抹杀现有的游戏出海热等繁荣状态，而且政策上的消极，也会加重社会上部分媒体、家长对游戏本就存在的偏见，使得“电子海洛因”的形象更深入人心。 作为一个庞大而年轻的产业，游戏业的发展离不开监管层对审核标准的进一步放开。越来越开放的的中国、日益热闹的游戏开发行业和广大的游戏玩家们，也呼唤着更规范而开放的监管层的出现。 而监管层呢，近年来也在有意放松，例如，2015年，游戏机禁令取消，我们能在正规渠道买到游戏机了。2020年，游戏适龄提示上线，有了些游戏分级的影子，甚至新闻出版署的未成年游玩限制新规出台，玩家们都疯传这样一种说法：新规意在堵住觉得游戏是坏东西的部分家长一口。而对于家长更开明的那些孩子而言，家长并不会介意帮助实名，因此不会受到影响。【此处需要图】 因此我们有理由相信，游戏产业监管正需要且正迎来一场变革，游戏监管一定会更加合理。使得游戏产业不仅有机会成为拉动经济增长的新力量，也成为我国文化输出的一大亮点。 （过去：）游戏（的监管史）是代际隔阂的当代写照 任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分。任何在我15-35岁之间诞生的科技都是将会改变世界的革命性产物。任何在我35岁之后诞生的科技都是违反自然规律要遭天谴的。 以《银河系漫游指南》闻名的科幻小说作家道格拉斯·亚当斯曾经写下上述这个著名的“科技三定律”。这虽然夸大而滑稽，却深刻反映了许多问题，例如，世风日下、人心不古这两个词语是怎么来的。例如，为什么金庸的武侠小说从孩子们偷着看变成了老师的推荐数目，周杰伦从“话都念不清楚”的差劲流行歌手变成了当代流行音乐天王。 有个网民【未知】曾经辛辣的讽刺： 我们不需要知道电子游戏是什么，它会不会造成近视，它会不会上瘾, 我们只需要一个背锅侠，一个可以掩盖家庭教育失败、 学校教育失败、社会教育失败的东西， 现在它叫游戏， 十五年前它是早恋, 三十年前它是偶像, 三十五年前它是香港电影， 四十年前它是武侠小说 这指出了部分家长的甩锅心理，但是我们要说的，他们之所以甩锅给游戏，正是因为他们带着偏见的眼光中，游戏是不好的。当代游戏产业的许多不合理之处，我们骂莫名其妙的监管、贪婪无度的游戏公司、骂不明事理的熊娃家长……说到底，就是在骂那些觉得游戏是“违反自然遭天谴的”，骂那些觉得自己不懂的产业就带着原罪的人。试想：如果监管者觉得游戏是大毒草，游戏的审核又怎么能公平合理呢？如果游戏公司老板觉得游戏就是一个捞快钱的地方，我们的游戏又怎么可能会吸引到玩家的注意力呢？如果家长觉得游戏是电子海洛因，又怎么可能在孩子成绩下降后不怪罪呢？ 如果我们今天只谈游戏产业受到了歧视和偏见，也许有朝一日随着玩游戏的一代人长大，游戏不会再被污名化，但是却会有其他产业被污名化。(例如短视频?）。从这个角度来看，游戏产业不过是当代文化产业快速发展大格局下，被推出来背“世风日下”这口大锅的那个。这是游戏产业的悲哀，也是每一个新兴文化的悲哀。 当然，正如我们也能看到一些开明的家长，一些孩子高三了家长帮忙上号代打的新闻等等，所谓“科技三定律”其实并非“定”律。这是可以改变的。一方面，做为玩游戏的青年人，我们有义务为游戏（和其他的新媒体、新文化）正名，为之发声，让更多家长辈的人明白、理解，游戏其实并不特殊，它不过是当代的一种新娱乐方式而已。另一方面，作为反思，我们是不是也在不知不觉中犯了类似的错误呢？生为00后的我们，对10后的娱乐是否又认真了解过，而不是简简单单的一句“哼，小孩子玩的”带过呢？ 愿我们都能多一些理解，少一些理所当然和“世风日下、人心不古”。 【报告结束】","categories":[{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"}]},{"title":"古埃及旅游指南 || 三、古埃及的一些事物与文化","slug":"古埃及旅游指南：文化篇","date":"2021-01-18T11:17:30.000Z","updated":"2023-03-15T12:30:02.139Z","comments":true,"path":"2021/01/18/古埃及旅游指南：文化篇/","link":"","permalink":"http://example.com/2021/01/18/%E5%8F%A4%E5%9F%83%E5%8F%8A%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97%EF%BC%9A%E6%96%87%E5%8C%96%E7%AF%87/","excerpt":"提要：这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。","text":"提要：这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。 古埃及的墓穴和葬仪 在古埃及对国王和大多数社会阶层而言，在思想上进行统治的一个非常重要的方面就是丧葬祭仪。不朽的陵墓建筑和丧葬祭仪象征着国家和统治机构。有些坟墓周围埋有陪葬者。例如埃及第一王朝第三任国王哲尔，他的墓穴周围有300多个陪葬者，这也是埃及历史上唯一用活人陪葬的时期。第二王朝的国王不再采用这种仪式。 木乃伊 木乃伊虽然不是古埃及的专利，但是古埃及的木乃伊无疑是最有名的。埃及神话相信死者会再次苏生，所以想方设法的保护死者的躯体也就成了一件重要的事。 不仅是法老，一般人的死也会经历木乃伊化的过程，尽管不同年代、不同阶层有很多区别，但是粗略来说，古埃及人会把死者的内脏等清理干净、涂上油防腐、还要裹上亚麻布。然后和其他的陪葬品一同安葬。 木乃伊也不是人的专属，很多的动物，尤其是猫，不仅是神圣的女神巴斯特的象征，还能抓耗子保护谷物，还可爱。 也经常被做成猫乃伊。 石棺铭文 虽然君主的权威在不断增强，但古王国末期和第一中间期的混乱局面大大削弱了王权在人们心中的地位。王权不再像过去那么神圣，在宗教上的权威地位也大打折扣。从人们去往来生世界的某种更为民主化的形式，可以明显的看出这一点。包含在金字塔铭文中的咒语经文，不再是国王和王后所独享的特权，而是只要买得起，任何人都可以将其刻在棺柩上。这就是我们所说的“石棺铭文”。中王国时期，铭文的数量激增，为我们提供了比古王国更多更直接的历史资料。这一时期的语言成了古埃及时期的标准经典语言，即中古埃及语。预言书，道德故事，赞美诗等叙事体文学作品大放异彩，成为中王国时期重要的文化成就之一。这些作品中最著名的是《西努赫流亡记》和《遇难水手的故事》，在中王朝结束很久之后，这两个故事仍然为人们所传播 古埃及丧葬习俗（英文）： https://en.wikipedia.org/wiki/Ancient_Egyptian_funerary_practices 医药 如果单就文字的运用而言，有许多时候和一般所谓的文学不同的实用性文字，埃及人的实用性格在这类文献中有清楚的表现。首先是医药方面的作品，用现代的概念来说，有属于医理方面的手册，包括对疾病的判断，或者治疗疾病的方法，也有属于药方之类的作品，虽然其中有时不免有巫术之类的手段。在一卷有关外科手术的文献中，我们可以看到以下记载：若你检查一个头部受伤者，伤势深入头骨，但并没有伤口，你应该轻触他的伤处。如果你发觉他的头骨没有受损，没有穿洞，没有裂痕或破碎，你应该对他做如下的诊断：“此人头上有伤，伤口没有裂开，虽然伤势深入头骨。这个伤我可以治。”你应该在第一天时将伤处用新鲜的肉敷住，而后每天施以油脂，蜂蜜，绷带，直到他康复。在古代世界中，埃及的医学的确是相当著名，许多希腊时代的作品都提到埃及医学和药物对他们的影响。而埃及人制作木乃伊的习俗也很可能与埃及医学中外科医学的发达有某种关系。 数学和几何 埃及人在建造金字塔和神庙这类的建筑活动中显然必须依靠相当精确u的数学计算，否则不可能成功。不过埃及的数学基本是从实用着眼，只求能够解决实际的问题，而没有理论上的兴趣。我们目前有关埃及数学的了解主要来自中王国时代的两份草纸文书，以及一些较晚而零散文献。基本上，埃及数学以十进位，而他们只用单位分数，如1/2,1/3,1/4等等，唯2/3例外。因而3/4是以1/2加1/4来表示。而数学的基本运算是以加法和倍数为基础，例如13乘以17，埃及人的写法是： ![img](file:///C:/Users/uftx/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg) 答案是将左边取1+4+8=13，右边相应地取17+68+136=221，结果为13*17=221。除法也用相似的方法，只是倒过来。至于几何学，埃及人的水平也大致限于简单的面积和体积的计算，但显然这些已足够让埃及人得到实用的数据。 法老的胡须 毛发是容易藏污纳垢的地方，所以爱干净的古埃及人就想了聪明的办法：把原来的毛发剃掉，然后戴上假发和假胡须。就能美观又干净了【如下图】 一个小细节是，法老在世时的胡须是直的，逝去的法老的胡子则和神的一样是弯的。这是因为法老去世是被认为回归神明之列。 参考： 古埃及练习曲，头发与假发（上），（繁体字） 知乎，法老的胡子有什么特殊的含义吗？ 努比亚人 努比亚人是埃及人的南方邻居，和埃及关系密切。埃及第25王朝就是努比亚人的王朝。而八爷担任的职务：守护者，职责最初就来自努比亚人的文化。 芦苇（莎草）、芦苇船、莎草纸 在埃及的绿洲边，常常能发现一种高大的草，这就是莎（suo）草，也被称做芦苇。（尽管生物学上来说芦苇和莎草是不同的）。有芦苇，就有水，有绿洲和肥沃的土地。因此古埃及人特别喜爱芦苇。 他们不仅用它做出了莎草纸、芦苇船，用芦苇的根茎作为神的贡品，对于死后天堂的描述也是一片长满芦苇肥沃的土地——芦苇原。 莎草纸，也许是世界上最早的一类纸，古埃及人从公元前3000年开始就用这种纸书写（这个时候，中国真处于尧舜禹的时代，再过三千年多年，东汉蔡伦才改进造纸术）。 不过，因为莎草只长在埃及地区，又不耐潮湿，在埃及以外的区域普及度并不高。所以在羊皮纸和更后来的中国纸的普及下莎草纸就逐渐失传了。不过，经过上个世纪的一个埃及工程师的研究，人类重新发明了莎草纸的制法。（尽管并没有什么使用价值就是了） 芦苇船，字面意思，就是用芦苇编成的船。在游戏中有两种小船，一种是士兵们坐的木制兵船，另一种则是平民们划的装满蔬果的芦苇船，如果用带火的箭头靠近船身，很快就会看到船被点燃。 参考： 维基百科，莎草纸：https://zh.wikipedia.org/wiki/%E8%8E%8E%E8%8D%89%E7%BA%B8 维基百科，纸莎草：https://zh.wikipedia.org/wiki/%E7%B4%99%E8%8E%8E%E8%8D%89 三桨座战船 游戏里出现频率最高的战船（兵营），古代希腊人和罗马人的一种战船，所谓三桨座的就是一边有三排桨。 参考： 刺客维基，三列桨座战船 三个桨的排布可参考维基百科下图【插入维基图片】 战象 大象皮糙肉厚，体型庞大，无论是实际战力还是对人的压迫力都极强。因此波斯帝国在和印度交战的过程中，学会了驯化大象进行战斗。之后，这一技巧又被与之交战亚历山大大帝学到。托勒密王朝最后从亚历山大人那里继承这一手段。此外，罗马人的老对手，迦太基人也点出了驯化非洲象作战的技能，并在布匿战争中被罗马人学会。这就是为什么我们能在特定的兵营里挑战罗马的战象。 埃及王冠 正如我们在历史篇中提到，埃及是由上下埃及两片构成。上下片无论是地形水土还是文化都有一定差别，因此，埃及王冠由上下埃及王冠合在一起构成的，表示法老同时统治上下埃及。 外圈是下埃及之冠，由于颜色，它也被叫做“红冠”。 内圈是上埃及之冠，由于颜色，它也被叫做“白冠”。 所以完整的王冠也就可以简单粗暴地叫做“红白双冠”。 同时，为了表示神的庇佑，在王冠前端还有上下埃及守护女神的象征，眼镜蛇（下埃及女神瓦吉特）和秃鹫（上埃及女神奈赫美特）。需要提醒的是，秃鹫女神奈赫美特不是母狮女神塞赫美特。 圣书体 圣书体顾名思义，是书“圣”的字体。这是一种用于给祭司们书写祭祀等神圣之事的字体。在游戏神庙的墙上就能看到。虽然随着古埃及文化的消亡，圣书体最终失传，但是它是世界上几乎所有字母系统（例如英语中的ABCD）的起源。 埃赫那顿事件（要不要放进游戏后篇呢） 埃赫那顿是新王国时期的十八王朝的一位法老。在他在位的年代，他干了一件惊世骇俗的事情：对宗教进行改革，否认拉、荷鲁斯、阿蒙等神的存在，认为世界上只有一个神，也就是太阳神阿顿，有人认为这是世界最早的一神论——要知道这个时候是公元前1000多年前！不仅如此，埃赫那顿还把都城由底比斯迁到新修的埃赫塔顿（这个名字也是为了纪念阿顿神） 不仅如此，他的王后也不同寻常。王后娜芙蒂蒂美貌惊人，而且很有能力，她和丈夫一同推进宗教改革、而且拥有一些以往只有法老自己独占的权利，甚至有埃及学家怀疑埃赫那顿的继位者斯门卡瑞就是娜芙蒂蒂化名。 尽管埃赫那顿统治了不短的时间，但是在他去世后，宗教改革成果还是迅速被不满的祭祀们破坏了。斯门卡瑞短暂的统治之后，法老之位传到了埃赫那顿的儿子图坦卡蒙手上。年幼的图坦卡蒙即位后，立即将名字由图坦卡顿（也就是“阿顿的人间化身”）改为图坦卡蒙（“阿蒙的人间化身”），他还把首都迁回底比斯、把父亲的墓改迁回传统的帝王谷、恢复祭司们的职位……而埃赫那顿、阿顿等名字也被刻意的从碑文上抹除，成为一段被刻意避讳和遗忘的历史。 图坦卡蒙的墓 在古埃及王室，近亲结婚现象非常普遍，即使到了八爷的托勒密时代也是如此。而图坦卡蒙，是埃赫那顿和他的姐妹（被埃及学家称为“年轻女士”）的孩子。近亲结婚的后果之一，就是严重的遗传病，根据科学研究，图坦卡蒙有包括脊椎侧弯和兔唇、骨组织坏死等种种疾病，年纪轻轻就需要拄拐杖，最后19岁就英年早逝。 图坦卡蒙之墓在上世纪20年代被英国的一行考古团队找到。保存得极其完好的图坦卡蒙墓不仅成为考古学的大发现，还引起全球轰动。而数位早期探险家的早逝，也引发“法老的诅咒”这一谣言，给古埃及文化戴上一层神秘魔幻的面纱。从那以后，的电影、小说、游戏在使用古埃及的文化形象。某种程度上来说，今天能玩到刺客信条起源，也离不开那次图坦卡蒙之墓被发掘的影响。 为什么游戏里图坦卡蒙和娜芙蒂蒂的死后世界入口在一个墓里呢？这是因为在2015年，科学家们发现图坦卡蒙之墓似乎是改建于在一个女性的墓，而这个女性，就极有可能是被祭司们试图抹杀存在的娜芙蒂蒂王后之墓。 参考： 维基百科-图坦卡蒙 古埃及练习曲，2015年度風雲人物──圖坦卡門","categories":[{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"},{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"}]},{"title":"搭建个人博客 || 二、域名跳转和写博客","slug":"搭建博客/个人博客上岸回顾(二)","date":"2021-01-18T11:17:30.000Z","updated":"2023-06-09T01:22:46.376Z","comments":true,"path":"2021/01/18/搭建博客/个人博客上岸回顾(二)/","link":"","permalink":"http://example.com/2021/01/18/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%8A%E5%B2%B8%E5%9B%9E%E9%A1%BE(%E4%BA%8C)/","excerpt":"提要：如何把域名解析到自己的网址和输出内容","text":"提要：如何把域名解析到自己的网址和输出内容 前言首先声明，把域名解析到自己的网址不是必要的，扔在 GitHub 就挺好。不过为了简洁好记和个（耍）性（帅），而且手上“恰好”有一个域名，那干嘛不折腾一下呢？并不是因为重新入坑所以把后期内容提上来了 确实还有很多事想做的！换背景、加音乐、换主题……但是内容永远是第一位的。所以，我们先讨论如何写博客。 写博文关于Markdownhexo 下博文以 Markdown 格式存储于本地，也就是 part 1 中我们一开始新建的文件下。因此，我们需要一款 Markdown 文本编辑器。目前我的 Typora 使用手感尚好。够简洁优雅，” 所见即所得 “ 的特性对萌新也够友好。你可以从官网下载到它。 至于 Markdown 的语法，建议花五分钟在百度上，然后熟能生巧即可。额外一提的是，hawa130 那学到的在字母数字前后空一个空格的习惯很棒，建议养成。（欸？真的有人来看？） 文章的模板你一定注意到，正如这篇博文，有创建日期、标签和目录等信息，这些非正文内容存在于文章的开头，形式如下： 这一部分由 hexo 生成，在 Git Bash 中使用 hexo new postname 生成一篇名为 postname 的新博文 。 而其模板在博客根目录\\scaffolds\\post.md 文件中。推荐添上 categories 和并在正文中写下““””文章在此处折叠）。 当然，此处还有 draft 和 page 两个模板，由于本人目前写文章是写好一篇更新一次，所以 draft 等没有用上。目测 draft 是上传至 GitHub 但不发表，page 则不知道由什么用。 写好以后，打上合适的 tags 和 categories ，再重新部署（hexo d）一下，就可以在博客上看到自己的新文章了！（顺便一提，多 tag 的格式如图哦） 域名解析","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]},{"title":"搭建个人博客 || 一、在本地搭好博客","slug":"搭建博客/个人博客上岸回顾","date":"2020-10-26T16:37:19.000Z","updated":"2023-06-22T08:19:48.504Z","comments":true,"path":"2020/10/27/搭建博客/个人博客上岸回顾/","link":"","permalink":"http://example.com/2020/10/27/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%B8%8A%E5%B2%B8%E5%9B%9E%E9%A1%BE/","excerpt":"前言本博客搭建于大一 2020，同时写的教程，已于 2023 年重新编辑。","text":"前言本博客搭建于大一 2020，同时写的教程，已于 2023 年重新编辑。 介绍关于这个博客：本博文的目的，与本博客本身，是一个托管于 Github Pages，基于 Hexo 的静态博客网，主要参考资料是本文末中的第一个视频。搭建时的主要目的是完成 MSC Web组的初面。 关于这篇文章：本文首次发布于 2020 年 10 月，初衷是为了回顾厘清懵懵懂懂、混混沌沌的搭建过程。而且那会还幻想着会有人来看（当然也不能说现在没有在幻想）。现在回过头来看不免觉得很多地方由于本身的理解不到位而表达含混甚至错误、还有一些刚刚搭建好博客带来的自我意识过剩，而且最后还烂尾了。因此近期终于感觉有时间和足够的理解后决定重新编辑并补完，但是我的目标仍然是尽力将其写成完全小白向的风格。 配置 hexo 环境OS：Windows 10生成：Node.js + hexo托管：GitHub Node.js 在官网下载安装即可。安装完成后，在控制台（例如 cmd 和 PowerShell ）运行node -v和npm -v应当可以看到 node.js 和 npm 的版本号。（关于控制台、终端和shell，可以参见【占位符】） Node.js 是一个开源的 Javascript 运行环境，它由 OpenJS 基金会维护和持有。所谓运行环境，可以说成是前置条件或者说充分条件，一个更好理解的例子是 C 的环境：一个文本编辑器（写代码）和一个编译器（把 C 代码转换为机器语言）。我们使用 Node.js 运行 JS 脚本。NPM 是 Node.js 的包管理器。大概可以理解为“插件管理器”，类似的包管理器还有 python 中的 pip 和Linux 下的 apt。在控制台（ cmd 和 PowerShell ）运行node -v和npm -v应当可以看到 node.js 和 npm 的版本号。 Git 官网下载。使用 git -v 检查是否安装成功与安装版本。 Git 是一个分布式版本控制软件。关于通过使用版本控制来管理博文，可以参见后续的文章【占位符】。在这里，我们的主要目的是通过 git 将我们的文章推送到远端 GitHub 仓库。 cnpm 与 npm Node.js 是由 OpenJS 基金会持有的软件，但其附带的包管理器 npm 则属于 npm 公司（已被 Github 收购）。npm 的默认下载源是从 npm 公司的公开下载源：https://registry.npmjs.org/ 进行下载（下载源的官方用词是 registry，注册表）。它收录 npm 账户用户公开发布的包。如果好奇关于注册表和在 npm 上发布包的问题，可以参见下面的官方文档： registry | npm Docs Creating and publishing scoped public packages | npm Docs 不过这就离题太远，就此打住。 普适地说，直接使用 npm 就可以下载安装 hexo 了。不过在国内使用默认注册表通常都会存在下载速度的问题。常见的解决方法有配置 Node 的代理（配置方法网络上很多，这里不叙）和更换下载源。许多组织会维护官方镜像站，他们同步官方站点。这样如果不便访问官方站点，就可以把下载源换为镜像站的源。 更换下载源的三种方式(第二类中所有方式我都没有尝试) 临时切换：npm install your-package --registry http://your.registry.source 长期切换： 命令行：npm config set registry http://your.registry.source; 环境变量：NPM_CONFIG_REGISTRY中写入https://registry.npmmirror.com; .npmrc文件中写入：registry=https://registry.npmmirror.com。 使用cnpm：这是我们采取的方式。 需要注意的是长期切换中的所有方法我都没有用过，仅是作为一个简单记录。 cnpm 是阿里云推出的的另一个 npm 客户端，它和 npm 的功能完全一致，只是没有 publish 功能。使用 cnpm 的优点在于可以使用 cnpm 的默认国内源进行下载，同时在需要使用官方源的时候不用修改下载源。在命令行界面下，键入npm install -g cnpm --registry=https://registry.npm.taobao.org，从https://registry.npm.taobao.org 安装 cnpm。 使用 npm config get registry 检查 npm 的下载源，cnpm config get registry检查 cnpm 的下载源。可以发现 npm 的默认下载源没有改变，cnpm 的默认下载源不同于 npm。 hexo cnpm 安装完成后，使用 cnpm install -g hexo-cli 安装 hexo。（如果没有使用 cnpm 是把 cnpm 换为 npm）。 运行hexo -v检查版本和安装是否成功。 配置博客我们先简单阐述本博客中 hexo + Github 的工作原理，然后再详述具体步骤：hexo 是一个使用 Markdown 写作的静态博客框架。这句话的意思是，我们使用 Markdown 编写文章，编写完成后，hexo 将文章渲染为网页，具体来说就是 html、CSS、Javascript 三大件，hexo 在这一步用到了 Node.js。在这一步完成后，我们就可以在本地启动一个服务器，然后在本地浏览博客了。当然我们的目的是在公网访问，因此我们需要将生成后的文件托管到远端。我们采用 Github Pages，GitHub Pages 是 GitHub 推出的静态站点托管服务，其可以将你托管到 GitHub 特定仓库的网页文件渲染成网页。我们用 Git 将生成的内容推送到 GitHub 远端仓库，然后让 Github Pages 充当远端服务器，将文件渲染成网站。这样我们就可以随时随地访问到我们的网站了。 初始化一个博客在合适的地方新建文件夹，此文件夹是博客的本地仓库，后续所有的操作都会是在此文件夹进行。 可以考虑建立一个专门存放各类文章/代码的文件夹，将 hexo 文件夹放在此文件夹内。通过 Windows 文件管理器左侧的“快速访问栏”快速抵达。 在此文件夹内启动终端 Shell： 在文件夹内右键选择 Git Bash Here 在其他地方启动 cmd、power shell、git bash，然后跳转到此文件夹。 如果你是 Windows 11，右键选择在终端中打开（Windows 10 需要在应用商店下载）。 在 Shell 中输入hexo init将此文件夹初始化（initialize）为 hexo 博客（如果建在一些特殊的地方，可能需要命令前加上sudo使用管理员权限）。 本地访问hexo 初始化的博客是包含有默认文章的生成网页的，因此继续输入hexo s（s：server ）启动一个本地服务器，就可以通过端口 4000 localhost:4000 访问网页了。 Github Pages托管当然存在其他的托管服务，例如国内的 gitee pages 托管。不过国内公开仓库都要先审核的环境嘛……emmmm。下面阐述步骤： 首先需要一个 GitHub 账号。 新建仓库：GitHub 的政策是每个账户只能拥有一个 GitHub Pages 站点，且站点文件必须存储在格式为 YourGithubAccountName.github.io 的仓库（Repository）内。因此，点选网站上 Repository 边的 New 新建一个库。 安装 Git 部署插件：回到命令行，在博客目录下输入cnmp install hexo-deployer-git安装部署插件。这一步的目的是使得我们可以将把博客部署（推送）到远端的服务器上，就本例而言，即 Github 仓库上 Note1：大一的时候我只能混沌地意识到 Git 与 Github 的不同但是说不清楚。建议读者可以先单独地使用一下 Git 和 GitHub 以更好地理清二者关系。 Note2：参考视频给的命令是cnmp install --save hexo-deployer-git，多出来的--save含义是安装好此插件后将其自动作为依赖（dependencies）添加到我们的 hexo 博客目录下的packages.json文件中。但是在 2017 年 5 月的 npm 5.0 后，不用写此选项也会自动添加了。因此这一选项可以删去了。 修改配置文件：在博客目录下找到 _config.yml 用任意文本编辑器打开 。滑到最低端找到 deploy 。把 type 后面引号中写入 git 。然后换行写上：repo： YourGIthubRepoAddress，再换行写上branch: master 。 这一步的目的是指定 hexo 的部署方式是使用 git，部署地址是我们指定的 git 远端仓库的 master 分支（主分支）。 编写博文：以前面说的 hexo 目录为根目录（./目录）下的./source/_posts文件夹下新建 Markdown 文件，使用 Markdown 编写（测试）博文。 部署：用hexo g将写好的博客生成（generate）对应的网页文件（HTML、JS、CSS），配置 Git 身份，键入hexo d 来部署（deploy）到远端。下面详述配置 Git 用户身份： Git 是一个版本管理工具。因此每一次上传都要求可追溯。上传前需要配置用户名和邮箱。这样协作者（对于开源项目，可能是陌生人）就可以联系到你并直到如何称呼你。GitHub使用你 Git 上传的邮箱来确定用户，所以这里我们应该保证邮箱以及用户名与 GitHub 账户一致，避免造成混乱。如果只有一个GitHub 账户，可以将用户身份配置为全局的：git config --global user.email &quot;YourGithubAccountEmail&quot;和git config --global user.name &quot;YourGithubAccountName&quot;这样就不必每个项目推送到远端时都重新配置用户身份了。但是我有多个账户，因此我的习惯是删去上述命令中的--global选项，不配置全局身份，这样，每个项目的第一次提交前必须要配置一个身份。 显然，我们在 Git 中配置的身份只是“宣称”我们是谁————Git可没有账户密码系统。因此远端托管网站会要求输入你在其网站的账户密码以验证你是否有权限访问你想要读写的远端仓库。因此下一步是在弹出的窗口中输入 Github 账户密码。 核验 Github 账户：有多种验证 GitHub 身份的方式。 Token：一共需要输入两次密码。第一次的时候，你应该输入你的 GitHub 账号和密码，第二次的则须如下获取。首先GitHub网页点击头像 -&gt; Settings -&gt; Developer Settings -&gt;Personal access tokens -&gt;Generate new token。创建一个新的 token ，设定其权限和名字，随后 GitHub 会分配给它一个 password 。这里的名字和密码才是第二次所需输入的。需要注意的是，你只有一次看到密码的机会，所以一定要保存好。以防日后用到。 检验成功后，Github 就会将文章上传到远端仓库，并使用 Github Actions 将其交给 Github Pages 静态站点渲染为一个网页。以后，访问 YourGithubAccountName.github.io 即可看到和 hexo s 一样的网站页面了。 后言和一些感想总结一下，本文阐述了如何完全从零：甚至没有 Git 和 Node.js 的前提下如何安装 Git、Node.js 等软件，并利用 Hexo 框架搭建一个静态博客，最后将其部署到 Github Pages 远端的过程。 如果你照着我的、或者别人的教程搭好了这样一个小小的静态博客。首先，相信和我 一样是充满成就感的，Hello World 两个单词仿佛是一个广阔的新世界你面前缓缓展开。其次，你也一定会注意到它是简单的，流程并不复杂，而且我们不曾敲过一行代码，那些真正麻烦的工作，hexo 给我们静静地办好了。无论如何，博客是我们的，我们可以自由的享用它了。 2023：如今回过头来才发现那些当时觉得困难无比的操作如今都稀疏平常。那个时候一个 npm 的下载问题都能要了我老命，什么时候是在用 GitHub、什么时候是在用 Git都晕晕乎乎难以明了。一方面，这大概是出于这并不是一个困难的问题反而导致有很多小白会对其感兴趣（这些人日常并不用 Git 和/或 Node.js 日常干些什么），于是讲解就必须要琐碎、细致且不关心为什么这么做。另一方面，国内的生态环境也就是如此，如果搜索“npm 默认下载源地址”那么大概率搜出来的都是教你如何更换下载源，却少有文章告诉你是哪儿。而使用英语，我们很轻松就可以找到本文上述有关部分给出的那两个官方参考地址。其他各种问题往往也能有各类文档与论坛（如 StackOverflow）解释。这多少有些悲哀。 我现在的博客当然不是默认样式，我们会在之后的系列文章中进一步的优化写作环境点击链接跳转到下一篇文章了解如何优雅地写博文。 感谢与参考 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo bilibili, UP: codesheep hawa同学。身边有有个大佬真好用。 newBing：在我重写此博客时提供了一些参考信息。","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"},{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"},{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"},{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"},{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"},{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"},{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"},{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"索引，多媒体数据处理","slug":"索引，多媒体数据处理","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95%EF%BC%8C%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算（课程），实验报告","slug":"云计算（课程），实验报告","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97%EF%BC%88%E8%AF%BE%E7%A8%8B%EF%BC%89%EF%BC%8C%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"},{"name":"c++","slug":"c","permalink":"http://example.com/tags/c/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"},{"name":"拾遗","slug":"拾遗","permalink":"http://example.com/tags/%E6%8B%BE%E9%81%97/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"},{"name":"笔记，基本线性变换","slug":"笔记，基本线性变换","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0%EF%BC%8C%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"批处理脚本，hexo","slug":"批处理脚本，hexo","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC%EF%BC%8Chexo/"},{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘，非技术","slug":"语摘，非技术","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98%EF%BC%8C%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"},{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"},{"name":"静态博客教程","slug":"静态博客教程","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"}]}