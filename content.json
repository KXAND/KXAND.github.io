{"meta":{"title":"LeeKa 的酒馆","subtitle":"欢迎，旅人！坐下来享受一下暖烘烘的炉火吧。","description":"代码、音乐和游戏，一起来聊聊吧","author":"LeeKa","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2014-12-22T04:39:04.000Z","updated":"2024-04-20T18:58:06.427Z","comments":false,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-01-19T16:25:11.000Z","updated":"2024-04-20T19:08:41.570Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"欢迎来到 LeeKa Pub！ 这个不定期更新的页面提供网站和作者的一些信息。 关于作者 一个即将毕业的某大学数字媒体技术专业学生。 我对 Unity 游戏开发很感兴趣，也在朋友的帮衬下做过一些小玩意。也有些许 UE 的使用经验。此外，我也对区块链有一定的兴趣，但是并没有很深入的了解。 除开技术，我喜欢音乐，特别是电子音乐（EDM，techno等）。我也喜欢玩游戏，主要是各种 AAA 游戏，但是也有些独立游戏，不过很缺乏网络游戏的经历。此外，我对中世纪史、语言学等也有一定兴趣。 不过这些内容并不能都指望在这个博客看见，因为很多真的就仅仅是感兴趣。 关于这里 这是一个基于 hexo 搭建的个人博客，使用 NexT 主题。 虽然域名有个 Pub，就本质而言，不过是个静态博客。所以除了阅读和评论外不会有更多的功能。 文章会不定期更新，这是因为后续检查的时候往往会发现错别字、感觉拗口的语句，又或者稍微成长一些以后发现了不准确甚至错误的内容，文章大体内容不会进行修改（除了完全重写的博客搭建笔记）。 网站主要是作为一个个人写文章总结心得的地方所使用，因此文章大体也就是“学到什么写什么”、“做了什么写什么”亦或者“想到什么写什么”。我对主题的分划大概是一下三块：计算机技术、电子游戏、音乐。但是目前基本只能看见技术内容了。 关于计算机技术：学习笔记，实验报告，一些配置经历分享等。 关于电子游戏：设想主要分游戏鉴赏和游戏制作两块。游戏鉴赏是对玩过游戏的评价；游戏制作则是独立游戏制作过程中的一些经验总结。 关于音乐：歌曲分享，音乐方面的学习。 反馈 我会尽力逐步完善这个 Pub。 如果你在浏览过程中发现问题 / 可改善之处，欢迎通过邮件(leeka.pub@outlook.com)告诉我。"},{"title":"目录","date":"2020-10-22T06:35:37.000Z","updated":"2024-04-20T18:58:08.113Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签页","date":"2020-10-22T06:24:10.000Z","updated":"2024-04-20T18:58:08.115Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"LeekKA 的朋友们","date":"2021-06-15T16:34:27.000Z","updated":"2024-04-20T18:58:08.114Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":".links-content{ margin-top:1rem; } .link-navigation::after { content: \" \"; display: block; clear: both; } .card { width: 45%; font-size: 1rem; padding: 10px 20px; border-radius: 4px; transition-duration: 0.15s; margin-bottom: 1rem; display:flex; } .card:nth-child(odd) { float: left; } .card:nth-child(even) { float: right; } .card:hover { transform: scale(1.1); box-shadow: 0 2px 6px 0 rgba(0, 0, 0, 0.12), 0 0 6px 0 rgba(0, 0, 0, 0.04); } .card a { border:none; } .card .ava { width: 3rem!important; height: 3rem!important; margin:0!important; margin-right: 1em!important; border-radius:4px; } .card .card-header { font-style: italic; overflow: hidden; width: 100%; } .card .card-header a { font-style: normal; color: #2bbc8a; font-weight: bold; text-decoration: none; } .card .card-header a:hover { color: #d480aa; text-decoration: none; } .card .card-header .info { font-style:normal; color:#a3a3a3; font-size:14px; min-width: 0; overflow: hidden; white-space: nowrap; } Hanwan Space We are here to put a dent in the universe. AweiP Cache 且愿饮冰而热血不凉 实现源自： 最简单的Hexo友情链接页面定制 | Finisky Garden"}],"posts":[{"title":"毕业设计（3）：RSA 快速变体上的短私钥指数攻击","slug":"毕业设计/毕业设计3：RSA快速变体上的短私钥指数攻击","date":"2024-04-20T14:12:22.000Z","updated":"2024-04-20T19:48:32.788Z","comments":true,"path":"post/20240420221222.html","permalink":"http://example.com/post/20240420221222.html","excerpt":"前言 原名Short Private Exponent Attacks on Fast Variants of RSA。","text":"前言 原名Short Private Exponent Attacks on Fast Variants of RSA。 1. Abstract 2. Introduction RSA 公钥系统的一大不足就是加密、解密、生成签名亦或者验证签名都非常慢，这归咎于其中的数字尺度和指数操作。对一些设备，例如可生成 RSA 签名的智能卡，如果能快速完成涉及私钥的操作那是很有益的。为了加速处理，一些人可能会使用短的秘密指数。不幸的是，维纳在 1990 年证明，对于有两个（素）因子的模数 NNN，若 d&lt;N14d&lt;N^{\\frac{1}{4}}d&lt;N41​ ，可以使用一种续分数算法在多项式时间内找到秘密指数 ddd。此后，小秘密指数 RSA 攻击最重大的提升由 Boneh 和 Durfee 在 1999 年提出。若 d&lt;N0.292d&lt;N^{0.292}d&lt;N0.292 ，他们能在多项式时间内恢复 ddd 。 多素数 RSA (RSA Multiprime)中，模数 NNN 由至少三个素因子组成：N=p1p2…prN=p_1p_2\\ldots p_rN=p1​p2​…pr​ 其中 r≥3r \\geq 3r≥3 。加密操作和传统 RSA 一致，但是解密和生成签名操作通过利用中国剩余定理（CRT）以加速。此外，还可以用 rrr 个指数器（exponentiator）并行地进行计算。 在 Crypto 1998，高木（Takagi）提出了一种新的公钥加密系统。这是众所周知的 RSA 公钥加密系统的一种修改版本。当使用形为 prqp^rqprq 的特定模数时，他给出了一种有趣的方法以加速解密部分。提出一种快速算法以检索 mmod prm\\mod{p^r}mmodpr ——它的计算时间对计算 cdmod pc^d \\mod{p}cdmodp 很重要。其中 mmm 是明文，ccc 是密文。考虑 mmod prm\\mod{p^r}mmodpr 的 p−adicp-adicp−adic 展开式：mmod pr=m0+m1p+m\\mod{p^r}=m_0+m_1p+mmodpr=m0​+m1​p+ m2p2+…+mr−1pr−1m_2p^2+\\ldots+m_{r-1}p^{r-1}m2​p2+…+mr−1​pr−1 其中 m0,m1,m2,…,mr−1∈[0,p−1]m_0,m_1,m_2,\\ldots,m_{r-1}\\in[0,p-1]m0​,m1​,m2​,…,mr−1​∈[0,p−1]。然后使用 CRT 由 mmod prm\\mod{p^r}mmodpr 和 mmod qm\\mod{q}mmodq 恢复 mmod prqm\\mod{p^rq}mmodprq。在 [23]中，高木的公钥加密系统扩展到了形如 prqsp^rq^sprqs 的模量。 另一种加速密钥运算的的方法——它可以和前者结合使用——是使用短秘密指数。在这篇报告中我们分析了短秘密指数攻击对 RSA MultiPrime 和高木系列方案（Takagi family scheme）的影响。 这篇报告如下组织：章节 2 介绍了 RSA MultiPrime 和广义高木方案的一些情况；章节 3 将维纳攻击拓展到这些上述方案中；随后，章节 4 中讨论了 Boneh-Durfee 攻击的基本形式和（使用几何级数矩阵的）改进形式，并给出可应用该攻击的指数上限，随后还讨论了 Hinek 等人在[10] 中给出的修正建议。 3. 数学背景 在本节中，我们将简要回顾 RSA MultiPrime 和高木系列方案的一些情况。已经了解这些方案的读者可以放心地跳过这一部分。本报告的其余部分自成体系，不需要这一部分也能理解。 3.1. RSA MultiPrime 康柏公司于 1997 年 1 月为 RSA MultiPrime 申请了专利。该专利技术要点在于使用至少有三个非相等素数的 RSA 模 NNN ： \\begin{equation} N=p_1p_2\\cdots p_r\\qquad (r\\geq3) \\end{equation} 其加密操作和经典 RSA 一致，但解密以及签名生成则是通过中国剩余定理（CRT）进行以加速操作。此外，还可以用 rrr 个指数器（exponentiator）并行地计算。图表 1 描述了递归 CRT 算法在 N=p1p2⋯prN=p_1p_2\\cdots p_rN=p1​p2​⋯pr​ 的情况下，从密文 c=mec=m^ec=me 中恢复明文 mmm 的过程。 输入：c,d,pi(i=1,⋯ ,r)c,d,p_i(i=1,\\cdots,r)c,d,pi​(i=1,⋯,r) 输出：mmm q1=1q_1 =1q1​=1 对 i=2,⋯ ,ri =2,\\cdots,ri=2,⋯,r：qi=qi−1pi−1,ui=qi−1mod piq_i =q_{i-1}p_{i-1},u_i=q_i^{-1}\\mod{p_i}qi​=qi−1​pi−1​,ui​=qi−1​modpi​ 对 i=1,⋯ ,ri =1,\\cdots,ri=1,⋯,r：di=dmod (pi−1),ci=cmod pi,mi=cidimod pid_i =d \\mod{(p_i-1)},c_i=c\\mod{p_i},m_i=c_i^{d_i}\\mod{p_i}di​=dmod(pi​−1),ci​=cmodpi​,mi​=cidi​​modpi​ y1=m1y_1=m_1y1​=m1​ 对 i=2,⋯ ,ri =2,\\cdots,ri=2,⋯,r：yi=yi−1+qi×((mi−yi−1)×uimod pi)y_i =y_{i-1}+q_{i}\\times((m_i-y_{i-1})\\times u_i\\mod{p_i})yi​=yi−1​+qi​×((mi​−yi−1​)×ui​modpi​) m=yrm=y_rm=yr​ 【图表 1】CRT 破译算法 我们记得，计算 xdmod Nx^d\\mod{N}xdmodN 的二进制运算次数大约是 32∣d∣×∣N∣2\\frac{3}{2}|d|\\times|N|^223​∣d∣×∣N∣2 ，其中 ∣.∣|.|∣.∣ 表示数字的（二进制）位数。表 1 展示了使用经典 RSA 和 RSA MultiPrime 时解密[1] 需要的二进制运算的数量 是 并行计算 计算次数 RSA 否 32∣N∣∣N∣2=32∣N∣3\\frac{3}{2}\\mid N\\mid \\mid N \\mid^2=\\frac{3}{2}\\mid N\\mid ^323​∣N∣∣N∣2=23​∣N∣3 RSA+CRT 否 2.32(∣N∣2)(∣N∣2)2=38∣N∣3\\frac{2.3}{2}\\left(\\frac{\\mid N\\mid}{2}\\right)\\left(\\frac{\\mid N\\mid}{2}\\right)^2=\\frac{3}{8}|N|^322.3​(2∣N∣​)(2∣N∣​)2=83​∣N∣3 RSA+CRT 是 32(∣N∣2)(∣N∣2)2=316∣N∣3\\frac{3}{2}\\left(\\frac{\\mid N\\mid}{2}\\right)\\left(\\frac{\\mid N\\mid}{2}\\right)^2=\\frac{3}{16}|N|^323​(2∣N∣​)(2∣N∣​)2=163​∣N∣3 r 个因数的MultiPrime 否 r.32(∣N∣r)(∣N∣r)2=32r2∣N∣3\\frac{r.3}{2}\\left(\\frac{\\mid N\\mid}{r}\\right)\\left(\\frac{\\mid N\\mid}{r}\\right)^2=\\frac{3}{2r^2}|N|^32r.3​(r∣N∣​)(r∣N∣​)2=2r23​∣N∣3 r 个因数的 MultiPrime 是 32(∣N∣r)(∣N∣r)2=32r3∣N∣3\\frac{3}{2}\\left(\\frac{\\mid N\\mid}{r}\\right)\\left(\\frac{\\mid N\\mid}{r}\\right)^2=\\frac{3}{2r^3}|N|^323​(r∣N∣​)(r∣N∣​)2=2r33​∣N∣3 【表 1】RSA 破译中的二进制运算次数 从安全角度看，模数素因子允许的最大值由一个曲线交点决定：对根据素因子的数量确定的质因子，数域筛法（NFS）和椭圆曲线方法（ECM）所需时间的曲线交点。这里第一种算法的复杂度随待分解的数大小增加而增长，第二种算法的复杂度则随着数中素因子的大小增加而增长。两种算法都是次指数复杂度：NFS 是 LN[13,c]L_N[\\frac{1}{3},c]LN​[31​,c]，其中 ccc 是一个小常量；ECM 是 Lp[12,2]L_p[\\frac{1}{2},\\sqrt{2}]Lp​[21​,2​]，其中 ppp 是 NNN 的一个因子。由此可以得出表 2。回顾 \\begin{equation} L_N[\\alpha,c]=\\oldstyle{O}(e^{(c+o(1))(\\ln{N})^\\alpha(\\ln\\ln{N})^{1-\\alpha}}) \\end{equation} 其中，ccc 是一个很小的正常量且 α\\alphaα 是一个在 0&lt;α&lt;10&lt;\\alpha&lt;10&lt;α&lt;1 间的实数。 模数二进制位长 素数个数 512 2 1024 3 1536 3 2048 3 2560 3 3072 3 3584 3 4096 4 8192 5 【表 2】指定模数大小下最优质因数个数（cf. 26） 例如，在 RSA MultiPrime 中使用有三个素因子的模数，其生成签名的速度比非并行计算的经典 RSA 快 94\\frac{9}{4}49​ 倍，比并行计算的 RSA 快 278\\frac{27}{8}827​。下面我们会看到，减小 ddd 的大小还会进一步加速生成速度。 3.2. Takagi family schemes 在这一节，我们简短地介绍高木系列方案并给出这些方案的核心，解密部分，的一些情况。 pkqp^kqpkq 加密系统由高木在 [21] 中首次提出，Lim、Kim、Yie 和 Lee 在 [23] 中将其模数推广到 prqsp^rq^sprqs 形式。模数需要适当地选择，以抵抗如数域筛法（NFS）和椭圆曲线方法（ECM）这样的因式分解算法。 选择私密参数 ddd 和公共参数 eee ，通过检验下式： \\begin{equation*} ed\\equiv 1 \\mod{\\mathrm{lcm}(p-1,q-1)} \\end{equation*} 使得秘密指数 ddd 远小于模数 nnn。加密方法和经典 RSA 相同，即对于信息 mmm，计算 memod nm^e\\mod{n}memodn。解密部分分成两步：首先恢复出 mmod prm \\mod{p^r}mmodpr 和 mmod qsm \\mod{q^s}mmodqs (细节见下)，然后利用 Quisquater 和 Couvreur 在[15] 中提出的中国剩余定理方法得到 mmod nm \\mod{n}mmodn 。为了得到 mmod prm \\mod{p^r}mmodpr 的具体数值，使用了 [20] 中介绍的基于 p 进数展开式（p-adic expansion）的算法。恢复 mmod psm \\mod{p^s}mmodps 也是同样的方法。 令 cpc_pcp​ 为密文 mem^eme 模 prp^rpr 的余数，mpm^pmp 明文模 prp^rpr 的余数。二者关系如下： \\begin{equation*} c_p=m_p^e\\mod{p^r} \\end{equation*} 给定密文 ccc，mpm_pmp​ 的值可以通过 mpm^pmp 自身的 p-adic 展开式恢复： \\begin{equation} m_p \\equiv \\sum^{r-1}_{h=0}p^hK_h\\mod{p^r} \\end{equation} 对 i∈{0,⋯ ,r−1}i \\in \\{0,\\cdots,r-1\\}i∈{0,⋯,r−1} ，令 Fi(X0,⋯ ,Xi)=(∑h=0iphXh)eF_i(X_0,\\cdots ,X_i)=\\left(\\sum^{i}_{h=0}p^hX_h\\right)^eFi​(X0​,⋯,Xi​)=(∑h=0i​phXh​)e 且 Gi(X0,…,Xi)=e(∑h=0iphXh)e−1G_i(X_0,\\ldots,X_i)=e\\left(\\sum^{i}_{h=0}p^hX_h\\right)^{e-1}Gi​(X0​,…,Xi​)=e(∑h=0i​phXh​)e−1 ，我们有 \\begin{equation} F_i \\equiv f_{i-1}+p^iG_{i-1}X_i\\mod{p^{i+1}} \\end{equation} (3) 中的 KhK_hKh​ 值可以由下式中 XhX_hXh​ 的解递归得出 \\begin{equation} c_p \\equiv F_{h-1}+p^hG_{h-1}X_h \\mod{p^{h+1}} \\end{equation} 这也适用于解出 mmod qsm \\mod{q^s}mmodqs 。最后，通过对 mmod prm\\mod{p^r}mmodpr 和 mmod qsm\\mod{q^s}mmodqs 应用中国剩余定理得出 mmm。 关于解密步骤运行时间的更多细节，我们推荐读者阅读[22]。 4. 维纳攻击 针对短秘密指数 RSA 攻击的第一个重要成果是维纳在 1990 年做出的。通过续分数算法，可以从完全由公共指数决定的分式找到一个含有秘密指数的分式。该攻击，以及更一般地所有短秘密指数攻击，的前提是下列等式： \\begin{equation} ed \\equiv 1 \\mod{\\varphi(N)} \\end{equation} 其中 φ(.)\\varphi(.)φ(.) 是欧拉函数（欧拉总计函数，Euler totient function），eee 是私钥指数，ddd 是公钥指数。维纳利用了这个信息：完全由公开参数构成的分式 epq\\frac{e}{pq}pqe​ ，是一个分母为 ddd 的倍数的分式的近似值。 定理 1（cf. [9]中定理 184） 设 gcd⁡ab=gcd⁡cd=1\\gcd{a}{b}=\\gcd{c}{d}=1gcdab=gcdcd=1 且 ∣ab−cd∣≤12d2\\left|\\frac{a}{b}-\\frac{c}{d}\\right|\\leq \\frac{1}{2d^2} ∣∣∣∣​ba​−dc​∣∣∣∣​≤2d21​ 那么 cd\\frac{c}{d}dc​ 是 ab\\frac{a}{b}ba​ 的续分数展开式的一个收敛项。 4.1. Multiprime 情况 现在我们考虑 RSA MultiPrime 的情况，其中模数 NNN 有 rrr 个不同的素因子 N=p1…prN=p_1\\ldots p_rN=p1​…pr​ 。并假设对任意（所有） i≠ji \\neq ji=j ，有 gcd⁡(pi−1,pj−1)=2\\gcd(p_i-1,p_j-1)=2gcd(pi​−1,pj​−1)=2 ，以对抗因数分解方法。由此，lcm(p1−1,…,pr−1)=(p1−1)…(pr−1)/2r−1\\mathrm{lcm}(p_1-1,\\ldots,p_r-1)=(p_1-1)\\ldots(p_r-1)/2^{r-1}lcm(p1​−1,…,pr​−1)=(p1​−1)…(pr​−1)/2r−1 。我们可以不加限制地假设 P1&lt;p2&lt;…&lt;pr&lt;2p1P_1 &lt; p_2 &lt; \\ldots &lt; p_r &lt; 2p_1P1​&lt;p2​&lt;…&lt;pr​&lt;2p1​，因此有 \\begin{equation} p^r_1&lt;N&lt;2^{r-1p^r_1} \\end{equation} 从等式 ed≡1mod lcm(p1−1,…,pr−1)ed \\equiv 1 \\mod{\\mathrm{lcm}(p_1-1,\\ldots,p_r-1)}ed≡1modlcm(p1​−1,…,pr​−1) 可以推出，存在 k∈Zk \\in \\mathbb{Z}k∈Z 为奇数使得 \\begin{equation} ed=1+\\frac{k}{g}(p_1-1)\\ldots(p_r-1) \\end{equation} 其中 g=2r′g=2^{r&#x27;}g=2r′，r′≤r−1r&#x27;\\leq r-1r′≤r−1 。等式（8）也可以改写为 \\begin{equation} ed=1+\\frac{k}{g}\\varphi(N) \\end{equation} 随后，要应用定理 1，需要满足下列条件： ∣eN−kdg∣&lt;12(dg)2\\left| \\frac{e}{N}-\\frac{k}{dg} \\right| &lt;\\frac{1}{2(dg)^2} ∣∣∣∣∣​Ne​−dgk​∣∣∣∣∣​&lt;2(dg)21​ 化简可得，攻击可行的前提条件是 2(r−1)/rrgN1/r&lt;12(dg)2i.e.d&lt;N1/2r2(2r−1)/2rrg≈N1/2r\\frac{2^{(r-1)/r}r}{gN^{1/r}}&lt;\\frac{1}{2(dg)^2} \\quad\\mathrm{i.e.}\\quad d&lt;\\frac{N^{1/2r}}{2^{(2r-1)/2r}\\sqrt{rg}}\\approx N^{1/2r} gN1/r2(r−1)/rr​&lt;2(dg)21​i.e.d&lt;2(2r−1)/2rrg​N1/2r​≈N1/2r 因此，若 ddd 大约小于 N1/2rN^1/2rN1/2r ，维纳攻击对有 rrr 个因子的 RSA MultiPrime 就可以进行。我们还需要在所有可能的情况中确定正确的收敛方案。下面是一个用于找出 kdg\\frac{k}{dg}dgk​ 的测试。首先，当 e d&gt;Nd &gt; Nd&gt;N 时，不等式 k&gt;gk &gt; gk&gt;g 成立。因此，对于每个计算出的收敛序列，做带余除法 edgedgedg 除以 kkk ，可以得到对 φ(N)\\varphi(N)φ(N) 和 ggg 的猜测值。若猜测值正确，计算 dgg\\frac{dg}{g}gdg​ 的结果就是秘密指数 ddd。事先根据随意明文 m∈Z/NZm \\in \\mathbb{Z}/N \\mathbb{Z}m∈Z/NZ 计算出密文 c=memod Nc=m^e \\mod{N}c=memodN，通过解密检验计算结果。若信息 mmm 没有被恢复，我们对下一个收敛项进行该测试，直到找出 ddd 为止。这样就可以利用下面的结果恢复模数的因式分解： 定理 2. 设 N=P1…psN=P_1\\ldots p_sN=P1​…ps​ 为整数。根据对 φ(N)\\varphi(N)φ(N) 倍数的了解，我们可以用概率多项式算法对 NNN 进行因式分解。 证明：设 N=P1…psN=P_1\\ldots p_sN=P1​…ps​ ，其中对每个 i=1…si=1\\ldots si=1…s 有 pi−1=2kiqip_i-1=2^{k_i}q_ipi​−1=2ki​qi​ 。此外，pip_ipi​ 还按使 k1≤…≤ksk_1 \\leq \\ldots \\leq k_sk1​≤…≤ks​ 的顺序进行排列。将 αφ(N)=2krα\\varphi(N) = 2 krαφ(N)=2kr 写为 φ(N)\\varphi(N)φ(N) 的倍数，其中 rrr 为奇数。设 m∈Z/NZm \\in \\mathbb{Z}/N \\mathbb{Z}m∈Z/NZ，使得 gcd(m,N)=1gcd(m,N)= 1gcd(m,N)=1。下面三个情况可能会发生： mr≡1mod Nm^r \\equiv 1 \\mod{N}mr≡1modN， ∃i∈N,0&lt;i≤k\\exists i \\in \\mathbb{N},0 &lt; i \\leq k∃i∈N,0&lt;i≤k 使得 m2ir≡−1mod Nm^{2ir}\\equiv -1 \\mod{N}m2ir≡−1modN， ∃i∈N,0≤i&lt;k\\exists i \\in \\mathbb{N},0 \\leq i &lt;k∃i∈N,0≤i&lt;k 使得 m2ir≢−1mod Nm^{2ir}\\not\\equiv -1 \\mod{N}m2ir≡−1modN，且 m2i+1≡1mod Nm^{2^i+1}\\equiv 1 \\mod{N}m2i+1≡1modN。 最后一种情况中，m2irm^{2^ir}m2ir 在模 NNN 意义下是 111 的平方根，且不等于 ±1\\pm1±1 。即 m2ir−1m^{2^ir}-1m2ir−1 和 m2ir+1m^{2^ir}+1m2ir+1 是零的非平凡除数[^2]。计算它们与 NNN 的最大公约数，得到 NNN 的一个非平凡除数 hhh 。由于 φ(N)\\varphi(N)φ(N) 仍然是 φ(N/h)\\varphi(N/h)φ(N/h) 或 φ(h)\\varphi(h)φ(h) 的倍数，我们可以对 N/hN/hN/h 或者 hhh 再进行一次这样的运算。因为 φ(N)=φ(N/h)φ(h)\\varphi(N)=\\varphi(N/h)\\varphi(h)φ(N)=φ(N/h)φ(h)。剩下的工作就是评估找到可以进行因式分解的 m 的概率。剩下的工作就是评估找到可以进行因式分解的 mmm 的概率。首先，定义 \\begin{align*} B(n):=\\{m \\in (\\mathbb{Z}/n \\mathbb{Z})^*:m^r \\equiv 1 \\mod{n}\\\\ 或 \\exists i \\in \\mathbb{N},0 \\leq i &lt; k:m^{2^ir} \\equiv -1 \\mod{n}&amp; \\}, \\end{align*} P(n):={m∈(Z/nZ)∗:mr≡1mod n},P(n):=\\{m\\in (\\mathbb{Z}/n \\mathbb{Z})^*:m^r \\equiv 1 \\mod{n}\\}, P(n):={m∈(Z/nZ)∗:mr≡1modn}, 以及，对 0≤j≤k−10 \\leq j \\leq k-10≤j≤k−1， Bj(n):={m∈(Z/nZ)∗:m2jr≡−1mod n},B_j(n):=\\{m\\in (\\mathbb{Z}/n \\mathbb{Z})^*:m^{2^jr} \\equiv -1 \\mod{n}\\}, Bj​(n):={m∈(Z/nZ)∗:m2jr≡−1modn}, 以使 B(n)=p(n)∪⋃0≤j≤k−1Bj(n)B(n)=p(n)\\cup \\bigcup_{0 \\leq j \\leq k-1}B_j(n) B(n)=p(n)∪0≤j≤k−1⋃​Bj​(n) 使用中国剩余定理，我们可以评估 ♯P(n)=∏i=1s♯P(pi)\\sharp P(n)=\\prod^{s}_{i=1}\\sharp P(p_i)♯P(n)=∏i=1s​♯P(pi​)，而由于 ♯P(pi)=gcd⁡(r,pi−1)\\sharp P(p_i)=\\gcd (r,p_i-1)♯P(pi​)=gcd(r,pi​−1) ,我们有 ♯P(n)=∏i=1sgcd⁡(r,pi−1)\\sharp P(n)=\\prod^{s}_{i=1}\\gcd(r,p_i-1) ♯P(n)=i=1∏s​gcd(r,pi​−1) 现在让我们考虑 Qj(n)Q_j(n)Qj​(n) 。如前所述 ♯Qj(n)=∏i=1s♯Qj(pi)\\sharp Q_j(n)=\\prod^{s}_{i=1}\\sharp Q_j(p_i)♯Qj​(n)=∏i=1s​♯Qj​(pi​) 。注意到 \\begin{align*}Q_j(p_i)\\neq \\emptyset &amp;\\Leftrightarrow-1^{\\frac{p_i-1}{\\gcd(2^jr,p_i-1)}}=1\\\\&amp;\\Leftrightarrow \\frac{2^kiq_i}{2^{\\inf(j,k_i)}\\gcd(r,q_i)}\\text{为偶数}\\\\&amp;\\Leftrightarrow j&lt;k \\end{align*} 因此 ♯Qj(n)=gcd⁡(2ir,pi−1)=2jgcd⁡(r,qi)\\sharp Q_j (n)=\\gcd (2^ir,p_i-1)=2^j \\gcd(r,q_i)♯Qj​(n)=gcd(2ir,pi​−1)=2jgcd(r,qi​) 。最后，由于我们有有序的 pip_ipi​，我们得到 ♯Qj(n)={0ifj≥k12js∏i=1sgcd⁡(r,qi)ifj&lt;k1\\sharp Q_j(n)=\\begin{cases}0 &amp; \\text{if}j \\geq k_1 \\\\ 2^{js}\\prod^{s}_{i=1}\\gcd(r,q_i)&amp;\\text{if}j&lt;k_1\\end{cases} ♯Qj​(n)={02js∏i=1s​gcd(r,qi​)​ifj≥k1​ifj&lt;k1​​ 于是，♯B(n)=♯P(n)+∑j=0k−1=(1+∑j=0k−1)∏i=1sgcd⁡(r,qi)\\sharp B(n)= \\sharp P(n)+\\sum^{k-1}_{j=0}=\\left(1+\\sum^{k-1}_{j=0}\\right)\\prod^{s}_{i=1}\\gcd(r,q_i)♯B(n)=♯P(n)+∑j=0k−1​=(1+∑j=0k−1​)∏i=1s​gcd(r,qi​)。 同时注意到 k1k1≤kk_1k_1\\leq kk1​k1​≤k，经过常规的演算，我们得到 ♯B(n)φ(n)≤12s−1)\\frac{\\sharp B(n)}{\\varphi(n)}\\leq \\frac{1}{2^{s-1)}} φ(n)♯B(n)​≤2s−1)1​ 这意味着找到允许因式分解的 mmm 的概率大于 1−1/2s−11-1/2^{s-1}1−1/2s−1 。 4.2. 高木系列方案 在高木系列方案中，公共模数有特殊的形式 N=prqsN = p^rq^sN=prqs，其中 ppp 和 qqq 是两个大素数，而两个指数的生成公式如下： \\begin{equation} ed \\equiv 1 \\mod{\\mathrm{lcm}(p-1,q-1)} \\end{equation} 这种生成方式似乎阻止了维纳攻击的直接应用。然而，另一种可能是攻击者找到 d′d&#x27;d′，使得 ed′≡1mod φ(N)ed&#x27; \\equiv 1 \\mod{ \\varphi(N)}ed′≡1modφ(N) ，其中 φ(N)=pr−1qs−1(p−1)(q−1)\\varphi(N) = pr-1 qs-1 (p - 1)(q - 1)φ(N)=pr−1qs−1(p−1)(q−1)。这样，攻击就能奏效，攻击者得以恢复明文。是的，有一个整数 kkk，使得 ed′=1+kj(N)ed&#x27; = 1 + kj (N)ed′=1+kj(N)，然后得到 \\begin{equation} \\left|\\frac{e}{N}-\\frac{k}{d&#039;}\\right|= \\left|\\frac{1}{Nd&#039;}+\\frac{k}{d&#039;}\\left(\\frac{\\varphi(N)}{N}-1\\right)\\right| &lt;\\frac{1}{2d&#039;^2}\\end{equation} 我们有 ∣φ(N)N−1∣=1p+1q−1pq\\left|\\frac{\\varphi(N)}{N}-1\\right|= \\frac{1}{p}+\\frac{1}{q}-\\frac{1}{pq} ∣∣∣∣∣​Nφ(N)​−1∣∣∣∣∣​=p1​+q1​−pq1​ 此外，我们假设 p&lt;q&lt;2pp&lt;q&lt;2pp&lt;q&lt;2p，即模数的素因子位长一致。于是 ∣φ(N)N−1∣≤2p且N&lt;2spr+s\\left|\\frac{\\varphi(N)}{N}-1\\right| \\leq \\frac{2}{p} \\text{且} N&lt;2^{s}p^{r+s} ∣∣∣∣∣​Nφ(N)​−1∣∣∣∣∣​≤p2​且N&lt;2spr+s 进而 p&gt;n1/(r+s)2s/(r+s)p&gt;\\frac{n^{1/(r+s)}}{2^{s/(r+s)}} p&gt;2s/(r+s)n1/(r+s)​ 为发起攻击，我们需要 ∣φ(N)N−1∣&lt;1(d′)2\\left|\\frac{\\varphi(N)}{N}-1\\right| &lt; \\frac{1}{(d&#x27;)^2} ∣∣∣∣∣​Nφ(N)​−1∣∣∣∣∣​&lt;(d′)21​ 经化简，我们知道攻击可行的条件是 \\begin{equation} d&#039;&lt;N^{\\frac{1}{2(r+s)}} \\end{equation} 然而，由于 e&lt;lcm(p−1)(q−1)e &lt; lcm (p - 1)(q - 1)e&lt;lcm(p−1)(q−1)，因此容易看出方程（10）和（12）给出的两个条件是互斥的。因此维纳攻击不适用。 5. 格攻击 5.1. 格方法改进 在[2]中，Boneh 和 Durfee 通过使用格归约方法（Lattice reduction approach）提高了维纳攻击的边界。 5.1.1. MultiPrime 的情况 我们聚焦于一个有 rrr 个因子的 MultiPrime，检验施加 Boneh-Durfee 格攻击对其造成的影响。等式 ed+kφ(N)=1ed+k \\varphi(N)=1ed+kφ(N)=1 在 φ(N)=(p1−1)…(pr−1)\\varphi(N)=(p_1-1)\\ldots(p_r-1)φ(N)=(p1​−1)…(pr​−1) 时成立。我们定义： A:=N+(−1)r,s:=φ(N)−N−(−1)rA:= N + (-1)^r ,\\qquad s := \\varphi(N) -N - (-1)^r A:=N+(−1)r,s:=φ(N)−N−(−1)r 随后有 \\begin{equation} k(A+s)\\equiv 1 \\mod{e} \\end{equation} 我们可以不受限制地假设：eee 与 NNN 同阶，d&lt;Nδd &lt; N^\\deltad&lt;Nδ，且 p1&lt;…&lt;pr&lt;2p1p_1 &lt; \\ldots &lt; p_r &lt; 2p_1p1​&lt;…&lt;pr​&lt;2p1​。那么 \\begin{equation} |k|=\\frac{ed-1}{\\varphi(N)}\\leq \\frac{ed}{\\varphi(N)}\\leq\\frac{ed}{N}&lt;e^\\delta \\end{equation} 且 \\begin{equation} |s|&lt;\\sum^{r}_{i=1}\\frac{N}{p_i}&lt;r \\frac{N}{p_1}&lt;r2^{\\frac{1}{r}-1}N^{1-\\frac{1}{r}} \\end{equation} 设 f(x,y)=x(A+y)−1f (x, y) = x (A+y)-1f(x,y)=x(A+y)−1 为整数系数的二元多项式。 接下来的问题是找到 (x0,y0)∈Z2(x_0, y_0) \\in \\mathbb{Z}^2(x0​,y0​)∈Z2 ，使得： \\begin{equation} f(x_0,y_0)\\equiv 0 \\mod{e} \\qquad\\text{其中} |x_0|&lt;e^\\delta=:X \\text{且} |y_0|&lt;e^{1-\\frac{1}{r}}=:Y \\end{equation} 我们定义多项式 P(x,y)=∑i,jai,jxiyj∈Z[x,y]P(x,y)=\\sum_{i,j}a_{i, j}x^iy^j \\in \\mathbb{Z}[x,y]P(x,y)=∑i,j​ai,j​xiyj∈Z[x,y] 的规范为 \\begin{equation} \\|P(x,y)\\|^2=\\sum_{i,j}a^2_{i,j} \\end{equation} Boneh-Durfee 攻击基于下列定理： 定理 3 cf. [11]. 令 P(x,y)P(x, y)P(x,y) 是一个最多包含 www 个单项式的多项式。假设对于某个正整数 mmm，P(x0,y0)≡0mod emP(x0, y0) \\equiv 0 \\mod{e^m}P(x0,y0)≡0modem，其中 ∣x0∣&lt;X|x0| &lt; X∣x0∣&lt;X 且 ∣y0∣&lt;Y|y0| &lt; Y∣y0∣&lt;Y。若 ∥P(xX,yY)∥&lt;em/w\\|P(xX, yY)\\| &lt; e^m/\\sqrt{w}∥P(xX,yY)∥&lt;em/w​，则在整数范围内， P(x0,y0)=0P(x0, y0) = 0P(x0,y0)=0 成立。 攻击的起点是多项式 f(x,y):=x(A+y)−1f(x, y) := x(A+y)-1f(x,y):=x(A+y)−1，(k,s)(k, s)(k,s) 是其模 eee 的解。主要思路是使用 LLL 算法找到两个低范数多项式以应用定理 3，这两个多项式在模 eme^mem 意义下解为 (k,s)(k, s)(k,s) 。随后，利用解在于整数集 Z\\mathbb{Z}Z 中的特性，在计算两个多项式的结果时还原出这些解。 就低范数多项式而言，Boneh 和 Durfee 构造了这两个多项式族： gi,k(x,y):=xifk(x,y)em−k和hj,k(x,y):=yjfk(x,y)em−k.g_{i, k}(x, y) := x^i f^k(x, y)e^{m-k} \\qquad \\text{和}\\qquad h_{j, k}(x, y) := y^j f^k(x, y)e^{m-k} . gi,k​(x,y):=xifk(x,y)em−k和hj,k​(x,y):=yjfk(x,y)em−k. 我们注意到，对 k=0,…,mk = 0, \\ldots, mk=0,…,m，(k,s)(k, s)(k,s) 是所有多项式模 eme^mem 意义下的解。我们的目标是找到多项式 gi,k(xX,yY)g_{i, k} (xX, yY)gi,k​(xX,yY)（称为 xxx -shifts）和 hj,k(xX,yY)h_{j, k} (xX, yY)hj,k​(xX,yY)（称为 yyy -shifts）的低范数整数线性组合。因此，用这些多项式的系数构建一个格。对于 k=0,…,mk = 0, \\ldots , mk=0,…,m，Boneh 和 Durfee 使用 gi,k(xX,yY)g_{i, k} (xX, yY)gi,k​(xX,yY) ，以及 hj,k(xX,yY)hj, k (xX, yY)hj,k(xX,yY) 来构建一个类似图像 2 中矩阵的矩阵，其中 i=0,…,m−ki = 0, \\ldots , m-ki=0,…,m−k，j=0,…,tj = 0, \\ldots , tj=0,…,t。整数 mmm 和 ttt 是在构建过程中优化的参数。 ![[Pasted image 20240127191336.png]] 【图像 2】该矩阵通过 gi,kg_{i,k}gi,k​ 和 hj,kh_{j,k}hj,k​ 张开，其中 k=0,…,3k=0,\\ldots,3k=0,…,3，i=0,…,3−ki=0,\\ldots,3-ki=0,…,3−k，j=0,1j=0,1j=0,1。“-”符号 '–' 表示非零项，其值没有考虑（参见 [2]）。 现在，我们可以使用非常强大的 LLL 格归约算法来获取该格的低范数元素。元素的大小受到下述著名结论的限制 [12]。 引理 4. 设 LLL 为一个格，而 (b1,…,bd)(b 1,\\ldots , bd)(b1,…,bd) 是 LLL 的一个 LLL-归约基。那么 \\begin{equation} \\|b_1\\|\\leq 2^{d/2}\\det(L)^{1/d} \\end{equation} 引理 5. 设 LLL 是由 (u1,…,ud)(u_1, \\ldots, u_d)(u1​,…,ud​) 生成的格子，而 (b1,…,bd)(b_1,\\ldots , b_d)(b1​,…,bd​) 是对给定的基应用 LLL 得到的结果。假设 mini∥ui∗∥≥1min_i \\|u^∗_i \\| \\geq 1mini​∥ui∗​∥≥1。那么 \\begin{equation} \\|b_2\\|\\leq 2^{d/2}\\det(L)^{1/(d-1)} \\end{equation} 通过上述两个引理以及 Boneh-Durfee 的定理，我们可以找到关于 δ\\deltaδ 的条件，使得前两个基向量的范数足够小，以使 (x0,y0)(x_0, y_0)(x0​,y0​) 成为整数解。然后，我们可以通过计算结果多项式 h(y)=Resx(g1,g2)h(y)=Res_x(g_1, g_2)h(y)=Resx​(g1​,g2​) 恢复 sss，并在整数域中找到其根。接着我们就能计算 φ(N)\\varphi(N)φ(N) 了。 备注：Boneh 和 Durfee [2] 指出，这种攻击属于启发式攻击，因为没有保证 g1(x,y)g 1 (x, y)g1(x,y) 和 g2(x,y)g 2 (x, y)g2(x,y) 在代数上是独立的。如果不是这种情况，那么结果多项式为零，无法恢复因子分解。不过，他们也指出这种攻击在实践中表现良好。 由于是三角矩阵，易于计算矩阵的行列式： \\begin{equation} \\det(L)=\\det_x \\det_y \\end{equation} 其中 \\begin{equation} \\begin{cases} \\det_x=e^{\\frac{m(m+1)(m+2)}{3}}X^{\\frac{m(m+1)(m+2)}{3}}Y^{\\frac{m(m+1)(m+2)}{6}}\\\\ \\det_y=e^{\\frac{tm(m+1)}{2}}X^{\\frac{tm(m+1)}{2}}Y^{\\frac{t(m+1)(m+t+1)}{2}} \\end{cases} \\end{equation} 行列式 det⁡x\\det_xdetx​ 是仅由 xxx -shifts 张成的子矩阵的行列式，而 det⁡y\\det_ydety​ 是矩阵仅涉及 yyy -shifts 部分的对角项乘积。 备注：如果考虑与 x-shifts 的矩阵对应的格，理论上我们能够恢复到 Wiener 的界限，但是 Blömer 和 May 在[1]中指出，在这种情况下 LLL 总是给出两个代数相关的向量，这说明攻击没有生效。 矩阵的维度变为 w=(m+1)(m+2)2+t(m+1)w = \\frac{(m+1)(m+2)}{2} + t(m+1)w=2(m+1)(m+2)​+t(m+1)，且将整个格中的 XXX 和 YYY 替换为对应的值，我们得到： \\begin{equation} det(L) = e^{(\\frac{\\delta}{3}+\\frac{1}{2}-\\frac{1}{6r})m^3+(1+\\frac{\\delta}{2}-\\frac{1}{2r})tm^2+(\\frac{1}{2}-\\frac{1}{2r}) mt^2+O(m^3)} \\end{equation} 以应用定理 3 到 LLL 生成的前两个向量。我们需要找到 δ\\deltaδ 的最大值使得 \\begin{equation} det(L) &lt; \\frac{e^{e(w-1)}}{\\gamma} \\qquad\\text{其中}\\qquad \\gamma = (w2^w)^\\frac{w-1}{2} \\end{equation} 通过忽略低阶项，并记 w = m^2/2 + tm + \\oldstyle{O}(m^2) ，我们有： \\begin{equation} \\left( \\frac{\\delta}{3}-\\frac{1}{6r} \\right)m^3 + \\left( \\frac{\\delta}{2}-\\frac{1}{2r} \\right)tm^2 + \\left( \\frac{1}{2}-\\frac{1}{2r} \\right)t^2m &lt;0 \\end{equation} 对每个 mmm ，最小值在 t=1−rδ2(r−1)mt=\\frac{1-r \\delta}{2(r-1)}mt=2(r−1)1−rδ​m 时取到。于是我们得到： \\begin{equation} m^3 \\left( \\frac{\\delta}{3}-\\frac{1}{6r}-\\frac{\\delta r -1}{2(r-1)}\\left(\\frac{\\delta}{2}-\\frac{1}{2r}\\right)+ \\frac{(\\delta r-1)^2}{4(r-1)^2}\\left(\\frac{1}{2}-\\frac{1}{2r}\\right) \\right)&lt;0 \\end{equation} 然后我们研究 \\begin{equation} \\frac{-r}{8(r-1)}\\delta^2+ \\left(\\frac{1}{3}+\\frac{1}{4(r-1)}\\right)\\delta- \\frac{1-4r}{24r(r-1)}&lt;0 \\end{equation} 最后得到 \\begin{equation} \\delta&lt;\\frac{4}{3}-\\frac{1}{3r}-\\frac{2}{3r}\\sqrt{4r^2-5r+1} \\end{equation} 因此，我们可以得到一个多项式 g1(x,y)∈Z[X,Y]g_1(x, y) \\in \\mathbb{Z}[X, Y]g1​(x,y)∈Z[X,Y]，它在整数域上有解 (x0,y0)(x_0, y_0)(x0​,y0​) 。我们需要另一个在引理 5 成立时可得的多项式 g2(x,y)g_2(x, y)g2​(x,y)。我们得到另一个多项式，其有解为 (x0,y0)(x_0, y_0)(x0​,y0​)。在解多项式 h(y)=Resx(g1,g2)∈Z[y]h(y)=Res_x(g_1, g_2) \\in \\mathbb{Z}[y]h(y)=Resx​(g1​,g2​)∈Z[y] 时，我们可以恢复 y0y_0y0​，从而计算 φ(N)\\varphi(N)φ(N)，从而破解该方案。我们对 3 因子 MultiPrime 上维纳攻击的调整，其界限得到了优化：在这种情况下，我们一般界限为 0.1799。但是，如果两个多项式 g1g_1g1​ 和 g2g_2g2​ 有一个公因子，那么 h(y)h(y)h(y) 将恒等于零。从这个意义上说，这种攻击是启发式的，但根据 Boneh 和 Durfee 的说法，在实践中效果很好。另外，使用小于 N43−13r−23r4r2−5r+1N^{\\frac{4}{3}-\\frac{1}{3r}-\\frac{2}{3r}\\sqrt{4r^2-5r+1}}N34​−3r1​−3r2​4r2−5r+1​ 可能很危险。 5.1.2. 高木系列方案的情况 在本部分，我们尝试将攻击应用于高木系列的加密系统。同样地，需要考虑到攻击者可能找到一个 d′d&#x27;d′ ，使得 ed′≡1(modφ(N))ed&#x27; \\equiv 1 (mod \\varphi(N))ed′≡1(modφ(N)) 。方便起见，我们下面将 d′d&#x27;d′ 记为 ddd。从等式 (6) 开始，对于某些 k∈Zk \\in \\mathbb{Z}k∈Z，我们有， ed+k(pr−1qr−1(p−1)(q−1))=1ed+k(p^{r-1}q^{r-1}(p-1)(q-1))=1 ed+k(pr−1qr−1(p−1)(q−1))=1 定义 A:=NA:=NA:=N 和 u:=pr−1qs−1−prqs−1−pr−1qsu:=p^{r-1}q^{s-1}-p^rq^{s-1}-p^{r-1}q^su:=pr−1qs−1−prqs−1−pr−1qs ，我们可以重写上式为： k(A+u)≡1mod ek(A+u)\\equiv 1 \\mod{e} k(A+u)≡1mode 于是我们需要 kkk 和 uuu 的上边界。若假设 eee 和 NNN 位长相同以及 d=Nδd=N^\\deltad=Nδ ，那么 \\begin{gather} |k|=|\\frac{1-ed}{\\varphi(N)}|&lt;e^\\delta=:X\\\\ |u|&lt;2^{s}p^{r+s-1}&lt;N^{\\frac{r+s-1}{r+s}}=:Y \\end{gather} 构造与前一部分相同的矩阵，矩阵的行列式变为： \\begin{equation} \\det(L)=e^{ (\\frac{\\delta}{3}+\\frac{1}{3}-\\frac{r+s-1}{6(r+s)})m^3+ (\\frac{1}{2}+\\frac{\\delta}{2}+\\frac{r+s-1}{2(r+s)})tm^2+ (\\frac{r+s-1}{2(r+s)})mt^2+ o(m^3) } \\end{equation} 为了将定理 3 应用于缩减后的基的前两个向量，我们需要验证引理 5 的条件。这意味着我们必须搜索最大的 δ\\deltaδ，使得 \\begin{equation} \\det(L)&lt;\\frac{1}{\\gamma}e^{m(w-1)} \\text{且有} \\gamma =(w2^w)^{\\frac{w-1}{2}} \\end{equation} 其中 w=(m+1)(m+2)2+t(m+1)=m22+tm+o(m2)w=\\frac{(m+1)(m+2)}{2}+t(m+1)=\\frac{m^2}{2}+tm+o(m^2) w=2(m+1)(m+2)​+t(m+1)=2m2​+tm+o(m2) 忽略一些常数，方程（31）等价于 (δ3−16(r+s))m3+(δ2−12(r+s))tm2+(12−12(r+s))t2m&lt;0\\left( \\frac{\\delta}{3}-\\frac{1}{6(r+s)} \\right)m^3+ \\left( \\frac{\\delta}{2}-\\frac{1}{2(r+s)} \\right)tm^2+ \\left( \\frac{1}{2}-\\frac{1}{2(r+s)} \\right)t^2m&lt;0 (3δ​−6(r+s)1​)m3+(2δ​−2(r+s)1​)tm2+(21​−2(r+s)1​)t2m&lt;0 对每个 mmm，使表达式最小的 ttt 的值为： t=1−δ(r+s)2(r+s−1)t=\\frac{1-\\delta(r+s)}{2(r+s-1)} t=2(r+s−1)1−δ(r+s)​ 将上式的 ttt 值代入前面的方程，得到一个关于 δ\\deltaδ的二次方程。 −r+s8(r+s−1)δ2+2(r+s)−16(r+s−1)δ+1−4(r+s)24(r+s−1)&lt;0-\\frac{r+s}{8(r+s-1)}\\delta^2+ \\frac{2(r+s)-1}{6(r+s-1)}\\delta+ \\frac{1-4(r+s)}{24(r+s-1)}&lt;0 −8(r+s−1)r+s​δ2+6(r+s−1)2(r+s)−1​δ+24(r+s−1)1−4(r+s)​&lt;0 这也就是说 δ&lt;4(r+s)−1−24(r+s)2−5(r+s)+13(r+s)\\delta&lt;\\frac{4(r+s)-1-2\\sqrt{4(r+s)^2-5(r+s)+1}}{3(r+s)} δ&lt;3(r+s)4(r+s)−1−24(r+s)2−5(r+s)+1​​ 因此，由 LLL 给出的前两个向量，g1(x,y)g_1(x, y)g1​(x,y) 和 g2(x,y)g_2 (x, y)g2​(x,y)，在整数上有解 (k,u)(k, u)(k,u) ，而结果多项式 h(y):=Resx(g1,g2)h(y) := Res_x (g_1, g_2)h(y):=Resx​(g1​,g2​) 允许恢复 uuu：一旦知道了 uuu，通过计算 p+q=(u/gcd⁡(N,u))+1p + q =(u/\\gcd (N,u))+1p+q=(u/gcd(N,u))+1 和 pq=N/gcd⁡(N,u)pq = N/\\gcd (N, u)pq=N/gcd(N,u) ,有很高的概率可以恢复 ppp 和 qqq。因此，该攻击要求存在一个 d′d&#x27;d′ 使得 ed′≡1(modφ(N))ed&#x27; \\equiv 1 (mod \\varphi(N))ed′≡1(modφ(N))，从而： d′&lt;N4(r+s)−1−24(r+s)2−5(r+s)+13(r+s)d&#x27;&lt;N^{\\frac{4(r+s)-1-2\\sqrt{4(r+s)^2-5(r+s)+1}}{3(r+s)}} d′&lt;N3(r+s)4(r+s)−1−24(r+s)2−5(r+s)+1​​ 其中 N=prqsN=p^rq^sN=prqs。同样地，这样的 ddd 不能满足 10。特殊情况和数值将在附录 A 中给出。。 备注. 最近，Hinek 等人 [10] 指出，由于一些粗心的近似（详细信息请参阅他们的论文），Boneh-Durfee 的界限是不准确且过于乐观的。在附录A.1 中，我们考虑了他们的观点，计算更精确和严谨的值来限制 δ\\deltaδ。此外，由于用于发动攻击的 LLL 算法是启发式的，注意到常数显然可以被忽略是很重要的。实际上，在实践中这些常数看上去足够小，可以忽略不计。 5.2. 使用几何级数矩阵改进的界限 在[2]中，Boneh 和 Durfee 引入了 几何级数矩阵 的概念。矩阵 MMM 的行和列被分成大小为 bbb 的 a+1a + 1a+1 个块，其中 a,b∈Na, b ∈ Na,b∈N。行（或列）通过 (i,j)(i, j)(i,j) 对索引，其中 i=0,…,ai = 0, \\ldots , ai=0,…,a，j=0,…,bj = 0, \\ldots , bj=0,…,b，使得 (i,j)(i, j)(i,j) 对对应于 MMM 的第 (bi+j)(bi + j)(bi+j) 行（或列）。记第 (i,j)(i, j)(i,j) 列 (k,l)(k, l)(k,l) 行的元素为 M(i,j,k,l)M (i, j, k, l)M(i,j,k,l) 表示。几何级数矩阵的定义如下 定义 6. 设 C,D,c0,c1,c2,c3,c4,βC,D,c_0,c_1,c_2,c_3,c_4,\\betaC,D,c0​,c1​,c2​,c3​,c4​,β 为实数，且 C,D,β≥1C,D,\\beta \\geq 1C,D,β≥1 。若对所有 i,k=0,…,ai,k=0,\\ldots,ai,k=0,…,a 和 j,l=1,…,bj,l=1,\\ldots,bj,l=1,…,b ，有下列条件成立，则称矩阵 MMM 是参数为 (C,D,c0,c1,c2,c3,c4,β)(C,D,c_0,c_1,c_2,c_3,c_4,\\beta)(C,D,c0​,c1​,c2​,c3​,c4​,β) 的几何级数矩阵： ∣M(i,j,k,l)∣≤C.Dc0+c1i+c2j+c3k+c4l|M(i,j,k,l)|\\leq C.D^{c_0+c_1i+c_2j+c_3k+c_4l}∣M(i,j,k,l)∣≤C.Dc0​+c1​i+c2​j+c3​k+c4​l ； M(k,l,k,l)=Dc0+c1k+c2l+c3k+c4lM(k,l,k,l)= D^{c_0+c_1k+c_2l+c_3k+c_4l}M(k,l,k,l)=Dc0​+c1​k+c2​l+c3​k+c4​l ； 当 i&gt;ki&gt;ki&gt;k 或 j&gt;lj&gt;lj&gt;l，M(i,j,k,l)=0M(i,j,k,l)= 0M(i,j,k,l)=0 ； βc1+c3≥0\\beta c_1+c_3 \\geq 0βc1​+c3​≥0 且 βc2+c4≥0\\beta c_2+c_4 \\geq 0βc2​+c4​≥0 。 Boneh 和 Durfee 证明了以下定理，它给出了一个几何级数矩阵去除了一些行后，行列式的界限。 定理 7. 设 MMM 为一个 (a+1)b×(a+1)b(a+1)b \\times(a+1)b(a+1)b×(a+1)b 的几何级数矩阵，矩阵参数为 (C,D,c0,c1,c2,c3,c4,β)(C,D,c_0,c_1,c_2,c_3,c_4,\\beta)(C,D,c0​,c1​,c2​,c3​,c4​,β) 。设 BBB 为实数。定义 SB:={(k,l)∈{0,…,a}×{1,…,b}∣M(k,l,k,l)≤B}S_B:=\\{(k,l)\\in\\{0,\\ldots,a\\}\\times \\{1,\\ldots,b\\}|M(k,l,k,l)\\leq B\\} SB​:={(k,l)∈{0,…,a}×{1,…,b}∣M(k,l,k,l)≤B} 并设 w:=∣SB∣w:=|S_B|w:=∣SB​∣ 。若 LLL 是由 MMM 上的行 (k,l)∈SB(k,l)\\in S_B(k,l)∈SB​ 定义的格，那么： det⁡(L)≤((a+1)b)w2(1+C)w2∏(k,l)∈SBM(k,l,k,l)\\det(L)\\leq ((a+1)b)^{\\frac{w}{2}}(1+C)^{w^2}\\prod_{(k,l)\\in S_B}M(k,l,k,l) det(L)≤((a+1)b)2w​(1+C)w2(k,l)∈SB​∏​M(k,l,k,l) 这种方法的思想是移除一些基向量，特别是那些在格行列式中贡献过大的向量。前面的定理允许控制这个行列式的值。正如下面的引理所述，记为 MyM_yMy​ 的该矩阵、与第 4.1 节中矩阵 MMM 的 yyy -shifts 对应的行组成的矩阵、其列对应于该矩阵的列，使得 xiyjx^iy^jxiyj，其中 j&gt;ij &gt; ij&gt;i 的矩阵，是几何级数的。 5.2.1. Multiprime 的情况 引理 8. 对于任意正整数 m,tm,tm,t，参数为 (m2m,e,m,δ+1−1/r,−1/r,−1,1,2)(m^{2m},e,m,\\delta+1-1/r,-1/r,-1,1,2)(m2m,e,m,δ+1−1/r,−1/r,−1,1,2) 的矩阵 MyM_yMy​ 具有等比级数性质。 证明. 简便起见，我们取 e=Ne=Ne=N。回顾 hl,k(xX,yY)=em−kylYlfk(xX,yY)=∑u=0k∑v=0ucu,vxuyv+lh_{l,k}(xX,yY)=e^{m-k}y^lY^lf^k(xX,yY)=\\sum^{k}_{u=0}\\sum^{u}_{v=0}c_{u,v}x^uy^{v+l} hl,k​(xX,yY)=em−kylYlfk(xX,yY)=u=0∑k​v=0∑u​cu,v​xuyv+l 其中 cu,v=(ku)(uv)(−1)k−uem−kAu−vXuyv+lc_{u,v}=\\binom{k}{u}\\binom{u}{v}(-1)^{k-u}e^{m-k}A^{u-v}X^uy^{v+l} cu,v​=(uk​)(vu​)(−1)k−uem−kAu−vXuyv+l 于是可以计算 My(i,j,k,l)=ci,i+j−l=(kl)(ii+j−l)(−1)k−iem−kAl−jXiYi+jM_y(i,j,k,l)=c_{i,i+j-l}=\\binom{k}{l}\\binom{i}{i+j-l}(-1)^{k-i}e^{m-k}A^{l-j}X^{i}Y^{i+j} My​(i,j,k,l)=ci,i+j−l​=(lk​)(i+j−li​)(−1)k−iem−kAl−jXiYi+j 定义中的条件 (iii) 得到了满足。同时通过代换 X=eδX=e^\\deltaX=eδ 和 Y=e1−1rY=e^{1-\\frac{1}{r}}Y=e1−r1​ ，并且由 A=eA=eA=e ，有 ∣My(i,j,k,l)∣≤(kl)(ii+j−l)em−k+l−j+δi+(1−1/r)(i+j)|M_y(i,j,k,l)|\\leq \\binom{k}{l}\\binom{i}{i+j-l}e^{m-k+l-j+\\delta i+(1-1/r)(i+j)} ∣My​(i,j,k,l)∣≤(lk​)(i+j−li​)em−k+l−j+δi+(1−1/r)(i+j) 于是 ∣My(i,j,k,l)∣≤m2mem+(δ+1−1r)i−1rj−k+l|M_y(i,j,k,l)|\\leq m^{2m}e^{m+(\\delta+1-\\frac{1}{r})i-\\frac{1}{r}j-k+l} ∣My​(i,j,k,l)∣≤m2mem+(δ+1−r1​)i−r1​j−k+l 我们计算 My(k,l,k,l)=em+(δ+1−1r)k−1rl−k+lM_y(k,l,k,l)=e^{m+(\\delta+1-\\frac{1}{r})k-\\frac{1}{r}l-k+l} My​(k,l,k,l)=em+(δ+1−r1​)k−r1​l−k+l 其满足条件 (ii)。最后，由于下面两个不等式成立 2(δ+1−1r−1≥0)和2−1r+1≥02(\\delta+1-\\frac{1}{r}-1\\geq 0) \\quad\\text{和}\\quad 2\\frac{-1}{r}+1 \\geq 0 2(δ+1−r1​−1≥0)和2r−1​+1≥0 所以我们的矩阵 MyM_yMy​ 是参数为 (m2m,e,m,δ+1−1/r,−1/r,−1,1,2)(m^{2m},e,m,\\delta+1-1/r,-1/r,-1,1,2)(m2m,e,m,δ+1−1/r,−1/r,−1,1,2) 的几何级数矩阵得证。 记为 M1M_1M1​ 的几何级数矩阵，是在第 4.1 节中定义的矩阵的基上构造的，但是取前一种矩阵两倍的 yyy -shifts，即设 t=1−δr(r−1t = \\frac{1 - δr }{ (r - 1}t=(r−11−δr​。然后，移除对角线上条目超过 eme^mem 的 yyy -shifts 对应的行。通过高斯消元，我们得到一个单位矩阵 AAA，使得 M1=AM2M_1 = AM_2M1​=AM2​，其中 M2M_2M2​ 的形式为： 【占位符】 其中 Δ\\DeltaΔ 是一个对角矩阵。于是因为 det⁡(L1)=det⁡(L2)\\det (L_1) = \\det (L_2)det(L1​)=det(L2​)，我们可以在格 L2L_2L2​ 上应用定理 7。此外，因为 x-shifts 和选定的 y-shifts 是正交的， det⁡(L2)=det⁡(Δ)det⁡(Ly′)\\det(L_2) = \\det (\\Delta) \\det (L&#x27;_y)det(L2​)=det(Δ)det(Ly′​)。格 L2L_2L2​ 的维度 www 计算如下： w=m(m+1)(m+2)2+w′w=\\frac{m(m+1)(m+2)}{2}+w&#x27; w=2m(m+1)(m+2)​+w′ 其中 w′w&#x27;w′ 是 Ly′L&#x27;_yLy′​ 的维度。满足 M(k,l,k,l)&lt;emM(k,l,k,l) &lt; e^mM(k,l,k,l)&lt;em 的元素 M(k,l,k,l)M(k,l,k,l)M(k,l,k,l) 将被移除，即 em+(δ−1r)k+(1−1r)l&lt;eme^{m+(\\delta-\\frac{1}{r})k+(1-\\frac{1}{r})l}&lt;e^m em+(δ−r1​)k+(1−r1​)l&lt;em 这些元素会导致 l&lt;1−δrr−1kl&lt;\\frac{1-\\delta r}{r-1}k l&lt;r−11−δr​k 于是我们有 w′=∑k=0m⌊1−δrr−1k⌋≥∑k=0m(1−δrr−1k+1)=1−δr2(r−1)m2+o(m2)w&#x27;=\\sum^{m}_{k=0}\\left\\lfloor \\frac{1-\\delta r}{r-1}k\\right\\rfloor \\geq \\sum^{m}_{k=0}\\left( \\frac{1-\\delta r}{r-1}k+1\\right) =\\frac{1-\\delta r}{2(r-1)}m^2+o(m^2) w′=k=0∑m​⌊r−11−δr​k⌋≥k=0∑m​(r−11−δr​k+1)=2(r−1)1−δr​m2+o(m2) 最后结合定理 7 我们得到 \\begin{align*} \\det (L&#039;_y)\\leq c \\prod^{m}_{k=0}\\prod^{\\lfloor \\frac{1-\\delta r}{r-1}k \\rfloor}_{l=0} e^{m+(\\delta - \\frac{1}{r})k+(1-\\frac{1}{r})l}\\\\ \\det(l&#039;_y)\\leq ce^{\\frac{(\\delta r+3r-1)(1-\\delta r)}{6(r-1)r}m^3+o(m^3)} \\end{align*} 其中 ccc 只是 δδδ 的函数，可以忽略不计。 我们现在可以限制 det⁡(L1)=det⁡(Δ)det⁡(L′y)&lt;e−δr+rδ2−3r+16(r−1)m3+o(m3)\\det(L_1)=\\det(\\Delta)\\det(L&#x27;y)&lt;e^{-\\frac{\\delta r+ r \\delta^2-3r+1}{6(r-1)}m^3+o(m^3)} det(L1​)=det(Δ)det(L′y)&lt;e−6(r−1)δr+rδ2−3r+1​m3+o(m3) 我们需要使这个项低于 em(w′′−1)e^{m (w&#x27;&#x27;-1)}em(w′′−1)，其中 w′′=12(m+1)(m+2)+w′w&#x27;&#x27; = \\frac{1}{2}(m + 1)(m + 2) + w&#x27;w′′=21​(m+1)(m+2)+w′，这使得 (−rδ2+2δr−1)m3&lt;0(-r \\delta^2+2\\delta r-1)m^3&lt;0 (−rδ2+2δr−1)m3&lt;0 这给出了 δ&lt;1−r2−rr\\delta &lt;1-\\frac{\\sqrt{r^2-r}}{r} δ&lt;1−rr2−r​​ 对 3 质数模数，得到的界限约为 0.184，这比之前的界限有所改进。 6. 总结 本报告将 Wiener 和 Boneh-Durfee 的结果扩展到多质数 RSA 的情况，并表明这些攻击可能不适用于 Takagi 方案。 就多质数 RSA 而言，结果表明，尽管该攻击仍然适用，但其效率随着因子数量增加而迅速下降。但需要记住的是，要保持与经典 RSA 相同的安全级别，模数大小必须随着因子数量的增加而增加。实际上，结果倾向于表明攻击适用的范围是固定的。例如，对于要达到和 1024 位经典 RSA 相当的安全级别，理论上 秘密指数必须大于 250 或 300 位。 然而，我们还要强调 LLL 及该攻击的启发式性质，有时结果可能比预期的效率要高得多。因此额外的安全边界是可取的。正如 Boneh 和 Durfee 指出的那样，我们不能将我们的结果作为定理给出，因为没有确保 LLL 输出两个代数独立的向量。 我们在本报告中展示了可以使用相当短的秘密指数来进行 RSA MultiPrime。与使用经典 RSA 和 CRT 相比，这改善了签名生成。然而，正如 Durfee 和 Nguyen 在[7]中解释的那样，当使用短 RSA 秘密指数时，应该非常谨慎。格工具改进了 N1/6N^{1/6}N1/6 的界限，如果我们更详细地研究具有低解的带模多项式方程的解析，也许能稍微增加一些边界。一种击败该攻击的方法是通过给 eee 加上 lcm(p−1,q−1,r−1)\\mathrm{lcm} (p-1,q-1, r-1)lcm(p−1,q−1,r−1) 的倍数的方法，使 eee 位长增加。此外，将质数添加到模数中可能会使 Boneh-Durfee 方法不那么有效，因为其处理过程中涉及多项式的变量数可能会产出过大的格。 Wiener 提出，作为一种快速计算秘密指数的对策，能否找到一个大的秘密指数 ddd，使得 dpi=dmod pi−1d_{pi}=d \\mod p_i-1dpi​=dmodpi​−1 对模数的每个质因子 pip_ipi​ 都很小。是否存在一种有效的攻击方法来破解这种秘密指数是一个未解决的问题。已知的最佳攻击耗时 (dp,dq)(\\sqrt{d_p},\\sqrt{d_q})(dp​​,dq​​) 是对于一个 2 质数模数做出的。 7. 致谢 作者要感谢 Ali Akhavi、 Jean-François Misarsky 和 Francesco Sica 在初稿中进行了富有成果的讨论，并提供了有用的评论。 8. References 9. A. Lattice 攻击 9.1. A.1. Adaption 9.2. A.2 10. B 总结 最后的重组步骤可以忽略不计，因此没有考虑。 ↩︎","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"高木变体","slug":"高木变体","permalink":"http://example.com/tags/%E9%AB%98%E6%9C%A8%E5%8F%98%E4%BD%93/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"毕业设计（3）：RSA多小密钥指数变体的密码学分析","slug":"毕业设计/毕业设计4：RSA多小密钥指数变体的密码学分析","date":"2024-04-20T14:12:22.000Z","updated":"2024-04-27T17:14:04.634Z","comments":true,"path":"post/20240420221222.html","permalink":"http://example.com/post/20240420221222.html","excerpt":"前言 原名Cryptanalysis of Variants of RSA with Multiple Small Secret Exponents，INDOCRYPT 2015。","text":"前言 原名Cryptanalysis of Variants of RSA with Multiple Small Secret Exponents，INDOCRYPT 2015。 摘要 在本文中，我们分析了 RSA 公钥加密系统的两种变体的安全性，其中使用了多个加密和解密指数，并且这些指数共用一个模数。对于最为知名的变体 CRT-RSA，假设有 nnn 个加密和解密指数 (el,dpl,dql)(e_l, d_{p_l}, d_{ql})(el​,dpl​​,dql​)，其中 l=1,…,nl = 1, \\ldots , nl=1,…,n，与一个共用的 CRT-RSA 模数 NNN 一同使用。通过利用基于 Minkowski 求和的格构造，并结合几个共享一个变量的模方程，我们证明了当对所有 l=1,…,nl = 1, \\ldots , nl=1,…,n，有 dpl,dql&lt;N2n−38n+2d_{p_l}, d_{ql} &lt; N^\\frac{2n-3}{8n+2}dpl​​,dql​&lt;N8n+22n−3​ 时，可以对 N 进行因式分解。我们进一步将这一边界提高到对所有 l=1,…,nl = 1, \\ldots , nl=1,…,n，dpld_{p_l}dpl​​（或 dqld_{ql}dql​）&lt;N9n−1424n+8&lt; N^\\frac{9n-14}{24n+8}&lt;N24n+89n−14​。此外，我们的实验结果在使用多个指数时优于以前的作品，例如 Jochemsz-May (Crypto 2007)和 Herrmann-May (PKC 2010)。对于 Takagi 的 RSA 变体，假设有 nnn 个密钥对(e_l, dl) ，其中 l=1,…,nl = 1, \\ldots , nl=1,…,n，可用于一个共同的模数 N=prqN=p^rqN=prq，其中 r ≥ 2。通过解决若干个同时的模一元线性方程，我们证明了当对所有 l=1,⋯ ,nl = 1, \\cdots , nl=1,⋯,n，dl&lt;N(r−1r+1)n+1nd_l &lt; N^{\\left(\\frac{r-1}{r+1}\\right)^{\\frac{n+1}{n}}}dl​&lt;N(r+1r−1​)nn+1​ 时，可以对共同的模数 NNN 进行因式分解。 介绍 自从 RSA 公钥方案的发明以来[16]，由于其有效的加密和解密，它已被广泛应用。为了获得高效性，一些原始 RSA 的变体被设计出来。Wiener [24]提出了一种算法，在解密阶段使用中国剩余定理来加速解密操作，通过使用满足 edp≡1mod(p−1)e d_{p}\\equiv 1\\mathrm{mod}(p-1)edp​≡1mod(p−1) 且 edq≡1mod(q−1)e d_{q}\\equiv 1\\mathrm{mod}\\left(q-1\\right)edq​≡1mod(q−1) 的较小指数 dpd_pdp​ 和 dqd_qdq​，其中模数为 N=pqN=pqN=pq，加密指数为 e。这种解密导向的 RSA 方案通常被称为 CRT-RSA。同样为了获得快速解密实现，Takagi [21]提出了另一种 RSA 的变体，其模数形式为 N=prqN=p^rqN=prq，其中 r≥2r ≥ 2r≥2 是一个整数。对于 Takagi 的变体，加密指数 eee 和解密指数 ddd 满足 ed≡1(modpr−1(p−1)(q−1))ed \\equiv 1 \\pmod{p^{r-1}(p - 1)(q - 1)}ed≡1(modpr−1(p−1)(q−1))。 在 RSA 方案及其变体的许多应用中，要么选择 ddd 较小，要么选择 dpd_pdp​ 和 dqd_qdq​ 较小以便在解密过程中进行高效的模指数运算。然而，自从 Wiener [24]展示了当 ddd 足够小时原始 RSA 方案不安全，沿着这个方向，许多研究人员都对在小解密指数下对 RSA 模数及其变体的因式分解给予了极大关注。 RSA 及其变体的小指数攻击：对于原始的 RSA，当 d≤N0.25d \\leq N^{0.25}d≤N0.25 时，Wiener [24]证明了可以通过连分数法在多项式时间内因式分解模数 NNN。后来，Boneh 和 Durfee [2]利用了一种基于格的方法，该方法通常被称为 Coppersmith 技术 [5]，用于寻找模方程的小根，他们在几个可接受的假设下将界限提高到了 N0.292N^{0.292}N0.292。随后，Herrmann 和 May [6]使用了一种线性化技术简化了所涉及的格的构造，并获得了相同的界限 N0.292N^{0.292}N0.292。到目前为止，N0.292N^{0.292}N0.292 仍然是对具有完整 eee 大小的原始 RSA 方案的小秘密指数攻击的最佳结果。 对于 CRT-RSA，Jochemsz 和 May [10]提出了一种针对小 dpd_pdp​ 和 dqd_qdq​ 的攻击，其中 ppp 和 qqq 是平衡的，加密指数 eee 的大小是完整的，即大约与模数 N=pqN = pqN=pq 一样大。通过解一个整数方程，他们可以因式分解 NNN，前提是小的解密 CRT 指数 dpd_pdp​ 和 dqd_qdq​ 小于 N0.073N^{0.073}N0.073。同样，Herrmann 和 May [6]使用了一种线性化技术获得了相同的理论界限，但在实验中取得了更好的结果。 对于具有模数 N=prqN=p^rqN=prq 的 Takagi 的 RSA 变体，May [13]应用了 Coppersmith 的方法证明了可以因式分解模数，前提是 d≤N(r−1r+1)2d \\leq N^{(\\frac{r-1}{r+1})^2}d≤N(r+1r−1​)2。通过修改构造格中的多项式集合，Lu 等人 [12]将这个界限提高到了 d≤N(r(r−1)(r+1)2)d \\leq N^{(\\frac{r(r-1)}{(r+1)^2})}d≤N((r+1)2r(r−1)​)。最近，从利用代数性质 prq=Np^rq = Nprq=N 的新视角出发，Sarkar [17]改进了当 r≤5r \\leq 5r≤5 时的界限。特别是对于 r=2r = 2r=2 的最实际情况，界限从 N0.222N^{0.222}N0.222 显著提高到了 N0.395N^{0.395}N0.395。下表列出了 RSA 及其变体的现有小解密指数攻击情况。 多个小秘密指数的 RSA：为了简化 RSA 密钥管理，人们可能会为几个密钥对（eie_iei​, did_idi​）使用单个 RSA 模数 NNN。Simmons [19]表明，如果一条消息 mmm 发送给两个公钥指数互质的参与者，那么消息 mmm 很容易恢复。然而，Simmons 的攻击无法因式分解 NNN。因此，Howgrave-Graham 和 Seifert [8]分析了对于一个共同的模数 NNN 存在多个可用的加密指数 (e1,⋯ ,en)(e_1, \\cdots , e_n)(e1​,⋯,en​) 以及相应的小解密指数 (d1,⋯ ,dn)(d_1, \\cdots , d_n)(d1​,⋯,dn​) 的情况。根据他们的结果，对于 l=1,⋯ ,nl=1,\\cdots,nl=1,⋯,n，当 nnn 个解密指数满足 dl&lt;Nδd_l &lt; N^\\deltadl​&lt;Nδ 时，可以因式分解 NNN，其中 δ&lt;{(2n+1)2n−(2n+1)(nn2)(2n−1)2n+(4n+2)(nn2), 若 n 为奇数,(2n+1)2n−4n(n−1n−12)(2n−2)22n+8n(n−1n−12), 若 n 为偶数,.\\delta\\lt {\\left\\{ \\begin{array}{l l} {\\frac{(2n+1)2^{n}-(2n+1){\\binom{n}{\\frac{n}{2}}}}{(2n-1)2^{n}+(4n+2){\\binom{n}{\\frac{n}{2}}}}},{\\text{~若~}}n{\\text{~为奇数}},\\\\ {\\frac{(2n+1)2^{n}-4n{\\binom{n-1}{\\frac{n-1}{2}}}}{(2n-2)2^{2^n}+8n{\\binom{n-1}{\\frac{n-1}{2}}}},{\\text{~若~}}n{\\text{~为偶数}},.} \\end{array}\\right.} δ&lt;⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​(2n−1)2n+(4n+2)(2n​n​)(2n+1)2n−(2n+1)(2n​n​)​, 若 n 为奇数,(2n−2)22n+8n(2n−1​n−1​)(2n+1)2n−4n(2n−1​n−1​)​, 若 n 为偶数,.​ Table 1: 小秘密指数攻击 RSA 及其变体的现有研究概况。最后一列中的条件允许高效因式分解模数 NNN。 Table 2: 就解密指数数量而言，以前的理论界限的比较。 在[18]中，Sarkar 和 Maitra采用了[9]中的策略来解决一个整数方程的小根，并将界限提高到了 δ&lt;3n−1(4n+4)\\delta &lt; \\frac{3n-1}{ (4n+4)}δ&lt;(4n+4)3n−1​。Aono [1]提出了一种解决多个同时的模方程的方法，这些方程共享一个未知变量。Aono 通过基于 Minkowski 求和的格构造将几个格合并成一个格，并得出当δ&lt;9n−512n+4\\delta &lt; \\frac{9n-5}{12n+4} δ&lt;12n+49n−5​时，可以对NNN进行因式分解。随后不久，Takayasu和Kunihiro [23]修改了每个格，并收集了更多有用的多项式，将界限改进到了1−23n+11 - \\sqrt{\\frac{2}{3n+1}}1−3n+12​​。总之，前期工作的明确比较如表2所示。 模未知除数的同时模一元线性方程：2001年，Howgrave-Graham 首次考虑了解决一个未知除数的已知复合整数的模一元线性方程的问题，形式为 f(x)=x+a(modp)f(x) = x + a \\pmod{p} f(x)=x+a(modp) 其中 aaa 是给定的整数，p≃Nβp \\simeq N^\\betap≃Nβ 是已知 NNN 的未知因子。根的大小受到 ∣x∣&lt;Nδ|x| &lt; N^\\delta∣x∣&lt;Nδ 的限制。Howgrave-Graham 证明了只要 δ&lt;β2\\delta &lt; β^2δ&lt;β2，就可以在多项式时间内求解根。 Cohn 和 Heninger [4]考虑了这个问题的一般化： {f(x1)=x1+a1 (mod p),f(x2)=x2+a2 (mod p),⋅⋅⋅f(xn)=xn+an (mod p).\\left\\{\\begin{array}{l} {f(x_{1})=x_{1}+a_{1}\\,\\,(\\mathrm{mod}\\,p),}\\\\ {f(x_{2})=x_{2}+a_{2}\\,\\,(\\mathrm{mod}\\,p),}\\\\ {\\cdot\\cdot\\cdot}\\\\ {f(x_{n})=x_{n}+a_{n}\\,\\,(\\mathrm{mod}\\,p).} \\end{array}\\right.⎩⎪⎪⎪⎨⎪⎪⎪⎧​f(x1​)=x1​+a1​(modp),f(x2​)=x2​+a2​(modp),⋅⋅⋅f(xn​)=xn​+an​(modp).​ 在上述的同时模一元线性方程中，a1,⋯ ,ana_1, \\cdots , a_na1​,⋯,an​ 是给定的整数，而 p≃Nβp \\simeq N^\\betap≃Nβ 是 NNN 的一个未知因子。根据他们的结果，如果满足以下条件，就可以对 N 进行因式分解： γ1+⋅⋅⋅+γnn &lt;βn+1n 且 β≫1log⁡N\\frac{\\gamma_{1}+\\cdot\\cdot\\cdot+\\gamma_{n}}{n}\\,\\lt \\beta^{\\frac{n+1}{n}}\\,~\\text{且}\\ \\beta \\gg \\frac{1}{\\sqrt{\\log N}} nγ1​+⋅⋅⋅+γn​​&lt;βnn+1​ 且 β≫logN​1​ 其中 ∣x1∣&lt;Nγ1,…,∣xn∣&lt;Nγn|x_1| &lt; N^{\\gamma_1}, \\ldots , |x_n| &lt; N^{\\gamma_n}∣x1​∣&lt;Nγ1​,…,∣xn​∣&lt;Nγn​。然后，通过考虑未知变量的大小并收集更多有用的多项式来构造格，Takayasu 和 Kunihiro [22]进一步将界限改进为 \\sqrt[n]{\\gamma_1 \\cdots \\gamma_n} &lt; \\beta^{\\frac{n+1}{n}} \\,~\\text{且}\\ \\beta \\gg \\frac{1}{\\sqrt{\\log N}} 我们的贡献：在本文中，我们分别对 CRT-RSA 和 Takagi 的 RSA 变体进行了多个小解密指数的分析。对于 CRT-RSA，(e1,⋯ ,en)(e_1, \\cdots , e_n)(e1​,⋯,en​) 是 nnn 个加密指数，而 (dp1,dq1),⋯ ,(dpn,dqn)(d_{p1}, d_{q1}), \\cdots , (d_{pn}, d_{qn})(dp1​,dq1​),⋯,(dpn​,dqn​) 是对一个共同的 CRT-RSA 模数 NNN 的相应解密指数，其中 e1,⋯ ,ene_1, \\cdots , e_ne1​,⋯,en​ 与 NNN 位长相同。基于 Aono [1]提出的基于 Minkowski 求和的格构造，我们结合了几个共享一个公共变量的模方程，并得出了结论，当对所有 $$l = 1, \\ldots , n$$,其中解密指数的数量为 nnn 时， dpl,dql&lt;N2n−38n+2d_{pl}, d_{ql} &lt; N^{\\frac{2n-3}{8n+2}} dpl​,dql​&lt;N8n+22n−3​ 为了利用基于 Minkowski 求和的格构造来合并方程，这些方程应该共享一个公共变量。因此，我们修改了[10]中考虑的每个方程，当只有一对加密和解密指数时，它们导致了一个更差的界限。 然而，注意到模方程 kpl(p−1)+1≡0(model)k_{pl}(p - 1) + 1 \\equiv 0 \\pmod{e_l} kpl​(p−1)+1≡0(model​) 对于 l=1,…,nl = 1, \\ldots , nl=1,…,n，共享一个公共根 ppp。然后，我们可以通过基于 Minkowski 求和的格构造直接组合这些 nnn 个方程，而且引入了一个新变量 qqq 来最小化组合格的行列式。我们可以得到一个改进的界限，即当对所有 $$l = 1, \\ldots , n$$ 时，dpl&lt;N9n−1424n+8d_{pl} &lt; N^\\frac{9n-14}{24n+8}dpl​&lt;N24n+89n−14​。 需要注意的是，为了组合这些方程，我们修改了[10]中考虑的每个方程。当有 n=2n = 2n=2 个解密指数时，我们的界限是 N0.071N^{0.071}N0.071，小于[10]中的界限 N0.073N^{0.073}N0.073。因此，我们只在存 n≥3n ≥ 3n≥3 对共用一个共同的 CRT-RSA 模数加密和解密指数时，在理论上改进了之前的界限，并在渐近情况下获得了 N0.375N^0.375N0.375。然而，令人欣慰的是，我们成功地通过实践在 dpl&lt;N0.035d_{pl} &lt; N^{0.035}dpl​&lt;N0.035 的情况下使用了3对指数因式分解 NNN，并且原始界限是[10]中的 N0.015N^0.015N0.015 和[6]中的 N0.029N^0.029N0.029。 这些界限的明确描述如图1所示。 Fig. 1. CRT-RSA 的秘密指数可恢复的范围。实线表示 dpld_{pl}dpl​ 和 dqld_{ql}dql​ 与 nnn 的关系范围，虚线表示 dpld_{pl}dpl​ 与 nnn 的关系范围。 对于 Takagi 的 RSA 变体，假设存在 nnn 个加密和解密指数 (el,dl)(e_l, d_l)(el​,dl​)，其中 $$l = 1, \\ldots , n$$ 共用一个模数 N=prqN=p^rqN=prq，这意味着存在 lll 个同时的模一元线性方程。到目前为止，这种模方程是[4,22]中考虑的内容。通过应用它们的结果，我们得出结论，当对所有 $$l = 1, \\ldots , n$$ 时，dl≤Nδd_l \\leq N^\\deltadl​≤Nδ 时，可以对模数进行因式分解，其中 δ&lt;(r−1r+1)(n+1)n\\delta &lt; \\left(\\frac{r - 1}{r + 1}\\right) ^ \\frac{(n+1)}{n} δ&lt;(r+1r−1​)n(n+1)​ 本文的其余部分安排如下。第2节是关于格和 CRT-RSA 变体的一些初步知识。在第3节中，我们分析了具有多个小解密指数的 CRT-RSA。第4节介绍了对具有多个小解密指数的 Takagi 的变体 RSA 的分析。最后，第5节是结论。 2. 预备知识 让 w1,w2,⋯ ,wkw_1, w_2, \\cdots , w_kw1​,w2​,⋯,wk​ 为 nnn 维空间 Rn\\mathbb{R}^{n}Rn 中的 kkk 个线性无关向量。由 w1,⋯ ,wk{w_1, \\cdots , w_k}w1​,⋯,wk​ 张成的格 L\\mathcal{L}L 是所有 w1,⋯ ,wkw_1, \\cdots , w_kw1​,⋯,wk​ 的整数线性组合 c1w1+⋯+ckwkc_1w_1 + \\cdots + c_kw_kc1​w1​+⋯+ck​wk​ 的集合，其中 c1,…,ck∈Zc_1, \\ldots , c_k \\in \\mathbb{Z}c1​,…,ck​∈Z。kkk 维格 L\\mathcal{L}L 是 Rn\\mathbb{R}^{n}Rn 中的离散加法子群。向量 w1,⋯ ,wk{w_1, \\cdots , w_k}w1​,⋯,wk​ 的集合称为格 L\\mathcal{L}L 的一个基。格基不是唯一的，可以通过乘以行列式为 ±1±1±1 的任意矩阵获得另一个基，这意味着任何维数大于 111 的格都有无穷多个基。因此，如何找到具有良好性质的格基一直是一个重要问题。 Lenstra 等人[11]引入了著名的 L3L^3L3 格基约简算法，该算法可以在多项式时间内输出相对较短且几乎正交的格基。该算法不是寻找格中最短的向量，而是找到具有以下有用性质的 L3L^3L3 约简基。 引理1（L3L^3L3，[11]）。设 L\\mathcal{L}L 是维度为 kkk 的格。将 L3L^3L3 算法应用于 L\\mathcal{L}L，输出的约简基向量 v1,…,vkv_1, \\ldots , v_kv1​,…,vk​ 满足以下条件 ∥vi∥≤2k(k−i)4(k+1−i)⋅det⁡(L)1k+1−i\\lVert v_i \\rVert \\leq 2^\\frac{k(k-i)}{4(k+1-i)} \\cdot \\det({\\mathcal{L}})^\\frac{1}{k+1-i} ∥vi​∥≤24(k+1−i)k(k−i)​⋅det(L)k+1−i1​ ，对于任意 1≤i≤k1 \\leq i \\leq k1≤i≤k。 Coppersmith [5]应用 L3L^3L3 格基约简算法来寻找整数方程和模方程的小解。后来，Jochemsz 和 May [9]扩展了这一技术，并给出了找到多元多项式的根的一般结果。 对于给定的多项式 g(x1,⋯ ,xk)=∑(i1,…,ik)ai1,…,ikx1i1⋯xkikg(x_1, \\cdots , x_k) = \\sum_{(i_1,\\ldots,i_k)} a_{i_1,\\ldots,i_k}x^{i_1}_1 \\cdots x^{i_k}_{k}g(x1​,⋯,xk​)=∑(i1​,…,ik​)​ai1​,…,ik​​x1i1​​⋯xkik​​，我们定义 ggg 的范数为 ∥g(x1,…,xk)∥=(∑(i1,…,ik)ai1,…,ik2)12\\lVert g(x_1, \\ldots , x_k) \\rVert = \\left( \\sum_{(i_1,\\ldots,i_k)} a_{i_1,\\ldots,i_k}^2 \\right)^{\\frac{1}{2}} ∥g(x1​,…,xk​)∥=⎝⎛​(i1​,…,ik​)∑​ai1​,…,ik​2​⎠⎞​21​ Howgrave-Graham [7]的以下引理给出了将模方程转换为整数方程的一个充分条件。 引理2（Howgrave-Graham，[7]）。设 g(x1,…,xk)∈Z[x1,…,xk]g(x_1, \\ldots , x_k) \\in \\mathbb{Z}[x_1, \\ldots , x_k]g(x1​,…,xk​)∈Z[x1​,…,xk​] 是一个最多有 www 个单项式的整数多项式。假设 g(y1,⋯ ,yk)≡0(modpm)对于成立∣y1∣≤X1,⋯ ,∣yk∣≤Xk并且∥g(x1X1,…,xkXk)∥&lt;pmw\\begin{aligned} &amp;g(y_1, \\cdots , y_k) \\equiv 0 \\pmod{p^m} \\text{对于成立} |y_1| \\leq X_1, \\cdots , |y_k| \\leq X_k\\text{并且}\\\\ &amp;\\lVert g(x_1X_1, \\ldots , x_kX_k) \\rVert &lt; \\frac{p^m}{\\sqrt{w}} \\end{aligned}​g(y1​,⋯,yk​)≡0(modpm)对于成立∣y1​∣≤X1​,⋯,∣yk​∣≤Xk​并且∥g(x1​X1​,…,xk​Xk​)∥&lt;w​pm​​ 那么在整数域上g(y1,…,yk)=0g(y_1, \\ldots , y_k) = 0g(y1​,…,yk​)=0成立。 假设我们有 w(&gt;k)w(&gt; k)w(&gt;k) 个多项式 b1,…,bwb_1, \\ldots , b_wb1​,…,bw​，它们是关于变量 x1,…,xkx_1, \\ldots , x_kx1​,…,xk​ 的，满足 b1(y1,…,yk)=⋯=bw(y1,…,yk)=0(modpm)b_1(y_1, \\ldots , y_k) = \\cdots = b_w(y_1, \\ldots , y_k) = 0 \\pmod{p^m}b1​(y1​,…,yk​)=⋯=bw​(y1​,…,yk​)=0(modpm)，其中 ∣y1∣≤X1,…,∣yk∣≤Xk|y_1| \\leq X_1, \\ldots , |y_k| \\leq X_k∣y1​∣≤X1​,…,∣yk​∣≤Xk​。现在我们构造一个由 b1(x1X1,…,xkXk),…,bw(x1X1,…,xkXk)b_1(x_1X_1, \\ldots , x_kX_k), \\ldots , b_w(x_1X_1, \\ldots , x_kX_k)b1​(x1​X1​,…,xk​Xk​),…,bw​(x1​X1​,…,xk​Xk​) 的系数向量构成的格 L\\mathcal{L}L。经过格约简后，我们得到 kkk 个多项式 v1(x1,…,xk),…,vk(x1,…,xk)v_1(x_1, \\ldots , x_k), \\ldots , v_k(x_1, \\ldots , x_k)v1​(x1​,…,xk​),…,vk​(x1​,…,xk​)，满足 v1(y1,…,yk)=⋯=vk(y1,…,yk)=0(modpm)v_1(y_1, \\ldots , y_k) = \\cdots = v_k(y_1, \\ldots , y_k) = 0 \\pmod{p^m} v1​(y1​,…,yk​)=⋯=vk​(y1​,…,yk​)=0(modpm) 它们对应于约简基的前 kkk 个向量。同时由 L3L^3L3 算法的性质，我们有 ∥v1(x1X1,…,xkXk)∥≤⋯≤∥vk(x1X1,…,xkXk)∥≤2w(w−1)4(w+1−k)det⁡(L)1w+1−k.\\lVert v_1(x_1X_1, \\ldots , x_kX_k) \\rVert \\leq \\cdots \\leq \\lVert v_k(x_1X_1, \\ldots , x_kX_k) \\rVert \\leq 2^\\frac{w(w-1)}{4(w+1-k)}\\det(\\mathcal{L}) ^ \\frac{1}{w+1-k}. ∥v1​(x1​X1​,…,xk​Xk​)∥≤⋯≤∥vk​(x1​X1​,…,xk​Xk​)∥≤24(w+1−k)w(w−1)​det(L)w+1−k1​. 因此根据引理2，如果 2w(w−1)4(w+1−k)⋅det⁡(L)1w+1−k&lt;pmw2^{\\frac{w(w-1)}{4(w+1-k)}} \\cdot \\det({\\mathcal{L}})^{\\frac{1}{w+1-k}} &lt; \\frac{p^m}{ \\sqrt{w}} 24(w+1−k)w(w−1)​⋅det(L)w+1−k1​&lt;w​pm​ 那么我们有 v1(y1,…,yk)=⋯=vk(y1,…,yk)=0v_1(y_1, \\ldots , y_k) = \\cdots = v_k(y_1, \\ldots , y_k) = 0v1​(y1​,…,yk​)=⋯=vk​(y1​,…,yk​)=0。接下来我们想要从 v1,…,vkv_1, \\ldots , v_kv1​,…,vk​ 中找到 y1,…,yky_1, \\ldots , y_ky1​,…,yk​。 一旦我们从 L3L^3L3 格基约简算法得到了几个整数多项式方程，我们就可以通过计算多项式的 resultant 或 Gröbner 基来解出整数根，这基于以下的启发式假设。在实际实验中，以下的启发式假设通常成立。 假设1：我们基于格的构造产生了代数无关的多项式。这些多项式的公共根可以通过计算resultant或找到Gröbner基等技术来高效地计算。 与其他格约简工作类似[1,9,10,23]，虽然我们提供了实验结果支持我们的攻击，但我们也想指出理论结果是渐近的，因为我们在攻击计算中在某些情况下忽略了常数。 基于 Minkowski 求和的格构造。在[1]中，Aono 提出了一种用于同时模方程 Coppersmith 技术的格构造方法。为了阐明这一点，让我们通过一个例子来说明。假设有两个模方程 f1≡0(modW1)f_1 \\equiv 0 \\pmod{W_1}f1​≡0(modW1​) 和 f2≡0(modW2)f_2 \\equiv 0 \\pmod{W_2}f2​≡0(modW2​)。基于 Coppersmith 的技术，为了解 f1f_1f1​ 的解，我们首先选择一些多项式 g1,…,gng_1, \\ldots , g_ng1​,…,gn​，它们在模 W1mW^m_1W1m​ 下具有相同的解。类似地，我们构造多项式 g1′,…,gn′g&#x27;_1, \\ldots , g&#x27;_ng1′​,…,gn′​，它们在模 W2mW^m_2W2m​ 下具有相同的解。显然，任何多项式 gigj′g_i g&#x27;_jgi​gj′​，其中 1≤i,j≤n1 \\leq i,j \\leq n1≤i,j≤n，都具有模 W1mW2mW^m_1 W^m_2W1m​W2m​ 下的所需解。然后我们排列这些多项式，并构造一个新的格，其中的多项式在 W1mW2mW^m_1 W^m_2W1m​W2m​ 下具有所需的解。通过整数线性组合，其中一些具有相同首项的多项式可以写成 ∑i,jai,jgigj′\\sum_{i,j} a_{i,j} g_i g&#x27;_j∑i,j​ai,j​gi​gj′​ '。为了保持格的行列式较小，整数 ai,ja_{i,j}ai,j​ 会适当地选择。这个格称为由多项式 g1,…,gng_1, \\ldots , g_ng1​,…,gn​ 构造的格和由多项式 g1′,…,gn′g&#x27;_1, \\ldots , g&#x27;_ng1′​,…,gn′​ 构造的格的合并格。 Aono证明了如果每个格都有三角形的基矩阵，那么合并的格将是三角形的。上述结论可以推广到任意数量的模方程。 CRT-RSA，即中国剩余定理 RSA，是 RSA 公钥加密系统的一种变体。自从 RSA 公钥加密系统的发明以来，由于其简洁有效的加密和解密方式，该公钥方案已被广泛应用。Wiener [24] 提出在解密阶段使用中国剩余定理。这个方案通常被称为 CRT-RSA。基于 Sun 和 Wu 的工作 [20]，这个变体的一个版本可以描述如下： 在 CRT-RSA 的密钥生成算法中描述了这样一种情况：可能存在多个有效的加密和解密指数对应于相同的 CRT-RSA 模 N=pqN = pqN=pq，也就是说，当我们完成第一步选择一对 (p,q)(p, q)(p,q) 时，在剩下的步骤中我们生成了几个不同的 dpd_pdp​ 和 dqd_qdq​。接下来，我们分析多个加密和解密指数共享相同 CRT-RSA 模数的弱点。 3 CRT-RSA的多重加密和解密指数攻击 在这一部分，沿用[1,8,18,23]的思路，我们给出了以下定理，用于描述当多个加密和解密指数用于一个公共的 CRT-RSA 模时的情况。通过将我们的结果与 Jochemsz 和 May 的结果[10]进行比较，我们改进了在一个公共的 CRT-RSA 模中存在 333 个或更多对加密和解密指数时的界限。我们还将实验结果从[10]的 N0.015N^{0.015}N0.015 和[6]的 N0.029N^{0.029}N0.029 改进到了在3对指数时的 N0.035N^{0.035}N0.035。 定理1. 设 (e1,e2,…,en)(e_1, e_2, \\ldots , e_n)(e1​,e2​,…,en​) 是 nnn 个带有共同模 N=pqN= pqN=pq 的 CRT-RSA 加密指数，其中 n≥3n ≥ 3n≥3 且 e1,e2,…,ene_1, e_2, \\ldots , e_ne1​,e2​,…,en​ 的位长度大致与 NNN 相同。考虑到 dpi,dqi≤Nδd_{p_i}, d_{q_i} \\leq N^\\deltadpi​​,dqi​​≤Nδ（i=1,2,…,ni = 1, 2, \\ldots , ni=1,2,…,n）为相应的解密指数。然后根据假设1，在 δ&lt;2n−38n+2\\delta &lt; \\frac{2n - 3}{8n + 2} δ&lt;8n+22n−3​ 时，可以在多项式时间内分解 NNN。 证明. 对于一对密钥 (el,dpl,dql)(e_l, d_{pl}, d_{ql})(el​,dpl​,dql​)，我们有 eldpl−1≡kpl(p−1)eldpl−1≡kql(q−1)e_{l}d_{pl} - 1 \\equiv k_{pl}(p - 1)\\\\ e_{l}d_{pl} - 1 \\equiv k_{ql}(q - 1) el​dpl​−1≡kpl​(p−1)el​dpl​−1≡kql​(q−1) 其中 kplk_{pl}kpl​ 和 kqlk_{ql}kql​ 是一些整数。 此外，通过将这两个方程相乘，我们有 el2dpldql−el(dpl+dql)+1=kplkql(N−s)e^2_ld_{pl}d_{ql} - e_l(d_{pl} + d_{ql}) + 1 = k_{pl}k_{ql}(N - s) el2​dpl​dql​−el​(dpl​+dql​)+1=kpl​kql​(N−s) 其中 s=p+q−1s = p + q - 1s=p+q−1。 那么 (kplkql,s,dpl+dql)(k_{pl}k_{ql}, s, d_{pl} + d_{ql})(kpl​kql​,s,dpl​+dql​) 是 fl(xl,y,zl)=xl(N−y)+elzl−1(model2)f_l(x_l, y, z_l) = x_l(N - y) + e_lz_l - 1 \\pmod{e^2_l} fl​(xl​,y,zl​)=xl​(N−y)+el​zl​−1(model2​) 的一个解。 此外，考虑 nnn 个模多项式 \\begin{equation} f_l(x_l, y, z_l) = x_l(N - y) + e_lz_l - 1 \\pmod{e^{2l}} \\end{equation} 其中 l=1,…,nl = 1, \\ldots , nl=1,…,n。 这些多项式有一个公共的根 (x1,…,xn,y,z1,…,zn)=(kp1kq1,…,kpnkqn,s,dp1+dq1,…,dpn+dqn)(x_1, \\ldots , x_n, y, z_1, \\ldots , z_n) = (k_{p_1}k_{q_1}, \\ldots , k_{p_n}k_{q_n}, s, d_{p_1} + d_{q_1}, \\ldots , d_{p_n} + d_{q_n})(x1​,…,xn​,y,z1​,…,zn​)=(kp1​​kq1​​,…,kpn​​kqn​​,s,dp1​​+dq1​​,…,dpn​​+dqn​​) ，其系数的值可以大致限定为kplkql≃Xl=N1+2δk_{p_l}k_{q_l} \\simeq X_l = N^{1 + 2\\delta}kpl​​kql​​≃Xl​=N1+2δ, s≃Y=N1/2s \\simeq Y = N^{1/2}s≃Y=N1/2，和 dpl+dql≃Nδ=Zd_{pl} + d_{ql} \\simeq N^\\delta = Zdpl​+dql​≃Nδ=Z，其中 l=1,…,nl = 1, \\ldots , nl=1,…,n。 为了解决模多项式 fl(xl,y,zl)=0(model2)f_l(x_l, y, z_l) = 0 \\pmod{e^2_l}fl​(xl​,y,zl​)=0(model2​) 的所需解，其中 l=1,…,nl = 1, \\ldots , nl=1,…,n，基于 Aono 的思想[1]，我们首先选择了以下一组多项式来解决每个单独的方程。 Sl={xlilzljlflkl(xl,y,zl)(el2)m−kl ∣ 0≤kl≤m,0≤il≤m−kl,0≤jl≤m−il−kl}S_l = \\{ x_l^{i_l} z_l^{j_l} f_l^{k_l} (x_l, y, z_l) (e^2_l)^{m - k_l} \\, | \\, 0 \\leq k_l \\leq m, 0 \\leq i_l \\leq m - k_l, 0 \\leq j_l \\leq m - i_l - k_l \\} Sl​={xlil​​zljl​​flkl​​(xl​,y,zl​)(el2​)m−kl​∣0≤kl​≤m,0≤il​≤m−kl​,0≤jl​≤m−il​−kl​} 其中 l=1,…,nl = 1, \\ldots , nl=1,…,n ，并且 mmm 是正整数。 每次(1)中对应方程的选择都会生成一个三角形基矩阵。同样地，对于每个 l=1,2,…,nl = 1, 2, \\ldots , nl=1,2,…,n，我们可以分别构造一个三角形矩阵。基于 Minkowski 基于格构造的求和技术，这 nnn 个的格与 nnn 个三角形矩阵对应，它们可以共同组合成一个新的格 L′\\mathcal{L}&#x27;L′，其基矩阵由和有相同根的多项式是模 (e12,…,en2)m(e^2_1, \\ldots , e^2_n)^m(e12​,…,en2​)m 的解。由于每个基矩阵都是三角形的，组合的格也是三角形的。组合的基矩阵的对角线条目为 X1i1⋯XninYkZ1j1⋯Znjn(e12)m−min⁡(i1,k)⋯(en2)m−min⁡(in,k)X^{i_1}_1 \\cdots X^{i_n}_n Y^k Z^{j_1}_1 \\cdots Z^{j_n}_n (e^2_1)^{m - \\min(i_1,k)} \\cdots (e^2_n)^{m - \\min(i_n,k)} X1i1​​⋯Xnin​​YkZ1j1​​⋯Znjn​​(e12​)m−min(i1​,k)⋯(en2​)m−min(in​,k) 其中 \\begin{align*} &amp;0 \\leq i_1, \\ldots , i_n \\leq m, \\\\ &amp;0 \\leq k \\leq i_1 + i_2 + \\cdots + i_n, \\\\ &amp;0 \\leq j_1 \\leq i_1, \\ldots , 0 \\leq j_n \\leq i_n。 \\end{align*} 然后，格的行列式可以计算如下， det⁡(L′)=∏i1=0m⋯∏in=0m∏k=0i1+⋯+in∏j1=0m−i1⋯∏jn=0m−in(X1i1⋯XninYkZ1j1⋯Znjn(e21)m−min⁡(i1,k)⋯(en2)m−min⁡(in,k))=X1Sx1⋯XnSxnYSyZ1Sz1⋯ZnSzn(e12)Se1⋯(en2)Sen\\begin{aligned} \\det({\\mathcal{L}}&#x27;) &amp;=\\prod_{i_1=0}^{m} \\cdots \\prod_{i_n=0}^{m} \\prod_{k=0}^{i_1 + \\cdots + i_n} \\prod_{j_1=0}^{m-i_1} \\cdots \\prod_{j_n=0}^{m-i_n}\\left( X_1^{i_{1}} \\cdots X^{i_n}_n Y^k Z^{j_1}_1 \\cdots Z^{j_n}_n (e^{2_1})^{m - \\min(i_1,k)} \\cdots (e^2_n)^{m - \\min(i_n,k)} \\right)\\\\ &amp;= X^1 S^{x_1} \\cdots X_n^{S_{x_n}} Y^{S_y }Z^{S_{z_1}}_1 \\cdots Z_n^{S_{z_n}} (e^2_1)^{S_{e_1}} \\cdots (e^2_n)^{S_{e_n}} \\end{aligned}det(L′)​=i1​=0∏m​⋯in​=0∏m​k=0∏i1​+⋯+in​​j1​=0∏m−i1​​⋯jn​=0∏m−in​​(X1i1​​⋯Xnin​​YkZ1j1​​⋯Znjn​​(e21​)m−min(i1​,k)⋯(en2​)m−min(in​,k))=X1Sx1​⋯XnSxn​​​YSy​Z1Sz1​​​⋯ZnSzn​​​(e12​)Se1​​⋯(en2​)Sen​​​ 其中 \\begin{align*} S_{x_1} + S_{x_2} + \\cdots + S_{x_n} = \\left( \\frac{n^2}{18} + \\frac{n}{36} \\right) \\frac{m^{2n+2}} {2^{n-1} }+ o(m^{2n+2})\\\\ S_y = \\left( \\frac{n^2}{36} + \\frac{n}{72} \\right) \\frac{m^{2n+2}} {2^{n-1}} + o(m^{2n+2})\\\\ S_{z_1} + S_{z_2} + \\cdots + S_{z_n} = \\left( \\frac{n^2}{18} - \\frac{n}{72} \\right) \\frac{m^{2n+2}}{ 2^{n-1} }+ o(m^{2n+2})\\\\ S_{e_1} + S_{e_2} + \\cdots + S_{e_n} = \\left( \\frac{n^2}{9} - \\frac{n}{72} \\right) \\frac{m^{2n+2}}{ 2^{n-1}} + o(m^{2n+2}) \\end{align*} 另一方面，维数为 dim(L′)=∑i1=0m⋯∑in=0m∑k=0i1+⋯+in∑j1=0m−i1⋯∑jn=0m−in1=n6⋅2n−1m2n+1+o(m2n+1)\\text{dim}({\\mathcal{L}}&#x27;) = \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum_{k=0}^{i_1 + \\cdots + i_n} \\sum_{j_1=0}^{m-i_1} \\cdots \\sum_{j_n=0}^{m-i_n} 1 = \\frac{n}{6 \\cdot 2^{n-1}} m^{2n+1} + o(m^{2n+1}) dim(L′)=i1​=0∑m​⋯in​=0∑m​k=0∑i1​+⋯+in​​j1​=0∑m−i1​​⋯jn​=0∑m−in​​1=6⋅2n−1n​m2n+1+o(m2n+1) 通过引用引理1和引理2，我们可以得到整数方程，当 \\begin{equation} \\det({\\mathcal{L}}&#039;) ^ \\frac{1}{\\text{dim}({\\mathcal{L}}&#039;)} &lt; (e^2_1\\cdots e^2_n)^m \\end{equation} 忽略 mmm 的低阶项并将 Xl=N1+2δX_l = N^{1+2\\delta}Xl​=N1+2δ，Y=N12Y = N^{\\frac{1}{2}}Y=N21​，Zl=NδZ_l = N^{\\delta}Zl​=Nδ，和 e2l≃N2e^{2_l} \\simeq N^2e2l​≃N2 代入上述不等式(2)中对于l=1,…,nl = 1, \\ldots , nl=1,…,n，必要条件可以写作 (1+2δ)(n218+n36)+12(n236+n72)+δ(n218−n72)+2(n29+n72)≤n23(1 + 2\\delta)\\left(\\frac{n^2}{18} + \\frac{n}{36}\\right) + \\frac{1}{2}\\left(\\frac{n^2}{36} + \\frac{n}{72}\\right) + \\delta\\left(\\frac{n^2}{18} - \\frac{n}{72}\\right) + 2\\left(\\frac{n^2}{9} + \\frac{n}{72}\\right) \\leq \\frac{n^2}{3} (1+2δ)(18n2​+36n​)+21​(36n2​+72n​)+δ(18n2​−72n​)+2(9n2​+72n​)≤3n2​ 即， δ&lt;2n−38n+2\\delta &lt; \\frac{2n - 3}{8n + 2} δ&lt;8n+22n−3​ 然后我们得到了 2n+12n + 12n+1 个多项式，它们共享根 (x1,…,xn,y,z1,…,zn)(x_1, \\ldots , x_n, y, z_1, \\ldots , z_n)(x1​,…,xn​,y,z1​,…,zn​)。根据假设1，我们可以从这些多项式中找到 x1,…,xn,y,z1,…,znx_1, \\ldots , x_n, y, z_1, \\ldots , z_nx1​,…,xn​,y,z1​,…,zn​。这证明了定理1的证明。 此外，除了通过 Minkowski 求和格构造来组合多项式 eldpl=kpl(p−1)+1e_ld_{pl} = k_{pl}(p-1)+1el​dpl​=kpl​(p−1)+1 ，对于 l=1,…,nl = 1, \\ldots , nl=1,…,n，我们还引入了一个附加变量 qqq 来减小我们格的行列式，最终改进了定理1的界限。 更具体地说，我们首先通过利用 Minkowski 求和格构造来组合多项式 fl(xl,y)=xl(y−1)+1 (model)f_l(x_l, y) = x_l(y - 1) + 1 \\ \\pmod {e_l}fl​(xl​,y)=xl​(y−1)+1 (model​) ，对于 l=1,…,nl = 1, \\ldots , nl=1,…,n 。然后，基于观察到格中出现的单项式，我们发现变量 yyy 的所需根 ppp 是模数 NNN 的一个因子。因此，为了减小我们构造的格的行列式，我们可以引入一个对应 qqq 的新变量 zzz。由于 pq=Npq = Npq=N，我们可以用 NNN 替换 yzyzyz，然后通过乘以 NNN 模 e1⋯ene_1 \\cdots e_ne1​⋯en​ 的倒数。总之，我们可以得到以下定理。 定理2. 设 (e1,e2,…,en)(e_1, e_2, \\ldots , e_n)(e1​,e2​,…,en​) 为 nnn 个 CRT-RSA 加密指数，共用模 N=pqN= pqN=pq，其中 n≥2n \\geq 2n≥2，且 e1,e2,…,ene_1, e_2, \\ldots , e_ne1​,e2​,…,en​ 的位数与 NNN 大致相同。考虑到对应的解密指数为 dpld_{p_l}dpl​​、dqld_{q_l}dql​​（l=1,2,…,nl = 1, 2, \\ldots , nl=1,2,…,n）。假设对于 l=1,2,…,nl = 1, 2, \\ldots , nl=1,2,…,n，有 dpl&lt;Nδd_{p_l} &lt; N^\\deltadpl​​&lt;Nδ ，那么在假设1下，当 δ&lt;9n−1424n+8\\delta &lt; \\frac{9n - 14}{24n + 8} δ&lt;24n+89n−14​ 时，可以在多项式时间内分解NNN。 证明. 对于每对密钥 (el,dpl,dql)(e_l, d_{p_l}, d_{q_l})(el​,dpl​​,dql​​) ，我们有 eldpl=kpl(p−1)+1e_ld_{p_l} = k_{p_l}(p - 1) + 1 el​dpl​​=kpl​​(p−1)+1 其中 kplk_{p_l}kpl​​ 是整数。 因此，(kpl,p)(k_{p_l}, p)(kpl​​,p) 是方程 fl(xl,y)=xl(y−1)+1 (model)f_l(x_l, y) = x_l(y - 1) + 1 \\ \\pmod {e_l} fl​(xl​,y)=xl​(y−1)+1 (model​) 的解。 考虑 nnn 个模多项式 fl(xl,y)=xl(y−1)+1 (model)f_l(x_l, y) = x_l(y - 1) + 1 \\ \\pmod {e_l} fl​(xl​,y)=xl​(y−1)+1 (model​) 其中 l=1,…,nl = 1, \\ldots , nl=1,…,n。 显然，这些多项式有共同的根 (x1,…,xn,y)=(kp1,…,kpn,p)(x_1, \\ldots , x_n, y) = (k_{p_1}, \\ldots , k_{p_n}, p)(x1​,…,xn​,y)=(kp1​​,…,kpn​​,p)，其系数的大小可以粗略确定为 kpl≃Xl=N12+δk_{p_l} \\simeq X_l = N^{\\frac{1}{2} + \\delta}kpl​​≃Xl​=N21​+δ （对 l=1,…,nl = 1, \\ldots , nl=1,…,n）和 p≃Y=N12p \\simeq Y = N^\\frac{1}{2}p≃Y=N21​。 为了求解所需解，我们首先选择了以下一组多项式来解决每个单一的模方程， Sl={xlilflkl(xl,y)(el)m−kl ∣ 0≤kl≤m,0≤il≤m−kl}S_l = \\{ x^{i_l}_{l} f^{k_l}_{l} (x_l, y)(e_l)^{m-k_l} \\ | \\ 0 \\leq k_l \\leq m, 0 \\leq i_l \\leq m - k_l \\} Sl​={xlil​​flkl​​(xl​,y)(el​)m−kl​ ∣ 0≤kl​≤m,0≤il​≤m−kl​} 其中 l=1,…,nl = 1, \\ldots , nl=1,…,n，mmm 是正整数。 每个选择都生成一个三角基矩阵。然后，对于 l=1,…,nl = 1, \\ldots , nl=1,…,n，我们分别构造一个三角矩阵。我们用与模方程的解的根相同的多项式构造了基础矩阵，模 (e1⋯en)m(e_1 \\cdots e_n)m(e1​⋯en​)m。通过将这些基于 Minkowski 和的格构造的 nnn 个格子结合起来，得到的与组合格 \\mathcal{L}^&#039;_1 X1i1⋯XninYk(e12)m−min⁡(i1,k)⋯enm−min⁡(in,k)X^{i_1}_1 \\cdots X^{i_n}_n Y^k (e^2_1)^{m - \\min(i_1,k)} \\cdots e_n^{m - \\min(i_n,k)} X1i1​​⋯Xnin​​Yk(e12​)m−min(i1​,k)⋯enm−min(in​,k)​ ， 其中 0≤i1,⋯ ,in≤m0 \\leq i_1, \\cdots , i_n \\leq m0≤i1​,⋯,in​≤m，0≤k≤i1+i2+⋯+in0 \\leq k \\leq i_1 + i_2 + \\cdots + i_n0≤k≤i1​+i2​+⋯+in​ 此外，注意到所需的小解包含质因数 ppp，这是模 N=pqN= pqN=pq 的因子。然后，我们引入一个新变量 zzz 作为另一个质因数 qqq，并将与 \\mathcal{L}^&#039;_1 中每个行向量对应的多项式乘以某个待优化的 sss 的幂 zsz^szs。然后，我们用 NNN 替换每个单项式 yzyzyz 的出现，因为 N=pqN = pqN=pq。因此，与未更改的多项式相比， 每个单项式 x1i1⋯xninykzsx_1^{i_1} \\cdots x_n^{i_n} y^k z^sx1i1​​⋯xnin​​ykzs 且 k≥sk \\geq sk≥s， 其系数 ai1,⋅⋅⋅,in,ka_{i_1,··· ,i_n,k}ai1​,⋅⋅⋅,in​,k​ 被转换为单项式 x1i1⋯xninyk−sx_1^{i_1} \\cdots x_n^{i_n} y^{k-s}x1i1​​⋯xnin​​yk−s 且系数 ai1,⋅⋅⋅,in,kNsa_{i_1,··· ,i_n,k}N^sai1​,⋅⋅⋅,in​,k​Ns。 类似地，当 k&lt;sk &lt; sk&lt;s 时，系数 ai1,⋅⋅⋅,in,ka_{i_1,··· ,i_n,k}ai1​,⋅⋅⋅,in​,k​ 的单项式 x1i1⋯xninykzsx_1^{i_1} \\cdots x_n^{i_n} y^k z^sx1i1​​⋯xnin​​ykzs 且 k≥sk \\geq sk≥s 被转换为单项式 x1i1⋯xninzs−kx_1^{i_1} \\cdots x_n^{i_n} z^{s-k}x1i1​​⋯xnin​​zs−k 其系数为 ai1,⋅⋅⋅,in,kNka_{i_1,··· ,i_n,k}N^kai1​,⋅⋅⋅,in​,k​Nk。 设 Z=N12Z = N^\\frac{1}{2}Z=N21​ 为未知变量 zzz 的上界。 为了使格的行列式尽可能小，我们尝试消除对角线条目中, NsN^sNs 和 NkN^kNk 的因子。由于 (N,e1⋯en)=1(N, e_1 \\cdots e_n) = 1(N,e1​⋯en​)=1，我们只需要将相应的多项式与 NsN^sNs 或 NkN^kNk 模 (e1⋯en)m(e_1 \\cdots e_n)^m(e1​⋯en​)m 的倒数相乘。 然后，格的行列式可以计算如下， det(L1′)=X1Sx1⋯XnSxnYSyZ1Sz1⋯enSen\\text{det}(\\mathcal{L}^{\\prime}_1) = X_1^{S_{x_1}} \\cdots X_n^{S_{x_n}} Y^{S_y} Z_1^{S_{z_1}} \\cdots e_n^{S_{e_n}} det(L1′​)=X1Sx1​​​⋯XnSxn​​​YSy​Z1Sz1​​​⋯enSen​​​ 其中 Sx1+Sx2+⋯+Sxn=∑i1=0m⋯∑in=0m∑k=0i1+⋯+in(i1+⋯+in),Sy=∑i1=0m⋯∑in=0m∑k=si1+⋯+in(k−s),Sz=∑i1=0m⋯∑in=0m∑k=0s−1(s−k),Se1+Se2+⋯+Sen=∑i1=0m⋯∑in=0m∑k=0i1+⋯+in(nm−min⁡(i1,k)−⋯−min⁡(in,k))\\begin{aligned} S_{x_1} + S_{x_2} + \\cdots + S_{x_n} &amp;= \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum_{k=0}^{i_1 + \\cdots + i_n} (i_1 + \\cdots + i_n),\\\\ S_y &amp;= \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum_{k=s}^{i_1 + \\cdots + i_n} (k - s),\\\\ S_z &amp;= \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum_{k=0}^{s-1} ( s-k),\\\\ S_{e_1} + S_{e_2} + \\cdots + S_{e_n}&amp;= \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum^{i_1 + \\cdots + i_n}_{k=0}(nm - \\min(i_1, k) - \\cdots - \\min(i_n, k)) \\end{aligned}Sx1​​+Sx2​​+⋯+Sxn​​Sy​Sz​Se1​​+Se2​​+⋯+Sen​​​=i1​=0∑m​⋯in​=0∑m​k=0∑i1​+⋯+in​​(i1​+⋯+in​),=i1​=0∑m​⋯in​=0∑m​k=s∑i1​+⋯+in​​(k−s),=i1​=0∑m​⋯in​=0∑m​k=0∑s−1​(s−k),=i1​=0∑m​⋯in​=0∑m​k=0∑i1​+⋯+in​​(nm−min(i1​,k)−⋯−min(in​,k))​ 由于下式对于任意 0≤a,b≤n0 \\leq a, b \\leq n0≤a,b≤n 成立 ∑i1=0m⋯∑in=0miaib={13mn+2+o(mn+2),(a=b),14mn+2+o(mn+2),(a≠b),\\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} i_a i_b = \\begin{cases} \\frac{1}{3}m^{n+2} + o(m^{n+2}), &amp; (a = b), \\\\ \\frac{1}{4}m^{n+2} + o(m^{n+2}), &amp; (a \\neq b), \\end{cases}i1​=0∑m​⋯in​=0∑m​ia​ib​={31​mn+2+o(mn+2),41​mn+2+o(mn+2),​(a=b),(a=b),​ 我们有 Sx1+Sx2+⋯+Sxn=(n24+n12)mn+2+o(mn+2),Sy=(σ2n22−σn22+n28+n24)mn+2+o(mn+2),Sz=(σ2n22)mn+2+o(mn+2),Se1+Se2+⋯+Sen=(n24+n12)mn+2+o(mn+2)\\begin{aligned} S_{x_1} + S_{x_2} + \\cdots + S_{x_n} &amp;=(\\frac{n^2} {4} + \\frac{n}{12})m^{n+2} + o(m^{n+2}),\\\\ S_y &amp;= (\\frac{\\sigma^2 n^2} {2} - \\frac{\\sigma n^2} {2} + \\frac{n^2}{8} + \\frac{n}{24})m^{n+2} + o(m^{n+2}),\\\\ S_z &amp;= (\\frac{\\sigma^2 n^2 }{2})m^{n+2} + o(m^{n+2}),\\\\ S_{e_1} + S_{e_2} + \\cdots + S_{e_n}&amp;= (\\frac{n^2 }{4} + \\frac{n}{12})m^{n+2} + o(m^{n+2}) \\end{aligned}Sx1​​+Sx2​​+⋯+Sxn​​Sy​Sz​Se1​​+Se2​​+⋯+Sen​​​=(4n2​+12n​)mn+2+o(mn+2),=(2σ2n2​−2σn2​+8n2​+24n​)mn+2+o(mn+2),=(2σ2n2​)mn+2+o(mn+2),=(4n2​+12n​)mn+2+o(mn+2)​ 其中 s=σnms = \\sigma nms=σnm 且 0≤σ&lt;10 \\leq \\sigma &lt; 10≤σ&lt;1 另一方面，维数为 dim(L′)=∑i1=0m⋯∑in=0m∑k=0i1+⋯+in∑j1=0m−i1⋯∑jn=0m−in1=n6⋅2n−1m2n+1+o(m2n+1)\\text{dim}({\\mathcal{L}}&#x27;) = \\sum_{i_1=0}^{m} \\cdots \\sum_{i_n=0}^{m} \\sum_{k=0}^{i_1 + \\cdots + i_n} \\sum_{j_1=0}^{m-i_1} \\cdots \\sum_{j_n=0}^{m-i_n} 1 = \\frac{n}{6 \\cdot 2^{n-1}} m^{2n+1} + o(m^{2n+1}) dim(L′)=i1​=0∑m​⋯in​=0∑m​k=0∑i1​+⋯+in​​j1​=0∑m−i1​​⋯jn​=0∑m−in​​1=6⋅2n−1n​m2n+1+o(m2n+1) 计算细节请参考附录。 通过引用引理1和引理2，我们可以得到整数方程，当 \\begin{equation} \\det({\\mathcal{L}}&#039;) ^ \\frac{1}{\\text{dim}({\\mathcal{L}}&#039;)} &lt; (e_1\\cdots e_n)^m \\end{equation} 忽略mmm的低阶项并将Xl=N1+2δX_l = N^{1+2\\delta}Xl​=N1+2δ，Y=N12Y = N^{\\frac{1}{2}}Y=N21​，Z=N12Z = N^{\\frac{1}{2}}Z=N21​，和 el≃N{e_l} \\simeq Nel​≃N 代入上述不等式(3)中对于l=1,…,nl = 1, \\ldots , nl=1,…,n，必要条件可以写作 (1+δ)(n24+n12)+12(σ2n22−σn22+n28+n24)+12(σ2n22)+(n24+n12)≤n22(1 + \\delta)\\left(\\frac{n^2}{4} + \\frac{n}{12}\\right) + \\frac{1}{2}\\left(\\frac{\\sigma^2n^2}{2} - \\frac{\\sigma n^2}{2}+\\frac{n^2}{8}+\\frac{n}{24}\\right) + \\frac{1}{2}(\\frac{\\sigma^2 n^2 }{2}) + (\\frac{n^2 }{4} + \\frac{n}{12}) \\leq \\frac{n^2 }{2} (1+δ)(4n2​+12n​)+21​(2σ2n2​−2σn2​+8n2​+24n​)+21​(2σ2n2​)+(4n2​+12n​)≤2n2​ 通过选择 δ=14\\delta=\\frac{1}{4}δ=41​，我们最终得到 δ\\deltaδ 的边界 δ&lt;9n−1424n+8\\delta &lt; \\frac{9n - 14}{24n + 8} δ&lt;24n+89n−14​ 然后在假设 1 下，可以在多项式时间内对 NNN 进行因式分解。至此结束定理2的证明。 我们的结果优于文献中先前的工作的原因基于以下两点观察。首先，我们可以利用 Minkowski 和格构造将 nnn 个多项式组合起来。其次，从 N=pqN = pqN=pq 的知识出发，我们可以通过引入某些因子 zsz^szs 到每个多项式中来优化格的行列式，其中 zzz 是对应于 qqq 的新变量，sss 是将在计算过程中会被优化的整数。 实验结果。需要注意的是，在定理2的计算中，我们假设 mmm 趋向于无穷大。因此，我们的结果是一个渐近界限，因为我们忽略了 mmm 的低阶项。如果 mmm 和 nnn 是固定的，满足条件(3)的最大 δ\\deltaδ 可以很容易地计算得出。在表3中，对于每个固定的 mmm 和 nnn，我们列出了满足式(3)的最大 δ\\deltaδ 以及格的维数。列中限制值表示渐近界限。 表3. 固定 mmm 时小 δ\\deltaδ 的理论界限和格的维数。 我们在一台配备 Intel(R) Core(TM) Duo CPU（2.53 GHz，1.9 GB RAM， Windows 7）的个人电脑上，使用 Magma 2.11计算机代数系统[3]实现了实验程序，并进行了 L3L^3L3 算法[14]。实验结果如表4所示。 表4. 实验结果。 在实验中，我们成功地在实践中分解了共同模 NNN，当存在三个解密指数且它们都小于 N0.035N^{0.035}N0.035 时。对于这个给定的问题，Jochemsz 和 May[10]成功地分解了具有一个小解密指数的 NNN，其界限为 N0.015N^{0.015}N0.015，后来通过利用 Herrmann 和 May[6]引入的未展开线性化技术，该界限已经提高到了 N0.029N^{0.029}N0.029。换句话说，我们通过使用更多具有共同模的解密指数，改进了理论和实验界限。 需要注意的是，在实验中，我们总是找到许多多项式方程在整数域上共享所需的解。此外，我们还有另一个方程 yz=Nyz = Nyz=N。然后通过计算这些多项式的 Gröbner 基础，我们可以在不到两个小时内成功解出所需的解。 在我们进行的所有验证我们提出的攻击的实验中，我们确实通过使用 Gröbner 基础技术成功地收集了根，并且没有实验结果与假设1相矛盾。然而，另一方面，证明或证实其有效性似乎非常困难。 4. 多重加密和解密指数攻击：Takagi变种RSA 定理3. 设 (e1,e2,…,en)(e_1, e_2, \\ldots , e_n)(e1​,e2​,…,en​) 为 Takagi 变种 RSA 的 nnn 个加密指数，共用模 N=prqN=p^rqN=prq。考虑到 d1,d2,⋯ ,dnd_1, d_2, \\cdots , d_nd1​,d2​,⋯,dn​ 是相应的解密指数。那么在假设1下，当 δ&lt;(r−1)(r+1)n+1n\\delta &lt; \\frac{(r - 1)}{(r + 1)} ^ \\frac{n+1}{n} δ&lt;(r+1)(r−1)​nn+1​ 时，可以在多项式时间内分解 NNN，其中 dl≤Nδd_l \\leq N^\\deltadl​≤Nδ，对于 l=1,…,nl = 1, \\ldots , nl=1,…,n。 证明. 对于一个模 N=prqN=p^rqN=prq，存在 nnn 个加密和解密指数 (el,dl)(e_l, d_l)(el​,dl​)，因此，我们有 e1d1=k1pr−1(p−1)(q−1)+1,e2d2=k2pr−1(p−1)(q−1)+1,⋯endn=knpr−1(p−1)(q−1)+1,\\begin{aligned} &amp;e_1 d_1 = k_1 p^{r-1} (p - 1)(q - 1) + 1,\\\\ &amp;e_2 d_2 = k_2 p^{r-1} (p - 1)(q - 1) + 1,\\\\ &amp;\\cdots\\\\ &amp;e_n d_n = k_n p^{r-1} (p - 1)(q - 1) + 1,\\\\ \\end{aligned}​e1​d1​=k1​pr−1(p−1)(q−1)+1,e2​d2​=k2​pr−1(p−1)(q−1)+1,⋯en​dn​=kn​pr−1(p−1)(q−1)+1,​ 因此，对于未知的 (d1,⋯ ,dn)(d_1, \\cdots , d_n)(d1​,⋯,dn​)，我们有以下模方程： e1d1=k1pr−1(p−1)(q−1)+1,e2d2=k2pr−1(p−1)(q−1)+1,⋯endn=knpr−1(p−1)(q−1)+1,\\begin{aligned} &amp;e_1 d_1 = k_1 p^{r-1} (p - 1)(q - 1) + 1,\\\\ &amp;e_2 d_2 = k_2 p^{r-1} (p - 1)(q - 1) + 1,\\\\ &amp;\\cdots\\\\ &amp;e_n d_n = k_n p^{r-1} (p - 1)(q - 1) + 1,\\\\ \\end{aligned}​e1​d1​=k1​pr−1(p−1)(q−1)+1,e2​d2​=k2​pr−1(p−1)(q−1)+1,⋯en​dn​=kn​pr−1(p−1)(q−1)+1,​ 正如所示，(d1,d2,⋯ ,dn)(d_1, d_2, \\cdots , d_n)(d1​,d2​,⋯,dn​) 是以未知除数为模的联立模单变量线性方程的根，并且其大小受到限制，即 dl≤Nδd_l \\leq N^\\deltadl​≤Nδ，对于 l=1,…,nl = 1, \\ldots , nl=1,…,n。 利用[4,22]中的技术，可以证明如果 δ&lt;(r−1)(r+1)(n+1)n\\delta &lt; \\frac{(r - 1)}{(r + 1)} ^ \\frac{(n+1)}{n}δ&lt;(r+1)(r−1)​n(n+1)​ 在假设1下，这些联立模线性方程可以被解，这意味着 (d1,⋯ ,dn)(d_1, \\cdots , d_n)(d1​,⋯,dn​) 可以被恢复。然后可以通过计算公因子轻松地分解 NNN。 实验结果. 我们在 Magma 2.11中实现了实验程序。在所有实验中，我们成功地求解了所需的解 (d1,d2,⋯ ,dn)(d_1, d_2, \\cdots , d_n)(d1​,d2​,⋯,dn​)。同样地，没有实验结果与假设1相矛盾，见表5。 表5. 使用多个解密指数因式分解 NNN。 需要注意的是，前述的定理3可以适用于任意大小的加密指数 (e1,⋯ ,en)(e_1, \\cdots , e_n)(e1​,⋯,en​)。然而，如果存在两个有效的密钥对 (e1,d1)(e_1, d_1)(e1​,d1​) 和 (e2,d2)(e_2, d_2)(e2​,d2​)，其中 e1e_1e1​ 和 e2e_2e2​ 的大小大致与模 NNN 或更大些的值如 NαN^αNα 相同。假设 d1≃d2≃Nδd_1 \\simeq d_2 \\simeq N^\\deltad1​≃d2​≃Nδ，则我们可以给出如下分析。 给定两个方程 e1d1=k1pr−1(p−1)(q−1)+1e_1d_1 = k_1p^{r-1}(p - 1)(q - 1) + 1e1​d1​=k1​pr−1(p−1)(q−1)+1 和 e2d2=k2pr−1(p−1)(q−1)+1e_2d_2 = k_2p^{r-1}(p - 1)(q - 1) + 1e2​d2​=k2​pr−1(p−1)(q−1)+1，我们消除 pr−1(p−1)(q−1)p^{r-1}(p - 1)(q - 1)pr−1(p−1)(q−1) 并得到以下等式， k2(e1d1−1)=k1(e2d2−1)k_2(e_1d_1 - 1) = k_1(e_2d_2 - 1) k2​(e1​d1​−1)=k1​(e2​d2​−1) 这启示我们寻找多项式 \\begin{equation} f(x, y) = e_2x + y (mod e_1) \\end{equation} 的小解。 由于 (d2k1,k2−k1)(d_2k_1, k_2-k_1)(d2​k1​,k2​−k1​) 是 f(x,y)(mode1)f(x, y) \\pmod {e_1}f(x,y)(mode1​) 的根，因此 k1k_1k1​ 的界限可以估计为 Nα+δ−1N^{α+\\delta-1}Nα+δ−1，因此我们定义边界 ∣d2k1∣≃X=Nα+2δ−1|d_2k_1| \\simeq X = N^{α+2\\delta-1}∣d2​k1​∣≃X=Nα+2δ−1 和 ∣k2−k1∣≃Y=Nα+δ−1|k_2 - k_1| \\simeq Y = N^{α+\\delta-1}∣k2​−k1​∣≃Y=Nα+δ−1。对于这个线性模方程，只要 XY&lt;eXY &lt; eXY&lt;e，或者 α+2δ−1+α+δ−1&lt;αα + 2\\delta - 1 + α + \\delta - 1 &lt; αα+2δ−1+α+δ−1&lt;α，我们就可以恢复 (d2k1,k2−k1)(d_2k_1, k_2 - k_1)(d2​k1​,k2​−k1​)。 因此，要从这个基于格的方法中恢复 d2k1d_2k_1d2​k1​ 和 k2−k1k_2 - k_1k2​−k1​，加密和解密指数的大小应满足 α+3δ&lt;2α + 3\\delta &lt; 2 α+3δ&lt;2 其中 α+δ&gt;1α + \\delta &gt; 1α+δ&gt;1。 结论 在本文中，我们提出了基于 Minkowski 和的格构造的一些应用，并对多对 CRT-RSA 模数 NNN 相同的加解密指数对的情况进行了分析。我们展示了当 dpi,dqi≤N2l−38l+2d_{p_{i}},d_{q_{i}}\\le N^{\\frac{2l-3}{8l+2}}dpi​​,dqi​​≤N8l+22l−3​ 或者 dpid_{p_{i}}dpi​​ 和 dqid_{q_{i}}dqi​​ 中的一个小于 N9l−1424l+8N^{\\frac{9l-14}{24l+8}}N24l+89l−14​ 时，可以分解 NNN，其中 i=1,2,⋯ ,li = 1, 2, \\cdots, li=1,2,⋯,l。此外，我们还分析了在模数为 N=prqN = p^rqN=prq 的 Takagi 变种 RSA 中使用多个加密和解密指数的情况。 致谢 作者要感谢匿名审稿人对本文的有益评论和建议。本文的工作得到了中国国家重点基础研究计划（项目编号2013CB834203和2011CB302400）、中国国家自然科学基金（项目编号61472417、61402469、61472416和61272478）、中国科学院战略性先导科技专项（项目编号 XDA06010702和 XDA06010703）以及中国科学院信息安全国家重点实验室的支持。Y. Lu 受到 JST 项目 CREST 的支持。 附录 这里给出计算 SX1,SY,SZ1,Se1S_{X_{1}},S_{Y},S_{Z_{1}},S_{e_{1}}SX1​​,SY​,SZ1​​,Se1​​ 的细节。 设对于任意 0≤a,b≤n0\\leq a,b\\leq n0≤a,b≤n，记 ∑∗\\sum^{*}∑∗ 表示 ∑i1=0m⋯∑in=0m∑j˙1=0m−i1⋯∑jn=0m−in\\sum_{i_{1}=0}^{m}\\dots \\sum_{i_{n}=0}^{m}\\sum_{\\dot j_1=0}^{m-i_1}\\dots\\sum_{j_n=0}^{m-i_n}∑i1​=0m​⋯∑in​=0m​∑j˙​1​=0m−i1​​⋯∑jn​=0m−in​​。我们有 ∑∗iaib={112∗2n−1∗m2n+2+o(m2n+2), (a=b),118∗2n−1∗m2n+2+o(m2n+2), (a≠b),\\stackrel{*}{\\sum}i_{a}i_{b}=\\left\\{ \\begin{array}{l} {\\frac{1}{12*2^{n-1}}*m^{2n+2}+o(m^{2n+2}),\\;(a=b),}\\\\ {\\frac{1}{18*2^{n-1}}*m^{2n+2}+o(m^{2n+2}),\\;(a\\neq b),} \\end{array}\\right.∑∗​ia​ib​={12∗2n−11​∗m2n+2+o(m2n+2),(a=b),18∗2n−11​∗m2n+2+o(m2n+2),(a=b),​ 和 ∑⋆iajb={124∗2n−1∗m2n+2+o(m2n+2), (a=b),118∗2n−1∗m2n+2+o(m2n+2), (a≠b).\\stackrel{\\star}{\\sum}i_{a}j_{b}=\\left \\{\\begin{array}{l} {\\frac{1}{24*2^{n-1}}\\ast m^{2n+2}+o(m^{2n+2}),\\;(a=b),}\\\\ {\\frac{1}{18*2^{n-1}}\\ast m^{2n+2}+o(m^{2n+2}),\\;(a\\neq b).} \\end{array}\\right.∑⋆​ia​jb​={24∗2n−11​∗m2n+2+o(m2n+2),(a=b),18∗2n−11​∗m2n+2+o(m2n+2),(a=b).​ 然后我们得到 ∑∗∑k=0i1+⋯+ini1+⋯+in=(n218+n36)∗m2n+22n−1+o(m2n+2),∑∗∑k=0i1+⋯+inj1+⋯+jn=(n218−n72)∗m2n+22n−1+o(m2n+2),∑∗∑k=0i1+⋯+ink=∑ ∗(i1+⋯+in)22+i1+⋯+in2=(n236+n72)∗m2n+22n−1+o(m2n+2).\\begin{aligned} \\sum^{*}\\sum_{k=0}^{i_{1}+\\cdots+i_{n}}i_{1}+\\cdots+i_{n}&amp;=({\\frac{n^{2}}{18}}+{\\frac{n}{36}})*{\\frac{m^{2n+2}}{2^{n-1}}}+o(m^{2n+2}),\\\\ \\sum^{*}\\sum_{k=0}^{i_{1}+\\dots+i_{n}}j_{1}+\\dots+j_{n}&amp;=({\\frac{n^{2}}{18}}-{\\frac{n}{72}})*{\\frac{m^{2n+2}}{2^{n-1}}}+o(m^{2n+2}),\\\\ \\sum^{*}\\sum_{k=0}^{i_{1}+\\cdots+i_{n}}k&amp;=\\sum_{\\,}^{*}\\frac{(i_{1}+\\cdots+i_{n})^{2}}{2}+\\frac{i_{1}+\\cdots+i_{n}}{2}\\\\ &amp;=\\left(\\frac{n^{2}}{36}+\\frac{n}{72}\\right)*\\frac{m^{2n+2}}{2n-1}+o(m^{2n+2}). \\end{aligned}∑∗​k=0∑i1​+⋯+in​​i1​+⋯+in​∑∗​k=0∑i1​+⋯+in​​j1​+⋯+jn​∑∗​k=0∑i1​+⋯+in​​k​=(18n2​+36n​)∗2n−1m2n+2​+o(m2n+2),=(18n2​−72n​)∗2n−1m2n+2​+o(m2n+2),=∑∗​2(i1​+⋯+in​)2​+2i1​+⋯+in​​=(36n2​+72n​)∗2n−1m2n+2​+o(m2n+2).​ 此外， ∑∗∑k=0i1+⋯+inmin⁡(i1,k)=∑∗(∑k=0i1k+∑k=i1+1i1+⋯+ini1)=∑∗(i1(i1+1)2+i1(i2+⋯+in))=(n18−172)∗m2n+22n−1+o(m2n+2)\\begin{aligned} \\sum^*\\sum_{k=0}^{i_{1}+\\cdots+i_{n}}\\min(i_{1},k)&amp;=\\sum^*(\\sum^{i_1}_{k=0}k+\\sum_{k=i_1+1}^{i_{1}+\\cdots+i_{n}}i_1)\\\\ &amp;=\\sum^*(\\frac{i_1(i_1+1)}{2}+i_1(i_2+\\cdots + i_n))\\\\ &amp;=(\\frac{n}{18}-\\frac{1}{72})*\\frac{m^{2n+2}}{2^{n-1}}+o(m^{2n+2})\\\\ \\end{aligned}∑∗​k=0∑i1​+⋯+in​​min(i1​,k)​=∑∗​(k=0∑i1​​k+k=i1​+1∑i1​+⋯+in​​i1​)=∑∗​(2i1​(i1​+1)​+i1​(i2​+⋯+in​))=(18n​−721​)∗2n−1m2n+2​+o(m2n+2)​ 通过对称，我们有 ∑∗∑k=0i1+⋯+in∗min(i1,k)+⋅⋅⋅+∗min(in,k)=(n218−n72)∗m2n+22n−1+o(m2n+2).\\sum^{\\ast}\\sum_{k=0}^{i_{1}+\\dots+i_{n}}{*{min}}(i_{1},k)+\\cdot\\cdot\\cdot+*{min}(i_{n},k)=(\\frac{n^{2}}{18}-\\frac{n}{72})\\ast\\frac{m^{2n+2}}{2^{n-1}}+o(m^{2n+2}). ∑∗​k=0∑i1​+⋯+in​​∗min(i1​,k)+⋅⋅⋅+∗min(in​,k)=(18n2​−72n​)∗2n−1m2n+2​+o(m2n+2). 格 L′{\\mathcal{L}}^{\\prime}L′ 的维度是 dim(L′)=∑∗∑k=0i1+⋯+in1=n6∗2n−1∗m2n+1+o(m2n+1).\\mathrm{dim}({\\mathcal L}^{\\prime})=\\sum^{*}\\sum_{k=0}^{i_{1}+\\dots+i_{n}}1=\\frac n{6*2^{n-1}}*m^{2n+1}+o(m^{2n+1}). dim(L′)=∑∗​k=0∑i1​+⋯+in​​1=6∗2n−1n​∗m2n+1+o(m2n+1).","categories":[],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"高木变体","slug":"高木变体","permalink":"http://example.com/tags/%E9%AB%98%E6%9C%A8%E5%8F%98%E4%BD%93/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"}]},{"title":"碧蓝航线装备属性浅解","slug":"碧蓝航线装备属性浅解","date":"2024-04-13T10:56:53.000Z","updated":"2024-04-20T19:08:41.569Z","comments":true,"path":"post/20240413185653.html","permalink":"http://example.com/post/20240413185653.html","excerpt":"前言 好复杂啊啊啊啊啊啊啊啊啊","text":"前言 好复杂啊啊啊啊啊啊啊啊啊 写在前面 这篇文章基本是写给我自己看的，不过我依然写清楚一些我早知道的事情，这主要是为了逻辑的连贯。 舰娘游戏的很多名词概念来源于历史但是并不同于历史，必要的情况下，我会使用斜体字表示这句话的内容是纯粹为游戏性服务的。 了解舰船 装备是给舰娘用的，要了解装备我们就必须先了解舰船。 依托于二战历史，游戏中主要的舰船和装备来源是白鹰、皇家、重樱、铁血四国。舰船的种类则可以分为驱逐、巡洋、战列、航母、潜艇。主要的武器类型可以分为舰炮、飞机、鱼雷。 人类发展了各式各样的战舰，但是，无疑没有一种舰艇是可以应对所有局势的。如果我们需要和敌军来一场正面决战，那么可以将所有的战舰排列好向同一个地方轰击，这就是战列舰。为了能多装载大口径炮并承受其巨大的后坐力，战列舰装甲厚、吨位大、航速慢。但是如果只是侦察、护卫、航线巡逻，那么吨位较小、航速更快、火力较弱便宜管够的中小舰船就更合时宜。较小吨位的就是驱逐，稍大一些的则是巡洋，巡洋舰中，根据吨位大小又分为重巡和轻巡。 随着时代的发展，驱逐舰的吨位越来越大，1939年下水的日本驱逐舰雪风号有2066吨，而今天中国055型导弹驱逐舰约11000吨，取代了巡洋的定位。 通常来说，可以认为一个舰队的核心是威力巨大的战列舰和航母，驱逐舰巡洋舰则是护卫。*在碧蓝中，它们被粗略的分为后排和前排，一个舰队至少需要有一个后排和一个前排。*前排的驱逐和巡洋承担侦察护卫攻击等职责，其中，以鱼雷为主要武器的是驱逐。以舰炮为主要武器，吨位更大的是轻巡。而比轻巡还重、火力和装甲更厚的则是重巡。注意，这只是一个简单的划分，事实上还存在战列巡洋舰（介于战列和巡洋之间）、超级巡洋舰（同样介于战列和巡洋之间）、轻型航母等等大量中间地带以及维修舰等特殊舰种。 还需要额外提到的是阵型。最基础是单纵阵，显然这种情况下所有战舰侧舷的火炮鱼雷都可以面向敌人，发挥出最大火力，但过长的整型无疑影响了整个舰队转向的速度。而复纵阵，即排成多个纵阵，缓解了机动性以及先锋舰孤立无援的问题，但是也一定程度干扰了友舰的发射。轮形阵将舰队核心旗舰包裹起来，这样，不仅无论敌方飞机想要在哪个方向攻击主舰，都会面临防空火力威胁，而且舰队转向速度快，躲鱼雷也更方便。了解更多：一战、二战时期海战的各种阵型是如何发挥其作用的？ - 知乎 了解舰船属性 在前面的基础上，进一步的我们可以了解舰船属性： 耐久：即通常所谓的游戏“血量”； 装甲类型：重/中/轻型装甲，厚重的装甲可以更好的减免火炮伤害。通常来说，战列属于重甲；航母，重巡洋舰以及战巡属于中甲；驱逐、潜艇、轻巡属于轻甲。 装填：装填属性影响武器的发射CD，当装填值高于 100 时，舰船发射火炮等的CD会变短。具体来说，假设一个武器本身的CD为 x，那么舰船使用该武器的CD为x′=x×200100+装填值x&#x27;=x\\times \\sqrt{\\frac{200}{100+装填值}}x′=x×100+装填值200​​； 炮击：提高舰炮伤害（通常不是航母类舰船）； 雷击：提高鱼雷伤害（通常是前排舰船）； 机动：增加舰炮的 miss 概率； 命中：提高对敌方的命中概率和暴击概率； 幸运：略微增加机动和命中； 防空：减少来自敌方的飞机伤害并击落敌方飞机； 航速：前排战舰的航速平均值决定了前排的移动速度； 消耗：石油消耗； 反潜/氧气、弹药、狩猎范围：对应潜艇的属性。 了解装备 不同吨位舰种的舰船有不同的装备。主要可以分为舰炮、鱼雷、飞机几类。 舰炮 依据口径，我们可以将舰炮分为小中大型舰炮。小于140mm称之为小型舰炮，140mm到203mm为中型舰炮，更大则属于大型舰炮。舰炮的口径越大，炮装药量和威力也越大（给船的后坐力也越大，小船上安过大的舰炮可甚至可能因此倾覆）。此外，还有游戏不太涉及到的另外两个参数，炮管长度和倍径。炮管越长，火炮受炮管内气体的推动时间越长，速度更快，而且长炮管也让炮弹可以更长、装药量更多，从而提升威力。将炮管长度除以口径，就得到倍径。倍径用斜线后的数值标记。例如游戏中装备“试作型203mmm/55三联装主炮”，就标明其口径为203mm，倍径为55倍。 需要注意的是，受到老牌帝国皇家造船业发达的影响，舰炮的口径往往采用英寸表示，这也造成了在公制单位下舰炮口径都是莫名奇妙的非整数的情形。例如，前面提到的小型舰炮口径小于140mm，其实就是小于5.5英寸，中型舰炮小于203mm，其实就是8英寸，而常见的127mm炮、152mm炮、308mm炮，则分别对应5英寸、6英寸、15英寸等。 如果按炮弹的类型，我们还可以分为通常弹、高爆弹（HE，High-Explosive）、穿甲弹（AP,Armour-piercing）、半穿甲弹。通常弹即没有特别属性的炮弹。高爆弹即高爆炸性，不同于黑火药等低爆炸药，高爆弹瞬间释放大量能量引发冲击波。进而增大敌舰起火几率。*高爆弹命中后，可能引发敌舰上的火灾，造成持续伤害。*穿甲弹则对致力于穿透敌方装甲后再爆炸造成破坏。通过增大装甲厚度和良好的船体设计，可以让从一些角度过来的穿甲弹不能击穿装甲或是发生“跳弹”，进而减弱破坏。另一种情况则是船体装甲太薄，穿甲弹击穿了两面装甲后再发生爆炸，即“过穿”，这也会降低受命中舰的损失。在游戏中，中小型舰炮的穿甲弹可以穿透敌方装甲，命中两个目标，战列舰主炮则可能造成破甲效果，提高敌方受炮击攻击的伤害。 另外两个可能需要加以区分的概念是“联装”和“连装”（其实大部分情况见到的都是联装）。所谓联装即“联合装药”，一个炮塔上有若干个炮口，它们可以一起装药，一起发射，从而有效提升火力密度。而所谓连装即“连续装药”，减少几次中间等待时间。通常来说，主炮都是双联装或三联装的，也有一些四联装的，但没有更高的情况。这是因为舰炮发射的速度极快（超音速），离开炮口时引起巨大的炮口风暴，进而干扰同时发射的其它炮弹。虽然一定程度上可以通过增大炮口间距解决问题，但是这样就会导致炮弹落点分散，反而得不偿失。 此外，舰炮的重要参数还要速度、散布、装填速度等。一门炮装填越快，就越能抢占先机，提高 “DPS”，飞行速度越快，则越容易命中敌人；散布越小，则炮弹落点越集中。于是我们得到舰炮的主要参数如下 伤害：伤害，由于联装，主炮往往是A×BA\\times BA×B的形式，表示有几颗炮弹。 射速：衡量一轮装填的时间。 炮击：提供给舰船的属性加成。 弹药：高爆？穿甲？ 飞行速度 对甲比例：如前所述，敌人装甲厚度不同深刻影响弹药伤害。具体体现为炮弹对轻中重型有不同的对甲系数，越高越好。 索敌范围：最大瞄准距离 索敌角度：最大转角 射程：炮弹落点距离将在该区间 散布角度：发射的炮弹散布在这个角度的扇形区域内 伤害修正比例：强化到+13有时可以提高该值。 适用舰种：如前所述，不同口径的舰炮装载在不同的舰船上。战列舰主炮位显然不会装配127mm的小口径炮，驱逐舰也无法装配356mm的主炮。 通常来说，除了在一定距离内攻击敌方飞机的防空炮，一个战列可以装载一门主炮一门副炮和一门防空炮，战列主炮为大型舰炮，同时装载中小型舰炮为副炮。巡洋搭载一门中小型炮为主炮，此外，一部分巡洋使用一门小型炮为副炮，还有一些轻巡则和驱逐一样，没有副炮而使用鱼雷进攻。至于驱逐，则只有小炮作为主炮，她们的主要攻击手段是鱼雷。 鱼雷 舰载鱼雷。鱼雷是一种威力巨大的、航速极快的炮弹。水面舰载鱼雷（通常由驱逐舰和轻巡发射）发射后，数枚鱼雷呈扇面散开。舰载鱼雷不同于炮弹，必然是存在这个散布角度的。由于鱼雷是自带动力的，因此其口径可以很大，虽然是由小吨位舰发射，但是我们常见的口径却高达533mm。 鱼雷主要可以分为两种，第一种是普通鱼雷，第二种是磁性鱼雷。顾名思义，磁性鱼雷具有磁性，弹药类型属于声导，可以更有效的命中敌人。 除此之外，鱼雷的属性和舰炮查不到，只是其影响的属性变成了雷击。鱼雷的选择并非是发射数量越多越好，一轮攻击打出的伤害越高越好，也受到其它因素的影响。例如四联装533mm磁性鱼雷优于五联装533mm磁性鱼雷。因为其装载冷却更接近20s，利于接受大部分舰娘加成技能的增幅。 飞机 航母作为另一种主力战舰，其功能就是起飞各种飞机。这些飞机主要可以分为三类：战斗机、轰炸机、鱼雷机。 不必多言，战斗机的主要职责是空中狗斗，兼顾对海作战。战斗机可以与敌方飞机进行战斗，从而阻止敌方飞机对我方舰船造成伤害。*此外，有的战斗机还有起飞拦截（迎击射速），当敌方飞机迫近，冷却好后战斗机可以自动地起飞拦截，但是对海输出为0。*而对海作战上，战斗机分为搭载航弹和搭载火箭弹的。航弹没有动力，投射精度低，往往炮弹分散，但是航弹机往往有起飞拦截，火箭弹有动力且速度高，因此炮弹集中精度高，但是没有火箭弹型往往起飞拦截。 毫无疑问，对海输出也是战斗机的重要职责，因此一些不搭载炸弹，没有对海作战能力或者对海作战能力弱的飞机，例如 Me-155A 舰载战斗机几乎不会被使用。 另一个重要的舰载机就是轰炸机，轰炸机的职责就是对海轰炸。轰炸机同样分为搭载航弹和搭载火箭弹的。航弹和火箭弹的区别如前所述。 最后一种重要的舰载机就是鱼雷机，不同于轰炸机，鱼雷机将鱼雷由空中投入海中，然后鱼雷自行向前行驶，和舰载鱼雷一样命中敌舰。鱼雷机投掷鱼雷有两种方式，在不同的地方向统一方向投掷和在同一个地方向不同方向投掷。这就造就两种不同的鱼雷机。前者是平行雷鱼雷机，鱼雷之间相互平行；后者是集束鱼雷机，鱼雷由一个地方向前方散布。不用说，平行雷适合敌人多的情况，集束雷适合对单个敌人打大量伤害。根据历史，赤色中轴阵营重樱铁血的鱼雷机是集束雷，而其它碧蓝航线阵营的则是平行雷。","categories":[],"tags":[{"name":"游戏,","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"碧蓝航线","slug":"碧蓝航线","permalink":"http://example.com/tags/%E7%A2%A7%E8%93%9D%E8%88%AA%E7%BA%BF/"}]},{"title":"了解濒危方言——宁远平话","slug":"了解濒危方言——宁远平话","date":"2024-03-28T19:23:49.000Z","updated":"2024-04-20T19:08:41.566Z","comments":true,"path":"post/20240329032349.html","permalink":"http://example.com/post/20240329032349.html","excerpt":"前言 一个了解湖南宁远平话的简单网站：宁远平话。","text":"前言 一个了解湖南宁远平话的简单网站：宁远平话。 如何使用 初步的学习了解，随心所欲的点击播放按钮即可。 在完成音标的录入后，要更好地使用网站，你可能需要花约 20 分钟对需要使用到的国际音标符号和五度标记法形成认识。特别提醒，国际音标是一套庞杂的系统，只需要对其形成基本的认识即可。 你还可以购买本站音频来源的书籍：商务印书馆“中国濒危语言志”中李永新教授的著作《湖南宁远平话》，其中的信息远多于网站呈现。该书各大购物平台有售，商务印书馆出版，建议零售价 ￥120。 了解宁远 宁远县位于湖南省南部，南岭中段萌渚岭北麓，属永州市管辖。宁远县是一个历史悠久的城市，《史记》记载，舜帝南巡，崩于苍梧之野，葬于江南九嶷，是为零陵。其中九疑即宁远境内九嶷山，零陵则成了永州地区的古称。秦始皇统一六国后，秦朝在此置县，北宋太祖乾德三年，改名宁远，此后宁远之名沿用至今。 宁远并不是一个以文旅著称的旅游城市，然而这里的确有舜帝陵和宁远文庙——我国现存始建年代之早、建筑规模之大仅次于曲阜孔庙的文庙建筑。这里还在唐朝太和二年孕育出湖广地区的第一个状元李郃，以及此后各朝进士共计 84 名。 南岭脚下的湘南地区，群山环绕，交通不便，经济发展受制，但是这样的环境也保留和发展了一批小方言。宁远县有平话，还有土话，毗邻宁远的道县有道县梅花土话（同样收录于“中国濒危语言志”），蓝山县则有蓝山话……这些小方言需要更多的关注。 了解平话 宁远平话不是分布在广西等地更出名的平话，它是一种仅分布于宁远县内的汉语方言。所谓“平话”，大抵可以理解成“平常说的话”或“平民说的话”，与之相对的则是西南官话，即通常所谓的“湖南话”、“四川话”。在常见的方言分类中，宁远平话属于湘南土话中的一种。 随着改革开放和普通话推广，许多宁远人外出务工，他们在外的日常用语自然不会是平话。因此平话的使用人数逐渐减少，另一方面，许多新事物使用平话无法表达和年青人大量从官话或普通话中借词，让平话的词汇特色逐渐减少。如今，平话已经属于一种濒危方言。 认识平话，不仅有助于保护汉语言的多样性，也能让我们透过平话这面镜子，更好地了解汉语在历史上的沿革变迁和脚下的历史。例如，宁远县内有村名为“马脚洞”，如果不理解这里的“洞”实际上在平话中指的是“开阔平地”的意思的话，就无法理解这里实际上是说这块平地形如马脚，而容易误以为这个名字源于附近某个山上的某个山洞。 了解网站 李永新教授著作的《湖南宁远平话》一书中，李永新教授不仅详细地从声韵调、词汇特点、语法等角度剖析了宁远平话，更重要的地是还提供了许多词汇、句子的语音材料。对于普通人来说，这也许是除了“去宁远找一个会说平话的人教”以外，学习平话最简单而直观的方法。 依托于李永新教授在书中提供的语音材料，我做出了这个简单的静态网站：宁远平话。通过它，我们可以更便捷地了解宁远平话，并初步地对平话进行一些学习。 目前音频文件已经录入，但是音标、文本等的录入则还远远不足，因此只能简单的听一下发音。","categories":[],"tags":[{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"},{"name":"语言学","slug":"语言学","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"}]},{"title":"屎山探索之旅——记一次失败的2D物理引擎复刻经历","slug":"屎山探索之旅——记一次失败的2D物理引擎复刻经历","date":"2024-02-01T05:08:39.000Z","updated":"2024-04-20T19:08:41.566Z","comments":true,"path":"post/20240201130839.html","permalink":"http://example.com/post/20240201130839.html","excerpt":"前言 去年大约 11 月份的时候，我在 B 站看到了一个视频。UP 主在视频中展现了一个完全由他自己基于 C++ 实现的 2D 刚体物理引擎。于是出于兴趣和春招需要，我着手去学习修改该项目。不过，今天我决定放弃。","text":"前言 去年大约 11 月份的时候，我在 B 站看到了一个视频。UP 主在视频中展现了一个完全由他自己基于 C++ 实现的 2D 刚体物理引擎。于是出于兴趣和春招需要，我着手去学习修改该项目。不过，今天我决定放弃。 项目介绍 首先，该项目是完全基于C++手搓的，包括 GUI 应用框架、音乐播放模块以及字体显示模块等。在此之上，作者实现了 2D 刚体间的交互模拟程序。由其发布的视频展示了具体效果：C++ 实现 2D 刚体模拟_哔哩哔哩_bilibili，而作者的作品实质上是由Let's Make a Physics Engine - YouTube所启发。 详细来说，这个刚体模拟程序实现了刚体的这些功能：碰撞、连接件、电磁力等，以及刚体本身的拖拽旋转等效果。刚体还细分了矩形、三角、圆等功能。当然，对应的渲染也不能落下。总之，就是一个引擎该有的样子。 那么我为什么要放弃呢？ TT.JMLANG 如果我不说你大概理解不了这个标题的意思，实际上，我想表达的是&quot;Title. Jia mi language&quot;，即“标题是‘加密通话’“的意思。 在物理引擎相关的部分：即存储刚体、碰撞、AABB 包围盒等类的地方，其实结构还相对清晰，毕竟，结合文件名、函数名以及代码，再考虑到实际的算法，也是可以理解的。这也是为什么我如今才选择放弃。但是，这一部分依然有很多让我头大的问题。例如 作者喜欢使用宏定义，甚至可以说到滥用的地步。例如，#define p cur.p ，cur 是一个全局唯一的类，并且在所有需要它做参数传进去的地方，形参都是这个名字。这样就可以省略几个字母并符合人全局唯一的思维的。 但是，不消说，宏定义我们都知道有许多的问题：不能直观找到定义位置、不方便 debug、全局性……其中最重要的就是我难以找到成员定义在哪里，而且也禁止我定位到定义处。想象一下按 F 12 以后跳转到了宏定义的定义处，这对我找出 p 的类型或者其它的东西有什么帮助呢？更糟糕的是，像上面例举的这种宏定义没法消除，因为展开以后 cur.p 中的 p 也该被宏定义展开了。 如果你理解这种感受，那么我们现在再扩展一点：cur.p 以及其它所有宏定义塞在名为 my_def.cpp 和 utils.cpp 的几个文件中，并且这个宏定义互相嵌套，这意味着你只有按照指定的顺序进行修改才能消除这些宏定义。并且不能直接删定义而是用删引用的方式，这样才能保证不会在其它文件出错。 作者喜欢使用缩写，并且这些缩写不一定常规。例如 bgr 是 background 这样的缩写都算普通，更常见的情况是难以猜出其中的含义，例如使用 pra 代表 parameter, 使用 tl 表示 topleft（指左上角的坐标系原点）。这样的缩写配合宏函数则会带来更大的折磨。例如一个宏函数 getv，其含义实际是 get（ValueTo）Vector 作用是从名为 f 文件指针中获取一个 wstring（对的，其实并不是 std::vector）的 sz（size），并读取 sz 个值。而且其中还使用了另一个宏函数来读取值。 使用 struct 而非 class：这意味着所有的成员都是 public 的，不通过查找引用的方式，无法确定一个函数就是有没有被外界访问，也无法确定一个变量有没有被外界访问。 此外还有一些我不太喜欢但是相对没有那么让人痛苦的问题 使用 typedef 而不是 enum class 的方式定义枚举，不够类型安全； 使用更倾向于使用 if-else 而非 switch； 喜欢将多行短代码放到一行使其具有一定长度； 不使用一行仅定义一个成员变量的方式； 不采用大驼峰的方式命名函数； 大括号不换行； 大量隐含的类型转换； 还有一些小问题和架构的问题就不吐槽了（毕竟没太看懂没法下嘴）。 它回报比你要求的更多 仅仅上述问题并没有令我放弃，毕竟正如我前面也说了&quot;在物理引擎相关的部分……其实结构还相对清晰……再考虑到实际的算法，也是可以理解的。&quot;但是，这个项目给东西远远不止是一个物理引擎。他还包括一个应用框架。这个框架中，按钮、面板、字体显示、音乐演奏、还有一个指令面板，都是在上面的问题下写就的，而我对这些部分的理解绝没有物理引擎部分那么多。 更退一步的来说，即使我想要学习和理解这些内容，那么这个框架也是有不足的： 字体和音乐演奏都是自设的格式，难以编辑，也并不通用，不支持通常的字体文件和音乐文件； 面板采用的不是原生 UI，无法调整画框大小； 没有异步加载等功能； 对于作者来说，在这个过程在中可以学到一些创建 GUI 的方式。但是既然这不是我写的，那么是否通过这样的途径去学习理解就很值得打问号了。 总结和收获 总结就是代码规范确实是很重要的东西，因为不遵守代码规范等等原因，这样的一份开源代码对我而言学习成本太高，因此最后我选择了放弃。 代码规范、命名规范、域以及其它的东西……这些看上去很飘渺的东西在这一次学习之旅中以反面例子的形式，给我直观地展现了出来。 当然，另一方面，这也意味着代码规范又没那么重要：这是一个完全不尊重代码规范的野蛮生长的作品，但是它确实能跑。代码规范指导着我们如何写出更好的代码，可不能拘泥于规范，将规范视为圣经、雷池，不敢稍逾一步。前面吐槽了那么多作者写的代码的问题，但是三个月过去，作者又新发了若干视频，我却并没有收获一个可以写在简历上的项目，这就是差距了。 尽管如此，通过阅读项目，我对 2D 物理引擎有关的代码确实更熟悉了，也更了解 cpp 的一些新特性。例如智能指针等等，这些新特性是我在秋招时自学的，但是我并没将其实践起来，通过这个项目，我消除了这种实践上的陌生感。","categories":[],"tags":[{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"物理引擎","slug":"物理引擎","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"},{"name":"2D","slug":"2D","permalink":"http://example.com/tags/2D/"}]},{"title":"毕业设计（2）：维纳攻击论文翻译","slug":"毕业设计/毕业设计2：维纳攻击","date":"2024-01-02T14:35:17.000Z","updated":"2024-04-20T19:25:45.966Z","comments":true,"path":"post/20240102223517.html","permalink":"http://example.com/post/20240102223517.html","excerpt":"前言 1989年，人们在 MICHAEL J. WIENER 的手稿中发现了一篇题为 Cryptanalysis of Short RSA Secret Exponents 的论文。此文中，Wiener 介绍了一种使用续分数算法对 RSA 短密钥的攻击方法。出于毕业设计的要求，下面是我对这篇论文的翻译。请注意，此翻译未经校对，仅作存档用。","text":"前言 1989年，人们在 MICHAEL J. WIENER 的手稿中发现了一篇题为 Cryptanalysis of Short RSA Secret Exponents 的论文。此文中，Wiener 介绍了一种使用续分数算法对 RSA 短密钥的攻击方法。出于毕业设计的要求，下面是我对这篇论文的翻译。请注意，此翻译未经校对，仅作存档用。 下面是一些可能会让人感到疑惑的用词： 位长：通常原文是 size of,bits of number of 等，指的应该是指数的二进制位长度； 秘密指数，公共指数：指的是密钥和公钥中，在加解密时充当指数的数字，即 eee 和 ddd； 续分数：continued fraction； 分数：本文中，有可能其实是分式。 下面是翻译正文。 I. 概要 本文介绍了一种在使用短密钥的 RSA 时的密码分析攻击。该攻击使用了一种基于续分数的算法，当知道了分数的足够近的估值，该算法能在多项式时间内找到分数的分子和分母。含有秘密指数 ddd 的分式的估值可以用公共指数 eee 和模数 pqpqpq 来创建。此基于续分数的算法可以使用此估值可以充分地找到短秘密指数。典型情况是 e&lt;pqe &lt; pqe&lt;pq 、 gcd⁡(p−1,q−1)\\gcd( p - 1, q - 1)gcd(p−1,q−1) 较小且 p 和 q 的位长大致相同，则这种攻击可以发现位长最大约为模数四分之一的秘密指数。本文介绍了使用这种攻击的方法、改进方法和两个悬而未决的问题。这种攻击对 RSA 的正常情况，即秘密指数的大小与模数大致相同的情况，不构成威胁。这是因为这种攻击使用的是公共指数提供的信息，而在正常情况下，公共指数的选择几乎可以与模数无关。 II. 介绍 在 RSA 公钥系统中的所有密钥对集合中[5]，有一些密钥的特性使其可以被多种密码分析攻击所利用。有些攻击利用了模数的弱点，还有的攻击则利用了公共指数或秘密指数的弱点。这里讨论的&quot;弱点&quot;，是那些使得针对 RSA 的攻击可以在模数长度的多项式时间内完成的特性。 针对 RSA 模数的攻击旨在发现模数的两个质数因子（ppp 和 qqq）。在 p−1p-1p−1 和 q−1q-1q−1 的质因子都足够小的时候，有一种攻击可以分解模数[3]。当 p+1p+1p+1 和 q+1q+1q+1 的质因子都很小的时候，也存在一种攻击可以分解模数[6]。当两个质数的差小于 p(log⁡p)k\\sqrt{p}(\\log p)^kp​(logp)k ，其中 kkk 是某些常量，此时存在一个分解模数的简单算法。此算法基于下面的特征。 (p+q2)2−pq=(p−q2)2\\left(\\frac{p+q}{2}\\right)^2-pq=\\left(\\frac{p-q}{2}\\right)^2 (2p+q​)2−pq=(2p−q​)2 通过寻找 p+q2\\frac{p+q}{2}2p+q​ 和 p−q2\\frac{p-q}{2}2p−q​ 就可以分解模数。(p+q2)2(\\frac{p+q}{2})^2(2p+q​)2 可以在从模数开始的完全平方线性搜索中找到。当模数与其平方之差恰为完全平方数时，就可以找到正确的平方。 还有很多 RSA 攻击除了其它条件外，还要求公共指数或秘密指数足够短。某些情况下，使用短公共指数或秘密指数很有吸引力，因为这可以减少加密或解密操作的执行时间。这是因为在模数固定的情况下，RSA 的加解密时间大致与指数位长成正比。使用短指数特别有优势的一种情况是，双方的通信设备算力差距悬殊。例如在智能卡和大型计算机之间的通信中使用 RSA 。在这个例子中，让智能卡掌握短秘密指数而大型计算机掌握短公共指数，以减智能卡需要做的处理是很有吸引力的选择。但是，我们必须警惕对 RSA 的短指数攻击。 当向多方广播同一信息时，短公共指数就有可乘之机[1]。为了描述此种攻击，假设将一条消息 mmm 广播给三方，且公共指数为 e1=e2=33=3e_1=e_2=3_3=3e1​=e2​=33​=3 ，模数为 n1,n2,n3n1,n2,n3n1,n2,n3 ，那么加密消息为： m3mod n1,m3mod n2,m3mod n3m^3\\mod{n_1},\\quad m^3\\mod{n_2},\\quad m^3\\mod{n_3} m3modn1​,m3modn2​,m3modn3​ 使用中国剩余定理，我们可以找出 m3mod n1n2n3m^3\\mod{n_1n_2n_3}m3modn1​n2​n3​ 。但是，由于 m&lt;n1,n2,n3m&lt;n_1,n_2,n_3m&lt;n1​,n2​,n3​，所以 m3&lt;n1n2n3m^3&lt;n_1n_2n_3m3&lt;n1​n2​n3​ 。因此，m3m^3m3 不会因对 n1n1n2n3n_1n_1n_2n_3n1​n1​n2​n3​ 取模而减小。消息可以通过对 m3m^3m3 求立方根而得到。在本论文中描述了一种对短秘密指数的攻击。这种攻击基于续分数。 II. 续分数背景 当已知分数的估计值足够接近时，就可以使用续分数求出分数的分子和分母。这将与第四节中的 RSA 有关，在第 IV 节中，公共指数和模数将用于构建一个含有秘密指数的分数估计值。 根据给定的分数的估计值，利用续分数求分子和分母的算法在此称为续分数算法。该算法将在第 III 节中介绍。 本 节将为讨论连续分数算法提供必要的背景。关于连分数的进一步讨论， 可参阅 [2] 。 续分数的表达式为 \\begin{equation} \\begin{aligned} &amp;\\frac{a_1}{q_1+\\frac{a_2}{q_2+\\frac{a_3}{\\cdots\\frac{\\ }{q_{m-1}+\\frac{a_m}{q_m}}}}}\\\\ &amp;=a_1/(q_1+a_2/(q_2+a_3/(\\cdots/q_{m-1}+a_m/q_m)\\cdots)) \\end{aligned} \\end{equation} 而我们感兴趣的是，上式中所有 aia_iai​ 均为 111 的情况。方便起见，我们定义 \\begin{equation} &lt;q_0,q_1,\\cdots,q_m&gt;=q_0+1/(q_1+1/(q_2+1/(\\cdots/q_{m-1}+1/q_m)\\cdots)) \\end{equation} 例如，&lt;0,2,1,3&gt;=0+1/(2+1/(1+1/3))=4/11&lt;0,2,1,3&gt; =0+1/(2+1/(1+1/3))=4/11&lt;0,2,1,3&gt;=0+1/(2+1/(1+1/3))=4/11 。称 &lt;0,2,1,3&gt;&lt;0,2,1,3&gt;&lt;0,2,1,3&gt; 为 411\\frac{4}{11}114​ 的续分数展开式 正有理数 fff 的续分数展开式是通过减去 fff 的整数部分，然后不断对余下部分取倒数再减去整数部分，直到小数部分为零为止。设 qiqiqi 为整数商，rrr 为第 iii 步余下的小数，mmm 为反转的步数： \\begin{equation} \\begin{aligned} &amp;q_0=\\lfloor f\\rfloor, \\quad r_0=f-q_0, \\text{且}\\\\ &amp;q_i=\\lfloor \\frac{1}{r_{i-1}}\\rfloor,\\quad r_i=\\frac{1}{r_{i-1}}-q_i,\\quad (i=1,2,\\cdots,m) \\end{aligned} \\end{equation} 因为 rm=0r_m=0rm​=0，我们有 f=⟨q0,q1,⋯ ,qm⟩f=\\langle q_0,q_1,\\cdots,q_m\\ranglef=⟨q0​,q1​,⋯,qm​⟩ 。此处可以得出两点结论，它们稍后会很有用的。第一， qm≥2q_m\\geq2qm​≥2。若 qm=1q_m=1qm​=1 会推出 rm−1=1r_{m-1}=1rm−1​=1 ，这是不可能的，故得证。第二个结论是，对任意 x&gt;0x&gt;0x&gt;0： \\begin{equation} \\begin{aligned} \\langle q_0,q_1,\\cdots,q_m\\rangle &lt;\\langle q_0,q_1,\\cdots,q_m+x\\rangle,\\\\ &amp;\\text{若} m \\text{是偶数},\\\\ \\langle q_0,q_1,\\cdots,q_m\\rangle &gt;\\langle q_0,q_1,\\cdots,q_m+x\\rangle,\\\\ &amp;\\text{若} m 、\\text{是奇数}. \\end{aligned} \\end{equation} 这可以通过查看 (2) 式中分数嵌套的层数看出。 现在我们开始思考如何通过 fff 的续分数展开式构造出 fff 。利用 (2) 式，可以从 qmq_mqm​ 开始，每步不断加和求倒数，直到回到 q0q_0q0​ ，以得到 fff。不过，要是能从 q0q_0q0​ , 开始重建 fff 就很好了。设 nin_ini​ 和 did_idi​ （其中 i=0,1,⋯ ,mi=0,1,\\cdots,mi=0,1,⋯,m）分别为一系列被定义为如下形式的分子和分母： \\begin{equation} \\begin{aligned} \\frac{n_i}{d_i}=\\langle q_0,q_1,\\cdots,q_i\\rangle,\\quad \\gcd(n_i,d_i)=1\\\\ &amp;i=0,1,\\cdots,m\\\\ \\end{aligned} \\end{equation} 可以写成如下形式： \\begin{equation} \\begin{aligned} &amp;n_0=q_0, &amp;&amp;d_0=1,\\\\ &amp;n_1=q_0q_1+1, &amp;&amp;d_1=q_1,\\\\ &amp;n_i=q_in_{i-1}+n_{i-2}, &amp;&amp;d_i=q_id_{i-1}+d_{i-2},\\\\ &amp;&amp;&amp;\\qquad i=2,3,\\cdots,m. \\end{aligned} \\end{equation} 这样，通过分式 f=nmdmf=\\frac{n_m}{d_m}f=dm​nm​​ 就可以构造出 fff 来了。 上述的分子分母 n,dn,dn,d 之间有下列在后面很有用的关系，可以证明： \\begin{equation} n_id_{i-1}-n_{i-1}d_i=-(-1)^i,\\quad i=1,2,\\cdots,m \\end{equation} 现在，我们已经介绍了足够的连分数背景知识，以供讨论连分数算法。 III. 续分数算法 设 f′f&#x27;f′ 是 fff 的低估值： \\begin{equation} f&#039;=f(1-\\delta), \\quad\\delta \\geq 0 \\end{equation} 设 qiq_iqi​，rir_iri​，和 qi′q&#x27;_iqi′​，ri′r&#x27;_iri′​，分别是 fff 和 f′f&#x27;f′ 的第 i 个商和因数。若 δ\\deltaδ 足够小，那么可以下面的算法求出 fff 的分子和分母。重复以下步骤，直到找到 fff 为止： 生成 f′f&#x27;f′ 的续分数展开式的下一个商（qi′q_i&#x27;qi′​）。 用 (6) 式构造分式使之等于⟨q0′,q1′,⋯ ,qi−1′,qi′+1,⟩,i为偶数,⟨q0′,q1′,⋯ ,qi−1′,qi′,⟩,i为奇数.\\begin{aligned} &amp;\\langle q_0&#x27;,q_1&#x27;,\\cdots, q_{i-1}&#x27;,q_i&#x27;+1,\\rangle, \\qquad&amp;i \\text{为偶数},\\\\ &amp;\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_{i-1}&#x27;,q_i&#x27;,\\rangle, \\qquad&amp;i \\text{为奇数}. \\end{aligned} ​⟨q0′​,q1′​,⋯,qi−1′​,qi′​+1,⟩,⟨q0′​,q1′​,⋯,qi−1′​,qi′​,⟩,​i为偶数,i为奇数.​ 检查构造的分式是否等于 fff 。 在第偶数个商的值上加 111 的原因是，fff 的猜测值应该大于 f′f&#x27;f′ ，因为 f≥f′f \\geq f&#x27;f≥f′。这点可以在 (4) 式中由 ⟨q0′,q1′,⋯ ,qi−1′,qi′⟩\\langle q&#x27;_0,q&#x27;_1,\\cdots,q&#x27;_{i-1},q_i&#x27;\\rangle⟨q0′​,q1′​,⋯,qi−1′​,qi′​⟩ 小于 ⟨q0′,q1′,⋯ ,qi−1′,qi′+ri′⟩\\langle q&#x27;_0,q&#x27;_1,\\cdots,q&#x27;_{i-1},q_i&#x27;+r&#x27;_i\\rangle⟨q0′​,q1′​,⋯,qi−1′​,qi′​+ri′​⟩ 看出。注意为了确定 fff 的猜测值是否正确，必须对其进行检验。 若 \\begin{equation} \\begin{aligned} &amp;\\langle q_0,q_1,\\cdots, q_{m-1},q_m-1,\\rangle&lt;f&#039;\\leq \\langle q_0,q_1,\\cdots, q_m\\rangle, \\qquad&amp;i \\text{为偶数},\\\\ &amp;\\langle q_0,q_1,\\cdots,q_{m-1},q_m+1,\\rangle&lt;f&#039;\\leq \\langle q_0,q_1,\\cdots, q_m\\rangle, \\qquad&amp;i \\text{为奇数}. \\end{aligned} \\end{equation} 成立，那么续分数算法就是正确的。 现在考虑 (9) 式关于 δ\\deltaδ 的大小的推论。在 (8) 式解得 \\begin{equation} \\delta =1-\\frac{f&#039;}{f} \\end{equation} 分别分析以下的几种情况：m=0m=0m=0， m=1m=1m=1 ，mmm 为大于等于 222 的偶数，mmm 为大于等于 333 的奇数。 情况 1：m=0m=0m=0。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0-1\\rangle}{\\langle q_0\\rangle} \\end{equation} 利用 (2) 式，可将其简化为 δ&lt;1/q0\\delta &lt; 1/q_0δ&lt;1/q0​，并可重写为（请注意 n0=q0n_0 = q_0n0​=q0​ 和 d0=1d_0 = 1d0​=1） \\begin{equation} \\delta&lt;\\frac{1}{n_0d_0} \\end{equation} 情况 2：m=1m=1m=1。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0,q_1+1\\rangle}{\\langle q_0,q_1\\rangle} \\end{equation} 利用 (2) 式，可以有： \\begin{equation} \\delta&lt;\\frac{1}{(q_0q_1+1)(q_1+1)} \\end{equation} 前面已经证明 qm≥2q_m \\geq 2qm​≥2 ，这意味着此时 32q1≥q1+1\\frac{3}{2}q_1\\geq q_1+123​q1​≥q1​+1。结合 (14) 式以及 (6)式中的 n1n_1n1​ 和 d1d_1d1​ 表达式，有： \\begin{equation} \\delta=\\frac{1}{\\frac{3}{2}n_1d_1} \\end{equation} 足以保证续分数算法的成功。 情况 3：mmm 为大于等于 222 的偶数。 用 (9) 式代换 (10)式中的 f′f&#x27;f′ ： \\begin{equation} \\delta&lt;1-\\frac{\\langle q_0,q_1,\\cdots,q_{m-1},q_m-1\\rangle}{\\langle q_0,q_1,\\cdots,q_m\\rangle} \\end{equation} 利用 (6) 式，有： \\begin{equation} \\begin{aligned} \\langle q_0,q_1,\\cdots,q_{m-1},q_m-1\\rangle&amp;=\\frac{(q_{m}-1)n_{m-1}+n_{m-2}}{(q_{m}-1)d_{m-1}+d_{m-2}}\\\\ \\langle q_0,q_1,\\cdots,q_m\\rangle&amp;=\\frac{q_{m}n_{m-1}+n_{m-2}}{q_{m}d_{m-1}+d_{m-2}} \\end{aligned} \\end{equation} 将上面的表达式代入到 (16) 式： \\begin{equation} \\delta&lt;\\frac{n_{m-1}d_{m-2}-n_{m-2}d_{m-1}}{(q_mn_{m-1}+n_{m-2})(q_md_{m-1}+d_{m-2}-d_m-1)} \\end{equation} 利用 (7) 式及 (6) 式中 nmnmnm 和 dmd_mdm​ 的表达式，得： \\begin{equation} \\delta&lt;\\frac{1}{n_m(d_m-d_{m-1})} \\end{equation} 因此 \\begin{equation} \\delta&lt;\\frac{1}{n_md_m} \\end{equation} 足以保证续分数算法的成功。 情况 4：mmm 为大于等于 333 的奇数。 和情况 3 中进行类似的分析，得 \\begin{equation} \\delta&lt;\\frac{1}{n_m(d_m+d_m-1)} \\end{equation} 由 dm=qmdm−1+dm−2d_m=q_md_{m-1}+d_{m-2}dm​=qm​dm−1​+dm−2​ 且 qm≥2q_m\\geq2qm​≥2 ，有 dm+dm−1≤32dmd_m+d_{m-1}\\leq \\frac{3}{2}d_mdm​+dm−1​≤23​dm​ 。因此， \\begin{equation} \\delta&lt;\\frac{1}{\\frac{3}{2}n_md_m} \\end{equation} 足以保证续分数算法的成功。 综合考虑上面提到的四种情况： \\begin{equation} \\delta &lt;\\frac{1}{\\frac{3}{2}n_md_m} \\end{equation} 足以保证续分数算法的成功。这里的 nm,dmn_m,d_mnm​,dm​ 就是前面提到过的 fff 的分子和分母。 现在考虑续分数算法执行的花费时间。设 x=max⁡(nm,dm)x=\\max(n_m,d_m)x=max(nm​,dm​) ，fff 的续分数展开式中除计算的数量可被表示为 O(log⁡x)O(\\log x)O(logx) 。每次除计算后，会得到并检验一个 fff 的猜测值。算式要求每次得到的 fff 的猜测值是 log⁡x\\log xlogx 的多项式。因此，假设 fff 的检验在 log⁡x\\log xlogx 的多项式中是正确的，那么续分数算法执行花费的时间就是 log⁡x\\log xlogx 的多项式。 IV. 在 RSA 上应用续分数算法 在 [5] 中给出了公共指数 eee 和秘密指数 ddd 的关系： \\begin{equation} ed\\equiv1\\mod LCM(p-1,q-1) \\end{equation} 这种关系对于公开指数和秘密指数互为倒数的指数运算来说是必要的。根据 (24)，必定存在一个整数 K，使 \\begin{equation} ed=K\\cdot LCM(p-1,q-1)+1 \\end{equation} 若令 G=gcd⁡(p−1,q−1)G=\\gcd(p-1,q-1)G=gcd(p−1,q−1) ，由 lcm(p−1,q−1)=(p−1)(q−1)Glcm(p-1,q-1)=\\frac{(p-1)(q-1)}{G}lcm(p−1,q−1)=G(p−1)(q−1)​ 得 \\begin{equation} ed=\\frac{K}{G}(p-1)(q-1)+1 \\end{equation} KKK 和 GGG 有可能有共同的因子。我们定义 k=Kgcd⁡(K，G)k = \\frac{K}{\\gcd(K，G)}k=gcd(K，G)K​ 和 g=Ggcd⁡(K,G)g=\\frac{G}{\\gcd(K,G)}g=gcd(K,G)G​。那么有 \\begin{equation} ed=\\frac{k}{g}(p-1)(q-1)+1 \\end{equation} 把 (27) 式同时除以 dpqdpqdpq： \\begin{equation} \\frac{e}{pq}=\\frac{k}{dg}(1-\\delta),\\qquad 其中\\ \\delta=\\frac{p+q-1-\\frac{g}{k}}{pq} \\end{equation} 需要注意 epq\\frac{e}{pq}pqe​ 是完全由公开信息构成的，且是对 kdg\\frac{k}{dg}dgk​ 的近似低估。在使用续分算法之前，我们必须记住这种算法总是能找到最小项的分数。由 (25) 可知，gcd⁡(K,d)=1\\gcd(K, d) = 1gcd(K,d)=1。因为 kkk 整除 KKK，所以 gcd⁡(k,d)=1\\gcd(k, d) = 1gcd(k,d)=1。根据定义，gcd⁡(k，g)=1\\gcd(k，g)= 1gcd(k，g)=1。因此，gcd(k，dg)=1gcd(k，dg)= 1gcd(k，dg)=1 ，故而只要 δ\\deltaδ 足够小就可以使用续分数算法求出 kkk 和 dgdgdg。 通过 (28) 式中的 δ\\deltaδ 表达式和 (23) 式对 δ\\deltaδ 的限制，可以证明 \\begin{equation} kdg&lt;\\frac{pq}{\\frac{3}{2}(p+q)} \\end{equation} 对求出 kkk 和 dgdgdg 是充分的。注意 (−1−gk)(-1-\\frac{g}{k})(−1−kg​) 在 δ\\deltaδ 的表达式中被舍弃了，因为其相对于 (p+q)(p+q)(p+q) 是很小的。这不会影响 (29) 式的有效性，因为 −1−gk-1-\\frac{g}{k}−1−kg​ 在算式中只会减小 δ\\deltaδ 的大小。 现在，我们将考虑如何检验 kkk 和 dgdgdg 的猜测是正确的。为了简化测试，我们假设 ed&gt;pqed &gt; pqed&gt;pq。这并不是一个特别严格的假设，因为当 eee 或 ddd 固定时，另一个的期望值约为 pq/Gpq / Gpq/G（回顾 G=gcd⁡(p−1,q−1)G = \\gcd(p - 1, q - 1)G=gcd(p−1,q−1)。除非 G 选得很大，否则 ed&gt;pqed&gt;pqed&gt;pq 的可能性很大。根据 (27) 式，ed&gt;pqed &gt; pqed&gt;pq 的结果是 k&gt;gk&gt;gk&gt;g 。重写(27)式成： \\begin{equation} edg=k(p-1)(q-1)+g \\end{equation} 可以看到，只要 k&gt;gk&gt;gk&gt;g ,那么用 kkk 除 edgedgedg 就有商 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 余 ggg 。这就给了我们一个 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 和 ggg 的猜测。如果 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 是 000，那么 kkk 和 dgdgdg 的值都是错误的。这种情况必须被过滤掉，不然该测试就会把 pqpqpq 分解为 111 和 pqpqpq。通过下列等式，我们可以用 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的猜测值来猜测 p+q2\\frac{p+q}{2}2p+q​ ： \\begin{equation} \\frac{pq-(p-1)(q-1)+1}{2}=\\frac{p+q}{2} \\end{equation} 若 p+q2\\frac{p+q}{2}2p+q​ 的值不是整数，则 kkk 和 dgdgdg 的值都是错误的。通过下式，可以用 p+q2\\frac{p+q}{2}2p+q​ 的猜测值来猜测 (p−q2)2(\\frac{p-q}{2})^2(2p−q​)2： \\begin{equation} (\\frac{p+q}{2})^2-pq=(\\frac{p-q}{2})^2 \\end{equation} 若 ((p−q)/2)(( p - q)/2)((p−q)/2) 的猜测是完全平方，那么原来对 kkk 和 dgdgdg 的猜测就是正确的。用 dgdgdg 除以 ggg 可以求出秘密指数 ddd 。如前所述，ggg 是 edgedgedg 除以 kkk 的余数。我们也能通过 (p+q)2\\frac{(p+q)}{2}2(p+q)​ 和 (p−q)2\\frac{(p-q)}{2}2(p−q)​ 轻松地算出 ppp 和 qqq 的值。 如果不采取任何措施对抗这种 RSA 上的续分数攻击，那么就可以期望 ggg 很小且 g&lt;dgg&lt;dgg&lt;dg。在这种条件下，由 (29) 式可知，二进制位数不大于大约模数四分之一比特位数的秘密指数可以在多项式时间内找到。这种攻击无法扩展到秘密指数与模的大小大致相同的正常情况，因为它依赖于公共指数提供信息来对模数进行因数分解，而在正常情况下，公共指数的选择几乎与模无关。 V. 例子 在这一部分，我们给续分数算法中放入一组很小的 RSA 密钥对： pq=8927e=2621pq=8927\\quad e= 2621 pq=8927e=2621 epq=26218927\\frac{e}{pq}=\\frac{2621}{8927}pqe​=89272621​ 的续分数展开式如表 I。 需要求的量 计算方法 i=0i=0i=0 i=1i=1i=1 i=2i=2i=2 qi′q&#x27;_iqi′​ 见 (3) 式 000 333 222 ri′r_i&#x27;ri′​ 见 (3) 式 26218927\\frac{2621}{8927}89272621​ 10642621\\frac{1064}{2621}26211064​ 4931064\\frac{493}{1064}1064493​ ni′di′=⟨q0′,q1′,⋯ ,qi′⟩\\frac{n_i&#x27;}{d_i&#x27;}=\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_i&#x27;\\rangledi′​ni′​​=⟨q0′​,q1′​,⋯,qi′​⟩ 见 (6) 式 01\\frac{0}{1}10​ 13\\frac{1}{3}31​ 27\\frac{2}{7}72​ kdg\\frac{k}{dg}dgk​ 的估值 ⟨q0′,q1′,⋯ ,qi−1′,qi′+1⟩(偶数)⟨q0′,q1′,⋯ ,qi′⟩(奇数)\\langle q_0&#x27;,q_1&#x27;,\\cdots,q&#x27;_{i-1},q_i&#x27;+1\\rangle\\quad(偶数)\\\\\\langle q_0&#x27;,q_1&#x27;,\\cdots,q_i&#x27;\\rangle\\quad(奇数)⟨q0′​,q1′​,⋯,qi−1′​,qi′​+1⟩(偶数)⟨q0′​,q1′​,⋯,qi′​⟩(奇数) 11\\frac{1}{1}11​ 13\\frac{1}{3}31​ 310\\frac{3}{10}103​ edgedgedg 的估值 e⋅dge\\cdot dge⋅dg 262126212621 786378637863 262102621026210 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的估值 ⌊edgk⌋\\lfloor\\frac{edg}{k}\\rfloor⌊kedg​⌋ 262126212621 786378637863 888 ggg 的估值 edgmod kedg\\mod kedgmodk 000 000 222 p+q2\\frac{p+q}{2}2p+q​ 的估值 见 (31) 式 3153.53153.53153.5 532.5532.5532.5 969696 (p−q2)2(\\frac{p-q}{2})^2(2p−q​)2 见 (32) 式 退出 退出 289=172289=17^2289=172 ddd dgg\\frac{dg}{g}gdg​ 555 在本例中，RSA 续分数攻击的结果是： d=8927,p=113,q=79,k=3,g=2.d=8927\\quad, p=113\\quad,q=79\\quad, k=3\\quad, g=2\\quad. d=8927,p=113,q=79,k=3,g=2. 通过将值代入 (27) 式验证，可以知道 d=5d=5d=5 就是 e=2621e=2621e=2621 对应的密钥。还可以验证，算法成功的充分条件 (29) 式得到了满足。 这个例子展现了对 RSA 进行续分数攻击的细节，但考虑一个更现实的情况也很有用。假设在 RSA 算法中用了一个 102410241024 比特（bit）的模数，那么 p,qp, qp,q 的大小约为 25122^{512}2512。假设 g=2g=2g=2，且 e≈pqe\\approx pqe≈pq，则 k≈dgk\\approx dgk≈dg（见(28) 式）。那么利用 (29) 式，可以看到续分数攻击可以找到最大约为 22552^{255}2255 的密钥。 VI. 对抗 RSA 的续分数攻击 有两种方法可以减少可以使用 RSA 续分数攻击找到的秘密指数的最大值。由 (29) 式可知，这两种方法就是让 kkk 变大或让 ggg 变大。 要使 kkk 增大，就必须让公共指数 eee 增大（见 (27)式）。这可以通过在 eee 上添加 lcm(p−1，q−1)lcm (p-1，q-1)lcm(p−1，q−1) 的倍数来实现。假设 e&gt;(pq)1.5e&gt;(pq) ^{1.5}e&gt;(pq)1.5 ,可以推出 kdg&gt;(pq)0.5\\frac{k}{dg}&gt;(pq)^{0.5}dgk​&gt;(pq)0.5 （见 (28) 式）。将 k=dg(pq)0.5k=dg(pq)^{0.5}k=dg(pq)0.5 代入到 (29) 式，得到 d&lt;1d&lt;1d&lt;1 。因此，若 e&gt;(pq)1.5e&gt;(pq) ^{1.5}e&gt;(pq)1.5 ，续分数算法就不能保证对任意大小的秘密指数均有效了。增大 eee 的大小有其弊端，这会导致公钥加密花费的时间增多。但是这在一些系统中是可以接受的。 要使 ggg 更大，必须选择 p 和 q 使得 gcd⁡(p−1，q−1)\\gcd (p-1，q-1)gcd(p−1，q−1) 很大。但是，我们稍后可以看到，在特定条件下有些方法可以找出 ggg 或 ggg 的因子。 VII. 改善攻击算法 在这一节，我们讨论四种针对短秘密指数攻击的可能改善方法。第一个改善是允许续分数算法稍微越过 (29) 式的限制持续搜寻 ddd。算法只能保证在限制内一定有效，但是略微超出限制也可能有效。这能让找到的（最大）秘密指数位长增加一位左右。 第二种改善基于下面的观察：kdg\\frac{k}{dg}dgk​ 的低估值 epq\\frac{e}{pq}pqe​ ，其分母就是对 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的高估值。一个更贴近 (p−1)(q−1)(p-1)(q-1)(p−1)(q−1) 的估值是： ⌊(pq−1)2⌋\\lfloor(\\sqrt{pq}-1)^2\\rfloor ⌊(pq​−1)2⌋ 使用此估值，(29) 式变成 kdg&lt;23(pq−1p−q)2.kdg&lt;\\frac{2}{3}(\\frac{\\sqrt{pq}-1}{\\sqrt{p}-\\sqrt{q}})^2. kdg&lt;32​(p​−q​pq​−1​)2. 这可以提高可以找到的秘密指数大小。此项改进提高的量随 ∣p−q∣|p-q|∣p−q∣ 的减小而提高。 第三个 RSA 上的续分数攻击改善方法是，对 kdg\\frac{k}{dg}dgk​ 的多个猜测值执行该算法。我们可以从某个猜测值开始，然后逐步尝试更大的猜测值。这样一来，我们就等于对 kdg\\frac{k}{dg}dgk​ 进行了线性搜索。对于最大为 (29) 式中限制大小的秘密指数，此算法消耗多项式时间。而当秘密指数的位长增长超过限制，算法执行的次数就呈指数增长。 第四个改善是尝试寻找 ggg 或 ggg 的因子。假设 ttt 是 ggg 的一个已知因子，那么我们可以用 t(epq)作为kd(gt)的低估值。t\\left(\\frac{e}{pq}\\right) 作为\\frac{k}{d(\\frac{g}{t})}的低估值。 t(pqe​)作为d(tg​)k​的低估值。 这种情况下，(29) 式就变成了 kd(gt)&lt;pq32(p+q)kd\\left(\\frac{g}{t}\\right)&lt;\\frac{pq}{\\frac{3}{2}(p+q)} kd(tg​)&lt;23​(p+q)pq​ ddd 的大小的增加可以通过 ttt 的一个因子找到。我们需要一种方法找到 g 的所有因子。因为 ggg 整除 gcd⁡(p−1)(q−1)\\gcd(p-1)(q-1)gcd(p−1)(q−1), 且 ggg 也整除 p−1p-1p−1 和 q−1q-1q−1，那么 g 也整除 pq−1pq-1pq−1，因为 pq−1=(p−1)(q−1)+(p−1)+(q−1)pq-1=(p-1)(q-1)+(p-1)+(q-1) pq−1=(p−1)(q−1)+(p−1)+(q−1) 一种可能的寻找 ggg 的所有因数的办法是因数分解 pq−1pq-1pq−1。如果 ggg 选择得很大且 ggg 的所有质因子都很大，那么通过分解 pq−1pq-1pq−1 寻找 ggg 的因数可能会很困难。但是，如果 ggg 足够大，从而使 p−1g\\frac{p-1}{g}gp−1​ 和 q−1g\\frac{q-1}{g}gq−1​ 很小，我们就可以通过寻找 p−1g\\frac{p-1}{g}gp−1​ 和 q−1g\\frac{q-1}{g}gq−1​ 的可能值来找到 ggg。 VIII. 悬而未决的问题 使用短秘密指数的主要原因是减少密钥做指数时（消耗）的时间。要减少密钥做指数消耗的时间，一种有效的办法是利用 ppp 和 qqq（而不仅仅是乘积 pqpqpq）的知识 [4]。利用这种方法，需要执行两次一半位长的指数计算。第一次指数计算使用指数 dp=dmod p−1d_p=d\\mod{p-1}dp​=dmodp−1，得出模 ppp 后的结果。第二次则使用指数 dq=dmod q−1d_q=d\\mod{q-1}dq​=dmodq−1 得出模 qqq 的结果。这两个结果结合在一起，可以通过中国剩余定理轻松地得到最终的模 pqpqpq 的结果。我们可以通过选择 ddd 使得 dpd_pdp​ 和 dqd_qdq​ 都很短，从而进一步的减少密钥指数运算的时间。一个有趣的公开问题是，在 dpd_pdp​ 和 dqd_qdq​ 都很短但是不相等的时候，是否存在一种 RSA 攻击。 另一个未解决的问题是于公共指数的位长有关。本论文前面描述的攻击在选择的公共指数至少比模数 pqpqpq 长 50%50\\%50% 时会无效。对某些系统而言，为了快速的密钥计算，这是可以承担的小代价。一个有趣的问题是，当秘密指数很小但是公共指数比模数还大时，是否存在一种 RSA 攻击。 IX. 结论 续分数算法可以在多项式时间内找到足够短的 RSA 秘密指数。一种典型的情况是，e&lt;pqe&lt;pqe&lt;pq，gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 很小，且 ppp 和 qqq 位长大致相等，此算法就可以找到位长最大约为模数的四分之一的秘密指数。 有很多种办法对抗 RSA 上的续分数攻击。如果 e&gt;(pq)1.5e&gt;(pq)^{1.5}e&gt;(pq)1.5 ，那么续分数算法对任何位长的秘密指数都无法保证有效。同时我们也可以选择让 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 很大，因为能找到的秘密指数长度与 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 成反比。不过，让 gcd⁡(p−1,q−1)\\gcd(p-1,q-1)gcd(p−1,q−1) 变大可能会导致其它的问题。 我们还讨论了若干 RSA 上的续分数攻击的改善方法。但是，在多项式时间内搜寻时，它们只能让能找到的最大秘密指数长度增加些许几位。因为当秘密指数的长度增长到超过最大限度时，寻找秘密指数的时间需求会呈指数增长。此攻击无法拓展到通常的情况，即秘密指数与模数大致有一样的位长。 参考文献 J. Hastad. “On using RSA with low exponent in a public key network,” Lecture Notes in Computer Science: Advances in Cryptology-CRYPT0 ’85 Proceedings. New York: Springer-Verlag, pp.403-408. D. E. Knuth, Art of Computer Programming Vol. 2/Seminumerical algorithms. New York: Addison Wesley, 1969. J. M. Pollard. “Theorems on factorization and primality testing,”Proc. Cambridge Philos. Soc., vol. 76, 1974, pp. 521-528. J. J. Quisquater and C. Couvreur, “Fast decipherment algorithm for RSA public-key cryptosystem,” Electron. Lett., vol. 18, no. 21,pp. 905-907, Oct. 1982. R. L. Rivest, A. Shamir, and L. Adleman, “A method for obtaining digital signatures and public key cryptosystems.” Commun. ACM.vol. 21, no. 2, pp. 158-164, Feb. 1978. H. C. Williams, “A p + 1 method of factoring,” Muthemutics of Computation, vol. 39, no. 159, pp. 225-234, July 1982.","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"}]},{"title":"毕业设计（1）：RSA密码与其数学原理","slug":"毕业设计/毕业设计1：RSA密码","date":"2023-12-13T14:09:26.000Z","updated":"2024-04-20T18:58:06.476Z","comments":true,"path":"post/20231213220926.html","permalink":"http://example.com/post/20231213220926.html","excerpt":"前言 什么是 RSA 算法及其数学原理。毕业设计笔记。","text":"前言 什么是 RSA 算法及其数学原理。毕业设计笔记。 RSA 算法的步骤 这里先不加数学原理解释，直接给出 RSA 的基本工作步骤，如下。 密钥的生成 选择两个素数 ppp，qqq； 记 n=p×qφ(n)=(p−1)×(q−1)n = p \\times q \\\\ \\varphi(n) = (p-1)\\times(q-1) n=p×qφ(n)=(p−1)×(q−1) 求公钥：任意选择 eee 使得： {0&lt;e&lt;φ(n)gcd(φ(n),e)=1\\left\\{ \\begin{aligned} &amp;0&lt;e&lt;\\varphi(n) \\\\ &amp;gcd(\\varphi(n),e)=1 \\end{aligned} \\right. {​0&lt;e&lt;φ(n)gcd(φ(n),e)=1​ 即 eee 小于 φ(n)\\varphi(n)φ(n)，且与 φ(n)\\varphi(n)φ(n) 互质； 求私钥：计算 ddd，其满足 d⋅e≡1mod (φ(n))d\\cdot e \\equiv 1 \\mod(\\varphi(n))d⋅e≡1mod(φ(n))。或者说，d⋅e+c⋅φ(n)=1d\\cdot e+ c\\cdot\\varphi(n)=1d⋅e+c⋅φ(n)=1，其中 ccc 不确定，求 ddd； {e,n}为公钥，{d，n}为私钥，p，q丢弃。 发现自己连第四步中的 d⋅e+c⋅φ(n)=1d\\cdot e+ c\\cdot\\varphi(n)=1d⋅e+c⋅φ(n)=1 都不会推了，简单记一下。 d⋅e≡1mod (φ(n))d⋅e−1=k⋅φ(n)d⋅e+c⋅φ(n)=1\\begin{aligned} d\\cdot e &amp;\\equiv 1 \\mod(\\varphi(n))\\\\ d\\cdot e-1&amp;=k\\cdot\\varphi(n)\\\\ d\\cdot e+ c\\cdot\\varphi(n)&amp;= 1 \\end{aligned} d⋅ed⋅e−1d⋅e+c⋅φ(n)​≡1mod(φ(n))=k⋅φ(n)=1​ 加密 对于明文 m，密文为c： c≡memod (n)c\\equiv m^e \\mod(n) c≡memod(n) 也就是说，我们对 mmm 进行幂运算同时进行模运算即可加密。 解密 对于密文 ccc，明文 mmm： m≡cdmod (n)m\\equiv c^d \\mod(n) m≡cdmod(n) 也就是说，我们对 ccc 进行幂运算同时进行模运算即可解密。 RSA 的数学基础 乘法逆元与扩展欧几里得算法 裴蜀定理（不证） 裴蜀定理（Bézout's lemma）指出，关于 aaa，bbb 的方程： ax+by=max+by=m ax+by=m 仅在 mmm 为 aaa，bbb 的最大公约数的倍数时，有整数解。 通过裴蜀定理，我们就可以把 gcd⁡(a,b)\\gcd(a,b)gcd(a,b) 转化成 ax+by=max+by=max+by=m。其中 m 是最大公因数的倍数。 特别地，当 m=1m=1m=1，这个时候 x,yx,yx,y 分别被叫做 aaa关于模 bbb 的模逆元 xxx 和 bbb关于模 aaa 的模逆元 yyy。 乘法逆元 ab≡1mod (n)ab\\equiv 1 \\mod(n) ab≡1mod(n) 则 a,ba,ba,b 互为乘法逆元（模逆元、模倒数）。此时有： ab+kn=1ab+kn=1 ab+kn=1 乘法逆元存在的充要条件是 a,na,na,n 互质，换句话说，右边的 1 其实是 gcd(a,n)gcd(a,n)gcd(a,n)。若 gcd(a,n)≠1gcd(a,n) \\neq 1gcd(a,n)=1，那么 xxx 就不是逆元。 求乘法逆元我们可以使用下面介绍的扩展欧几里得算法，在求 gcd(a,n)gcd(a,n)gcd(a,n) 的过程中，将逆元 bbb 求出。 在 RSA 中，私钥 ddd 实际上就是公钥 eee 的乘法逆元。 欧几里得算法与其证明 欧几里得算法即辗转相除法，用于求两个数的最大公因数。在密钥生成的第三步，我们可以用欧几里得算法检查 gcd(φ(n),e)gcd(\\varphi(n),e)gcd(φ(n),e) 是否为 1。其算法逻辑如下： 123456789int gcd(int a, int b)&#123; if (b == 0) &#123; return a; &#125; int d = gcd(b, a % b); return d;&#125; 比较简单就只写代码了。 下面是该算法有效性的证明： 设 a&gt;ba&gt;ba&gt;b （否则，代码结果会等价于做一次交换）： 在带余除法下，我们设 q=⌊ab⌋q=\\displaystyle\\left\\lfloor\\frac{a}{b}\\right\\rfloorq=⌊ba​⌋：商 r=a mod br=a\\bmod br=amodb：余 d1=gcd⁡(a,b)d_1=\\gcd(a,b)d1​=gcd(a,b)：最大公因数 d2=gcd⁡(b,r)d_2=\\gcd(b,r)d2​=gcd(b,r)：与余的最大公因数 那么，对于 d1d_1d1​： 由于 bbb 是最大公因数 d1d_1d1​ 的倍数，那么 qbqbqb 也是 d1d_1d1​ 的倍数； 又 aaa 是最大公因数 d1d_1d1​ 的倍数，那么 a−qba-qba−qb 也是 d1d_1d1​ 的倍数； 又 r=a−qbr=a-qbr=a−qb ，所以 rrr 也是 d1d_1d1​ 的倍数。 d1d_1d1​同时为 bbb 和 rrr 因数，即 d1d_1d1​ 是 bbb 和 rrr 的公因数。 由于 d2=gcd⁡(b,r)d_2=\\gcd(b,r)d2​=gcd(b,r) 数，根据性质“最大公因数是所有公因数的倍数”，可知 d1d_1d1​ 是 d2d_2d2​ 的因数。 另一方面，对于 d2d_2d2​： 由于 bbb 是最大公因数 d2d_2d2​ 的倍数，那么 qbqbqb 也是 d2d_2d2​ 的倍数； 又 rrr 是最大公因数 d2d_2d2​ 的倍数，那么 r+qbr+qbr+qb 也是 d2d_2d2​ 的倍数； 由于 a=qb+ra=qb+ra=qb+r ，所以 aaa 也是 d2d_2d2​ 的倍数。 所以 d2d_2d2​ 是 aaa 和 bbb 的公因数。 由于 d1=gcd⁡(a,b)d_1=\\gcd(a,b)d1​=gcd(a,b) ，根据性质“最大公因数是所有公因数的倍数”，所以 d2d_2d2​ 是 d1d_1d1​ 的因数。 d1d_1d1​ 是 d2d_2d2​ 的因数， d2d_2d2​ 也是 d1d_1d1​ 的因数，这说明 d1=d2d_1=d_2d1​=d2​ ，即 gcd⁡(a,b)=gcd⁡(b,a mod b)\\gcd(a,b)=\\gcd(b,a\\bmod b)gcd(a,b)=gcd(b,amodb) 。因此辗转相除法是正确的。 最大公因数是所有公因数的倍数的证明： 设 g=gcd(a,b)g= gcd(a,b)g=gcd(a,b)，ddd 是所有形如 ax+byax+byax+by 的正整数中最小的。 由于正整数 d=ax+by=xk1g+yk2g=g(xk1+yk2)&gt;0d=ax+by=xk_1g+yk_2g=g(xk_1+yk_2)&gt;0d=ax+by=xk1​g+yk2​g=g(xk1​+yk2​)&gt;0，那么 ggg 整除 ddd 且 g⩽dg\\leqslant dg⩽d； 设 d=ax0+by0d=ax_0+by_0d=ax0​+by0​，用 ddd 带余除任意形如 ax+byax+byax+by 的数，设为 ax+by=dq+rax+by=dq+rax+by=dq+r，那么 r=ax+by−d=a(x−qx0)+b(y−qy0)r=ax+by-d=a(x-qx_0)+b(y-qy_0)r=ax+by−d=a(x−qx0​)+b(y−qy0​)。即 rrr 也是一个形如 ax+byax+byax+by 的数。 由余数的定义，可知 0⩽r&lt;d0\\leqslant r&lt; d0⩽r&lt;d；若 r&gt;0r&gt;0r&gt;0 那么这与前述“ddd 是所有形如 ax+byax+byax+by 的正整数中最小的”相矛盾，所以 r=0r=0r=0。 即： ddd 整除任意形如 ax+byax+byax+by 的数。 因此，ddd 整除 aaa，bbb，即 ddd 是 aaa，bbb的公因数。那么， d⩽gd\\leqslant gd⩽g。 综合 g⩽dg\\leqslant dg⩽d 和 d⩽gd\\leqslant gd⩽g 有 g=d=ax+byg=d=ax+byg=d=ax+by。 可以看出 ax+byax+byax+by 可以被 aaa，bbb 的每一个公因数整除，因此，最大公因数是所有公因数的倍数。 得证。 扩展欧几里得算法与其证明 欧拉函数与欧拉定理 欧拉函数 如果两个正整数，除了 1 以外，没有其他公因数，我们就称这两个数是互质关系。两个数互质，不说明两个数是质数。 给定一个数 nnn，求出在小于 nnn 的数中有多少个与 nnn 互质，这就是欧拉函数 φ(n)\\varphi (n)φ(n)。 在欧拉函数的第一步中，我们就计算了 nnn 的欧拉函数值 φ(n)=(p−1)(q−1)\\varphi (n)=(p-1)(q-1)φ(n)=(p−1)(q−1)。 欧拉函数函数式的推导： 分情况讨论： n=1：φ(1)=1\\varphi(1) =1φ(1)=1。1 与任何数都互质。 n 为质数：φ(n)=n−1\\varphi(n) =n-1φ(n)=n−1。不难想到，互质的两个数中，若大的为质数，那么二者必然互质，因为质数只有两个因数。 n=pk (k&gt;0)n = p^k\\ (k&gt;0)n=pk (k&gt;0)，即 nnn 是一质数 ppp 的某一次方幂： φ(n)=pk−pk−1=pk(1−1p)\\begin{aligned} \\varphi(n) &amp;=p^k-p^{k-1}\\\\ &amp;= p^k(1-\\frac{1}{p}) \\end{aligned} φ(n)​=pk−pk−1=pk(1−p1​)​ 这是因为小于 pkp^kpk 的数中，1×p,2×p…pk−1×p1\\times p,2\\times p\\dots p^{k-1}\\times p1×p,2×p…pk−1×p 共计 pk−1p^{k-1}pk−1 个数都有质数 ppp 做因数，需要剔除。 第二种情况是第三种情况的特殊情况。 n=p1×p2n = p_1\\times p_2n=p1​×p2​，即 nnn 是两互质整数的积： φ(n)=φ(p1)φ(p2)\\varphi(n) =\\varphi(p_1)\\varphi(p_2) φ(n)=φ(p1​)φ(p2​) 证明需要用到中国剩余定理。 nnn 是一般的正整数，通过质因数分解，其可以化为 n=p1k1p2k2p3k3…pmkmn=p_1^{k_1}p_2^{k_2}p_3^{k_3}\\dots p_m^{k_m}n=p1k1​​p2k2​​p3k3​​…pmkm​​。那么有： φ(n)=φ(p1)φ(p2)⋯φ(pm) (情况4)=p1k1p2k2…pmkm×(1−1p1)(1−1p2)⋯(1−1pm) (情况3)=n(1−1p1)(1−1p2)⋯(1−1pm)\\begin{aligned} \\varphi(n) &amp;= \\varphi(p_1)\\varphi(p_2)\\cdots\\varphi(p_m)\\ (情况4)\\\\ &amp;= p_1^{k_1}p_2^{k_2}\\dots p_m^{k_m}\\times(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m})\\ (情况3)\\\\ &amp;=n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_m}) \\end{aligned} φ(n)​=φ(p1​)φ(p2​)⋯φ(pm​) (情况4)=p1k1​​p2k2​​…pmkm​​×(1−p1​1​)(1−p2​1​)⋯(1−pm​1​) (情况3)=n(1−p1​1​)(1−p2​1​)⋯(1−pm​1​)​ 欧拉定理（不证） 有了欧拉函数，我们可以有欧拉定理，对于互质的两个数 a,na,na,n： aφ(n)≡1mod (n)a^{\\varphi(n)}\\equiv 1\\mod(n) aφ(n)≡1mod(n) 若 a,pa,pa,p 互质，那么有 ap−1≡1mod (n)a^{p-1}\\equiv 1\\mod(n) ap−1≡1mod(n) 这就是费马小定理 欧拉定理这里不证。 RSA 的有效性证明 为什么 RSA 这样进行加密可以保证解密后一定是原文？下面给出证明。 根据【加密】一节，可以知道，密文 ccc 和mem^eme 之间差距为若干个 nnn: c=me+knc= m^e+kn c=me+kn 代入【解密】中的公式，有： (me+kn)d≡mmod (n)(m^e+kn)^d\\equiv m \\mod(n) (me+kn)d≡mmod(n) 左侧多项式展开后，所有含 knknkn 的项都可被 nnn 整除，不影响余数。于是等价为： med≡mmod (n)m^{ed}\\equiv m\\mod(n) med≡mmod(n) 根据【密钥生成】中第四步的公式 d⋅e+k⋅φ(n)=1d\\cdot e+ k\\cdot\\varphi(n)=1d⋅e+k⋅φ(n)=1 （为避免歧义，将 φ(n)\\varphi(n)φ(n) 的系数换了字母）代换： m1−kφ(n)≡mmod (n) ⟹ m⋅mφ(n)−k≡mmod (n)\\begin{aligned} m^{1-k\\varphi (n)}&amp;\\equiv m\\mod(n)\\\\ \\implies m\\cdot {m^{\\varphi (n)}}^{-k}&amp;\\equiv m\\mod(n) \\end{aligned} m1−kφ(n)⟹m⋅mφ(n)−k​≡mmod(n)≡mmod(n)​ 此时分情况讨论： m,nm,nm,n 互质，根据欧拉定理就有 mφ(n)≡1mod (n)m^{\\varphi(n)}\\equiv 1\\mod(n)mφ(n)≡1mod(n)，将 mφ(n)m^{\\varphi(n)}mφ(n) 代入就得证。 m,nm,nm,n 不互质。而 nnn 是两大素数的乘积，那么 mmm 的因子中必然有 p,qp,qp,q 中的一个而与另一个互质。假设 m,nm,nm,n 公因子为 ppp，mmm 与 qqq 互质，有： 两个素数不可能同时为公因子，这意味着 mmm 不小于 nnn，那么就无法正确【解密】了。 根据费马小定理： mφ(q)≡1mod (q)m^{\\varphi(q)}\\equiv 1\\mod(q) mφ(q)≡1mod(q) 于是根据欧拉函数以及前面提到的 d⋅e+k⋅φ(n)=1d\\cdot e+ k\\cdot\\varphi(n)=1d⋅e+k⋅φ(n)=1 推出： mφ(q)≡1mod (q)mq−1≡1mod (q)(mq−1)−k(p−1)≡1mod (q)m−kφ(n)≡1mod (q)med−1≡1mod (q)\\begin{aligned} m^{\\varphi(q)}&amp;\\equiv 1\\mod(q)\\\\ m^{q-1}&amp;\\equiv 1\\mod(q)\\\\ {(m^{q-1})}^{-k(p-1)}&amp;\\equiv 1\\mod(q)\\\\ {m^{-k\\varphi(n)}}&amp;\\equiv 1\\mod(q)\\\\ m^{ed-1}&amp;\\equiv 1\\mod(q)\\\\ \\end{aligned} mφ(q)mq−1(mq−1)−k(p−1)m−kφ(n)med−1​≡1mod(q)≡1mod(q)≡1mod(q)≡1mod(q)≡1mod(q)​ 于是设 m=r⋅pmed−1=t⋅q+1m = r\\cdot p\\\\ m^{ed-1}=t\\cdot q+1 m=r⋅pmed−1=t⋅q+1 那么 med−1=tq+1med=tq⋅m+mmed=tq⋅(r⋅p)+mmed=tr⋅pq+mmed=tr⋅n+m ⟹ med≡mmod (n)\\begin{aligned} m^{ed-1}&amp;= tq+1\\\\ m^{ed}&amp;= tq\\cdot m+m\\\\ m^{ed}&amp;= tq\\cdot (r\\cdot p)+m\\\\ m^{ed}&amp;= tr\\cdot pq+m\\\\ m^{ed}&amp;= tr\\cdot n+m\\\\ \\implies m^{ed}&amp;\\equiv m \\mod(n)\\\\ \\end{aligned} med−1medmedmedmed⟹med​=tq+1=tq⋅m+m=tq⋅(r⋅p)+m=tr⋅pq+m=tr⋅n+m≡mmod(n)​ 得证。","categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"}]},{"title":"配置 WSL 与 WSA","slug":"配置WSL与WSA","date":"2023-12-10T09:40:37.000Z","updated":"2024-04-20T18:58:06.488Z","comments":true,"path":"post/20231210174037.html","permalink":"http://example.com/post/20231210174037.html","excerpt":"前言 其实很久之前配过，但是有奇奇怪怪的问题，也没有完全搞懂，干脆重新配了一遍。","text":"前言 其实很久之前配过，但是有奇奇怪怪的问题，也没有完全搞懂，干脆重新配了一遍。 WSL 的配置 首先为啥要搞 WSL： 好玩； 一个更方便也更有更强性能的 linux 系统，例如可以使用 Terminal 应用统一管理 shell。 我会使用目前最新的 Windows 11 配置 WSL 2，这也是目前主流的 WSL，如果你想了解 WSL 1，请参考官方文档。 下面是具体步骤。 安装 WSL 打开Terminal，使用命令 wsl --install 安装默认最新的 Ubuntu，或者直接的 Microsoft Store 搜索对应发行版安装需要的版本即可。 如果是想要安装其它的发行版本，使用 wsl --list --online 检查可用的官方发行版，然后用 wsl --install -d &lt;DistroName&gt; 安装对应的发行版。 如果有之前搞崩的了的版本需要卸载，需要使用 wsl --unregister &lt;DistributionName&gt;，才能清楚所有个人信息，直接在 windows 中卸载是不会删除个人数据的。 然后你就得到了一个崭新的 Ubuntu。输入账号密码即可创建你的账户。 Terminal 启动会自动登录该账户，所以我不建议你设一个巨复杂的密码。毕竟如果是不常用很容易忘，而且要安全你应该首先就不应该让别人接触到你的 Windows 账户。 此后，Terminal 中输入 WSL/Ubuntu或直接在开始菜单中输入上述字符串都可以直接启动 WSL 了。 配置 WSL 使用 sudo apt update &amp;&amp; sudo apt upgrade 更新包； 使用 git --version 检查是否有 git，现在应该是自带的； VSCode“远程”连接到WSL：在 VSCode 中安装 Remote Development 扩展包，然后在 VSC 命令面板选择连接到 WSL，即可在 VSC 中打开 WSL 文件夹进行开发等操作。也可以在 WSL 的对应路径下输入 code .，VSC 会自动启动并连接到 WSL 定位到该目录下。把后面的 . 换成对应的相对路径也是可行的。 安装一些 GUI 应用： 文本编辑器 gnome-text-editor：sudo apt install gnome-text-editor -y 文件管理器 nautilus：sudo apt install nautilus -y 火狐浏览器：sudo apt install firefox 安装后可能会出现闪屏的现象，一开始以为是驱动的问题，不过驱动实际上是不需要动或者说动不了的，重启一下就好了。 安装中文字体，不然无法显示: sudo apt-get install fonts-wqy-microhei # 安装文泉驿微米黑字体 sudo apt-get install fonts-wqy-zenhei # 安装文泉驿正黑字体 sudo apt-get install xfonts-wqy # 安装文泉驿点阵宋体 设置代理，也许你能参考为 WSL2 一键设置代理 - 知乎，但是我使用 Clash 是目前没有配成功。 基本上你可以完全参考 适用于 Linux 的 Windows 子系统文档 | Microsoft Learn 中从“概述”到“教程”这几节的东西完成配置，只不过中文本地化的问题会有些麻烦。而且我目前没找到中文输入的手段，只不过由于能直接 Windows 复制粘贴到 WSL，这也就是一个麻烦，不至于成为无法完成的事情。 WSA 的配置 WSA 使用 Amazon Appstore （而不是Google Play）作为官方应用商店，直接在 Microsoft Store 中搜索 Amazon Appstore 进行下载即可自动安装。 由于 Amazon Appstore 相当垃圾，不仅需要美区 Amazon 号还 app 数量少，所以可以考虑下面的方法启动侧载。 首先在 Windows Subsystem for Android 中高级设置中启用开发者模式，点击管理开发者选项启用USB 调试。在 Windows Terminal中输入adb devices 检查现在是否有被 adb 连接的设备。你也可以直接通过 adb 安装 app，但是更方便的办法是通过软件完成。在 Microsoft Store 中下载 WSATools 或者其它类似的软件，启动并选择对应的应用 apk 就可以进行安装了。这样的安装本质也是通过 adb 的，因此你可能需要在弹窗中授予权限。 这部分写得很简略是因为我 WSA 重新配置的过程比较简单，如果你想要更细致的教程，这里是我参考的文章： 【微软官方】如何安装WSA（附通过ADB安装应用） - 知乎 此外，你也许也需要下面两个文档： 适用于 Android™️ 的 Windows 子系统 | Microsoft Learn Android 调试桥 (adb) | Android 开发者 | Android Developers 我不是 Android 开发者，WSA 对我最主要的应用是游戏挂机，现在手游的空间对对我的 128G 千元机实在有些艰巨。几个月前，WSA 出现了奇妙的问题导致游戏无法正常更新，于是催生我一口气干脆把 WSA 和 WSL 重新配了一遍。其实不难，但是我还是了一点感悟，那就是重装是真有用啊。WSA 游戏无法正常更新（但是网易云app 可以正常联网）的 bug 在重装 WSA 后就轻松消失了。","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"WSA","slug":"WSA","permalink":"http://example.com/tags/WSA/"},{"name":"配置环境","slug":"配置环境","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"给Obsidian搭建自己的云同步服务","slug":"给Obsidian搭建自己的云同步服务","date":"2023-12-03T09:33:12.000Z","updated":"2024-04-20T18:58:06.478Z","comments":true,"path":"post/20231203173312.html","permalink":"http://example.com/post/20231203173312.html","excerpt":"前言 阿里云服务器 + docker + self-hosted Sync 插件给 Obsidian 搭建实时同步服务。","text":"前言 阿里云服务器 + docker + self-hosted Sync 插件给 Obsidian 搭建实时同步服务。 前几天准备给自己的武汉之旅写一篇很————长————的回忆记，但是这篇后来发现超过 5000 字的文章要是用手机码就麻烦了。原先 Obsidian 在我手里的定位就是手机便签加强版，根本没有考虑过同步的功能，现在为了写这个游记，只好开始想办法进行同步了。于是最后我就找到了博主&quot;吕楪&quot;的这一篇：Obsidian免费的实时同步服务。 很不幸，由于 fly.io 的政策改动，现在（2023年12月3日）它必须要求你有一个信用卡（而且非双币卡我怀疑不能认可），而且根据评论区消息，他们需要 $2/月 购买 IPv4 地址才能提供服务。既然如此，那么就不如自己在国内搞一个服务器了。 阿里云的学生福利允许通过任务最高领取 7 个月的免费 2 核 2G 服务器，即使不是学生，现在（2023年12月3日）腾讯云和阿里云也都有 100 元左右的 2 核 2G 服务器可以优惠购买。尽管这个价格和官方服务是差不多价格的，但是同步服务占用不大，因此性价比会比官方服务高很多。毕竟还可以跑其他的小东西玩呢。因此，我最后决定使用阿里云的云服务器部署同步服务，实现了 Windows + 安卓的实时同步功能。 下面正式开始论述步骤。 在开始配置同步前，最好将其它的同步插件（含官方插件），以及 Onedrive 等同步方式关闭，避免冲突问题。 配置服务器 我们的目标是在服务器上运行一个 CouchDB 数据库。 CouchDB 是 Apache 开发的一个开源 NoSQL 数据库，它使用 JSON 文档存储数据，通过 web 访问，使用JavaScript查询、合并和转换文档。 首先，你需要有一个服务器。我的意思是，像腾讯云 Cloudbase 云开发这样的 Serverless 产品，后台是腾讯云内建的数据库，需要通过 API 读写，就应该是不行的。（为什么我会知道这个呢） 参考云服务器的官方文档（可参见文末参考部分），连接到服务器，我这里使用的是 Workbench，主要是这个连接方式支持复制粘贴并且无需下载客户端。 随后参考另一篇云服务器官方文档（下述文档等均可参见文末参考部分），安装 Docker 和 docker-compose。 在 livesync 的官方文档中说道，“设置 CouchDB 的最简单方法是使用 CouchDB docker image”，并且推荐使用同时启动 Caddy 和 CouchDB 的另一方法。因此，这里安装了 Docker 和 docker-compose。 在服务器上，使用 mkdir 命令在合适的地方创建一个文件作为 CouchDB 容器的数据文件夹。在该文件夹下，使用 touch 命令创建一个名为 local.ini 的文件，这是要修改数据库以让它可以用于 Self-hosted LiveSync。使用 vim 或任何其他编辑器打开并粘贴以下内容： 12345678910111213141516171819202122[couchdb]single_node=truemax_document_size = 50000000[chttpd]require_valid_user = truemax_http_request_size = 4294967296[chttpd_auth]require_valid_user = trueauthentication_redirect = /_utils/session.html[httpd]WWW-Authenticate = Basic realm=&quot;couchdb&quot;enable_cors = true[cors]origins = app://obsidian.md,capacitor://localhost,http://localhostcredentials = trueheaders = accept, authorization, content-type, origin, referermethods = GET, PUT, POST, HEAD, DELETEmax_age = 3600 再在该文件夹下创建一个 docker-compose.yml 文件，打开，贴入以下内容 123456789101112131415version: &quot;2.1&quot;services: couchdb: image: couchdb container_name: obsidian-livesync user: 1000:1000 environment: - COUCHDB_USER=admin - COUCHDB_PASSWORD=password volumes: - ./data:/opt/couchdb/data - ./local.ini:/opt/couchdb/etc/local.ini ports: - 5984:5984 restart: unless-stopped ❗请根据需要修改文中 ./local.ini 、environment 以及 container_name ，的值。 运行下面这个命令 1docker compose up -d docker 就会自动拉取 couchDB 镜像并配置好。 运行下面这个命令，检查容器是否已经开始运行 1docker ps 如果看到了前面设置的 container_name ，那么容器已经在运行了。由于服务器没有图形化窗口，这里需要转到阿里云的实例的安全组中， 给“入方向”添加 5984 端口，允许外界访问服务器的 5984 端口。 下面转到本地操作。 在网页端创建数据库 在 PC 上访问 http://[你的服务器公网IP]:5984/_utils。你应该就能看见图形化界面了。 如果拒绝访问，你可能需要写成这种形式http://[你的用户名]:[你的密码]@[你的服务器公网IP]:5984/_utils。这里的用户名和密码都是前面的 docker-compose.yml 中设置的。 点击网页右上角的 Create Database，创建一个数据库，其中 Database name 为数据库名字，Partitioned 不应该被勾选，然后点 Create 创建。 接着点开图标为扳手🔧的 Setup 选项卡，依次填入上述配置的管理员姓名和密码凭据，Bind address 一栏应保持为 0.0.0.0 才能允许所有的 IP 访问，最后，端口写 5984。 最后，点开齿轮⚙️图标的 Config 选项卡，点选 CORS，启用，允许直接从浏览器连接到远程服务器并与 CouchDB 对话以加载数据。 页面可能会提示报错，你需要刷新页面检查确实是启用并设置为 All domains 的就可以。 配置 Obsidian 在 Obsidian 本体软件中关闭安全模式，安装插件 Self-hosted LiveSync 并启用。 打开卫星图标🛰️的 Remote Database configuration 选项卡。输入自己的数据库网址、用户名、密码与数据库名。数据库网址形如：http://[你的服务器IP地址]:5984，用户名、密码与数据库名都是在上一节数据库网页设定的。 点击 Test Database Connection，若连接成功，则会提示 connected，否则，会提示那些步骤存在问题，按描述检查即可。 打开循环图标🔁的 Sync Settings 选项卡，将 Sync Mode 调整为 Live Sync，这样就是实时的同步，而非定时或定节点的保存。 一些建议设置： 在 Sync Settings 选项卡中启用 Use Trash for deleted files，启用回收站而非直接删除； 在齿轮图标⚙️的 General Settings中，检查启用 Show staus inside editor 💤：表示目前一切就绪 ⚡：表示正在同步 ⚠️：同步出现错误 ↑和↓：表示本次启动以来上传和下载了多少数据 其它的图标感觉都不大容易碰到，这里略过。 在卫星图标🛰️的 Remote Database configuration 选项卡中的 Confidentiality 启用端到端加密和路径混淆（Path Obfuscation）并配置加密密码，保护数据。（可能会导致重建数据库） 配置第二台设备 继续在上述已经配好的设备的 LiveSync插件上，点选魔法师图标的🧙 Setup Wizard选项卡，点选Copy Setup URI，输入一个加密密码，生成口令。将其发送到我们需要设置的另一设备。 在第二台设备（例如安卓手机）上，打开同样的选项卡，点击Open Setup URI，依次输入口令和加密码进行解密。选择“将其设置为第二或后续设备”，最后同样点击 Test Database Connection 检查确实已经连接成功即可。 接下来就可以通过创建文件，打几段话试试同步效果，最后继续写作之旅了。 参考和推荐阅读 本文的主要参考对象，吕楪的博客，有一些细节比本文更丰富（毕竟中译中就没意思了）：Obsidian 免费的实时同步服务 插件官方提供的设置 CouchDB 教程（顺便一提官方的其它中文文档也值得一看）：obsidian-livesync/docs/setup_own_server_cn.md at main · vrtmrz/obsidian-livesync 如果你想了解其它的同步方式，同样是吕楪大佬的：Obsidian 各种同步方式体验 另一篇关于 Obsidian 不同同步方式的文章：Obsidian 免费同步方案 - 知乎 了解如何连接到服务器（阿里云）：云服务器ECS连接方式介绍与对比_云服务器 ECS-阿里云帮助中心 在阿里云（CentOS 或 Alibaba Cloud Linux）云服务器上安装 Docker：安装Docker并使用_云服务器 ECS-阿里云帮助中心","categories":[],"tags":[{"name":"Obsidian","slug":"Obsidian","permalink":"http://example.com/tags/Obsidian/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"数据库大作业：公交管理系统","slug":"课程报告/数据库大作业：公交管理系统","date":"2023-11-12T10:13:07.000Z","updated":"2024-04-20T18:58:06.487Z","comments":true,"path":"post/20231112181307.html","permalink":"http://example.com/post/20231112181307.html","excerpt":"前言 因为在复习数据库，整理下大三数据库大作业。","text":"前言 因为在复习数据库，整理下大三数据库大作业。 环境配置 需要一个简单的前端，这里使用的是 python38 + Flask(简单的 web 框架) + psycopg2(PostgreSQL 数据库适配器) ，这就没什么好说的了。对应有一小段 python 代码和 html，css 代码，我前端苦手，这些前端功能是直接拿的同学的，因此这里也不多谈。python 代码可以见后。 当然需要一个数据库软件，我们选择的是 PostgreSQL。参考 Windows 10平台安装PostgreSQL 14.2详细教程 - 知乎 就行。在我重新完善这个实验的时候，使用的版本是 16。下面阐述一些细节。 安装过程中我遇到了上述链接阐述的初始化失败的问题，可以安装上述博主提供的命令行代码手动初始化即可。 在网上的教程中，往往是使用 psql 命令行交互，不过，事实上 PostgreSQL 包含一个名为 pgAdmin 的可视化窗口，因此我就直接使用了可视化操作进行了。 在我的电脑上，PostgreSQL 服务器不会自启动，也无法在 service 中找到，因此我需要通过命令手动启动服务器： 1./bin/pg_ctl.exe -D &quot;C:\\\\PostgreSQLDataArea&quot; start 其中，第一个地址是指定软件安装目录下的 pg_tcl.exe, 第二个目录则是指明服务器数据的存放地址，默认是安装目录下 data 文件夹，但是我给它改了。如果你的 pg_ctl 被包含在了环境目录中，那么第一串就可以直接写成 pg_ctl。 启动服务器后就可以在 pgAdmin 中去连接服务器，创建数据库了。 设计数据库 显然这一步才是整个作业的关键 首先回顾作业的要求： 公交车公司架构如下： 公交公司有若干个【车队】，每个【车队】下有若干条【线路】; 公交公司有若干辆【汽车】，每辆【车】属于一条【线路】; 每个【车队】有一名【队长】，他只有管理工作，不开车; 每条【线路】有若干名【司机】；每名【司机】只在一条【线路】上开车; 【司机】开车时会产生【违章】，包含: 闯红灯、未礼让斑马线、压线、违章停车等; 【队长】、【路队长】负责将司机的违章信息输入到系统，包含: 司机、车辆、车队、线路、站点、时间、违章等 公交公司管理系统要求功能如下： 录入司机信息 录入汽车信息 录入违章信息 查询车队拥有的司机 查询时间段内实际信息 查询车队违章信息 对此，数据库的结构大体思路如下： 有车队、线路、站点、汽车、员工等表存储信息，有“违章类型表”和“违章信息表”表示违章信息。特别地，线路和站点之间是多对多的关系，而且有顺序要求，因此我们还要建立一个“线路-站点”关联表。具体的 SQL 语句见后。 接下来对数据库进行范式分析： 1NF：属性不可被分解。不满足 1NF 就不是数据库，因此我们的数据库显然是满足的； 2NF：非主属性完全依赖主键。满足。 3NF：非主属性不存在传递依赖。满足。 BC范式：主属性没有传递依赖和部分依赖。满足。 代码 建表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109-- 汽车表CREATE TABLE &quot;buses&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;number&quot; varchar(16) UNIQUE, &quot;route_id&quot; int4, &quot;capacity&quot; int4 NOT NULL, CHECK (number SIMILAR TO &#x27;[京津冀晋蒙辽吉黑沪苏浙皖闽赣鲁豫鄂湘粤桂琼渝川贵云藏陕甘青宁新][A-HJ-NP-Z][A-HJ-NP-Z0-9]&#123;5,6&#125;&#x27;) -- 检查车牌号格式);-- 车队表CREATE TABLE &quot;fleets&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;leader_id&quot; int4 NOT NULL);-- 违章类型表CREATE TABLE &quot;offence_types&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;type&quot; varchar(255) NOT NULL UNIQUE);-- 路线表CREATE TABLE &quot;routes&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;leader_id&quot; int4 UNIQUE, &quot;fleet_id&quot; int4);-- 站点表CREATE TABLE &quot;stops&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;name&quot; varchar(255) NOT NULL UNIQUE);-- 路线-站点表CREATE TABLE &quot;route-stops&quot; ( &quot;route_id&quot; int4 NOT NULL, &quot;order&quot; int4 NOT NULL, &quot;stop_id&quot; int4 NOT NULL, PRIMARY KEY (&quot;route_id&quot;, &quot;order&quot;));-- 员工表CREATE TABLE &quot;workers&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;name&quot; varchar(255) NOT NULL, &quot;gender&quot; varchar(2) NOT NULL, &quot;is_driver&quot; bool NOT NULL DEFAULT false, &quot;route_id&quot; int4, CHECK (gender = &#x27;男&#x27; or gender = &#x27;女&#x27;));-- 违章表CREATE TABLE &quot;offences&quot; ( &quot;id&quot; int4 PRIMARY KEY GENERATED ALWAYS AS IDENTITY, &quot;driver_id&quot; int4 NOT NULL, &quot;time&quot; timestamp NOT NULL, &quot;bus_id&quot; int4 NOT NULL, &quot;stop_id&quot; int4 DEFAULT NULL, &quot;offence_type_id&quot; int4 NOT NULL);-- 外键ALTER TABLE buses ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE fleets ADD FOREIGN KEY (leader_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (offence_type_id) REFERENCES offence_types (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (driver_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (bus_id) REFERENCES buses (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE offences ADD FOREIGN KEY (stop_id) REFERENCES stops (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE routes ADD FOREIGN KEY (leader_id) REFERENCES workers (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE routes ADD FOREIGN KEY (fleet_id) REFERENCES fleets (id) ON DELETE SET NULL ON UPDATE CASCADE;ALTER TABLE &quot;route-stops&quot; ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE SET NULL;ALTER TABLE &quot;route-stops&quot; ADD FOREIGN KEY (stop_id) REFERENCES stops (id) ON DELETE SET NULL ON UPDATE SET NULL;ALTER TABLE workers ADD FOREIGN KEY (route_id) REFERENCES routes (id) ON DELETE SET NULL ON UPDATE CASCADE;-------- 视图 ---------- 不同车队的驾驶员基本信息CREATE VIEW &quot;fleet-driver&quot;(fleet_id, driver_id, driver_name, driver_gender)ASSELECT fleets.id, workers.id, workers.name, workers.genderFROM fleets INNER JOIN routes ON fleets.id = routes.fleet_id INNER JOIN workers ON routes.id = workers.route_idWHERE workers.is_driver;-- 不同驾驶员的违章信息CREATE VIEW &quot;driver-offence&quot;(driver_id, offence_time, bus_number, stop_name, offence_type, offence_id)ASSELECT offences.driver_id, offences.time, buses.number, stops.name, offence_types.type, offences.idFROM offences INNER JOIN buses ON offences.bus_id = buses.id INNER JOIN stops ON offences.stop_id = stops.id INNER JOIN offence_types ON offences.offence_type_id = offence_types.id;-- 不同车队的违章信息CREATE VIEW &quot;fleet-offence&quot;(fleet_id, offence_time, offence_type)ASSELECT &quot;fleet-driver&quot;.fleet_id, offences.time, offence_types.typeFROM offences INNER JOIN offence_types ON offences.offence_type_id = offence_types.id INNER JOIN &quot;fleet-driver&quot; ON offences.driver_id = &quot;fleet-driver&quot;.driver_id; python 前端 访问 localhost:5000/BusCompanyManage 网站即可，注意修改 python 代码中的数据库用户名、密码等信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#! python3.8import tracebackfrom flask import Flask, render_template, requestimport psycopg2# 连接数据库conn = psycopg2.connect( database=&#x27;bus_company_db&#x27;, user=&#x27;postgres&#x27;, password=&#x27;password&#x27;, host=&#x27;127.0.0.1&#x27;, port=&#x27;5432&#x27;)# 数据库操作游标cur = conn.cursor()def queryDb(sql: str): &#x27;&#x27;&#x27; 通过SQL语句查询数据库，返回查询结果。 &#x27;&#x27;&#x27; cur.execute(sql) conn.commit() return cur.fetchall()def modifyDb(sql: str): &#x27;&#x27;&#x27; 通过SQL语句修改数据库。 &#x27;&#x27;&#x27; cur.execute(sql) conn.commit() def insertDriver(form): &#x27;&#x27;&#x27; 录入司机基本信息，如工号、姓名、性别等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO workers(name, gender, is_driver, route_id) VALUES(&#x27;&#123;form[&#x27;name&#x27;]&#125;&#x27;, &#x27;&#123;form[&#x27;gender&#x27;]&#125;&#x27;, TRUE, &#123;form[&#x27;route_id&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM workers ORDER BY id DESC;&#x27; return queryDb(sql)def insertBus(form): &#x27;&#x27;&#x27; 录入汽车基本信息，如车牌号、座数等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO buses(number, route_id, capacity) VALUES(&#x27;&#123;form[&#x27;number&#x27;]&#125;&#x27;, &#123;form[&#x27;route_id&#x27;]&#125;, &#123;form[&#x27;capacity&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM buses ORDER BY id DESC;&#x27; return queryDb(sql)def insertOffence(form): &#x27;&#x27;&#x27; 录入司机的违章信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;INSERT INTO offences(driver_id, time, bus_id, stop_id, offence_type_id) VALUES(&#x27;&#123;form[&#x27;driver_id&#x27;]&#125;&#x27;, &#x27;&#123;form[&#x27;time&#x27;]&#125;&#x27;, &#123;form[&#x27;bus_id&#x27;]&#125;, &#123;form[&#x27;stop_id&#x27;] or &#x27;NONE&#x27;&#125;, &#123;form[&#x27;offence_type_id&#x27;]&#125;);&#x27;&#x27;&#x27; modifyDb(sql) sql = &#x27;SELECT * FROM offences ORDER BY id DESC;&#x27; return queryDb(sql)def queryFleetDrivers(form): &#x27;&#x27;&#x27; 查询某个车队下的司机基本信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT driver_id, driver_name, driver_gender FROM &quot;fleet-driver&quot; WHERE fleet_id = &#123;form[&#x27;fleet_id&#x27;]&#125;;&#x27;&#x27;&#x27; return queryDb(sql)def queryDriverOffences(form): &#x27;&#x27;&#x27; 查询某名司机在某个时间段的违章详细信息。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT offence_time, bus_number, stop_name, offence_type, offence_id FROM &quot;driver-offence&quot; WHERE driver_id = &#123;form[&#x27;driver_id&#x27;]&#125; AND offence_time BETWEEN &#x27;&#123;form[&#x27;start_time&#x27;]&#125;&#x27; AND &#x27;&#123;form[&#x27;end_time&#x27;]&#125;&#x27;;&#x27;&#x27;&#x27; return queryDb(sql)def queryFleetOffences(form): &#x27;&#x27;&#x27; 查询某个车队在某个时间段的违章统计信息，如：2次闯红灯、4次未礼让斑马线等。 &#x27;&#x27;&#x27; sql = f&#x27;&#x27;&#x27;SELECT offence_type, COUNT(*) FROM &quot;fleet-offence&quot; WHERE fleet_id = &#123;form[&#x27;fleet_id&#x27;]&#125; AND offence_time BETWEEN &#x27;&#123;form[&#x27;start_time&#x27;]&#125;&#x27; AND &#x27;&#123;form[&#x27;end_time&#x27;]&#125;&#x27; GROUP BY offence_type;&#x27;&#x27;&#x27; return queryDb(sql)actionTypes = &#123; &#x27;ins-driver&#x27;: [insertDriver, [&#x27;编号&#x27;, &#x27;姓名&#x27;, &#x27;性别&#x27;, &#x27;是否为司机&#x27;, &#x27;路线编号&#x27;]], &#x27;ins-bus&#x27;: [insertBus, [&#x27;编号&#x27;, &#x27;车牌号&#x27;, &#x27;路线编号&#x27;, &#x27;载客量&#x27;]], &#x27;ins-offence&#x27;: [insertOffence, [&#x27;司机编号&#x27;, &#x27;时间&#x27;, &#x27;车辆编号&#x27;, &#x27;站点编号&#x27;, &#x27;违章类型号&#x27;, &#x27;违章编号&#x27;]], &#x27;qry-fleet-driver&#x27;: [queryFleetDrivers, [&#x27;编号&#x27;, &#x27;姓名&#x27;, &#x27;年龄&#x27;]], &#x27;qry-driver-offence&#x27;: [queryDriverOffences, [&#x27;违章时间&#x27;, &#x27;车牌号&#x27;, &#x27;站点&#x27;, &#x27;违章类型&#x27;, &#x27;编号&#x27;]], &#x27;qry-fleet-offence&#x27;: [queryFleetOffences, [&#x27;类型&#x27;, &#x27;次数&#x27;]]&#125;app = Flask(__name__)@app.route(&#x27;/BusCompanyManage&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def manage(): msg = None thead = None tbody = None try: if request.method == &#x27;GET&#x27;: msg = &#x27;欢迎来到公交安全管理系统。&#x27; elif request.method == &#x27;POST&#x27;: msg = &#x27;提交成功！&#x27; form = request.form action = form[&#x27;type&#x27;] tbody = actionTypes[action][0](form) thead = actionTypes[action][1] except Exception: msg = traceback.format_exc() return render_template( &#x27;index.html&#x27;, msg=msg, thead=thead, tbody=tbody )if __name__ == &#x27;__main__&#x27;: app.run(debug=True)","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大作业","slug":"大作业","permalink":"http://example.com/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"}]},{"title":"A 测实验：湿度测控系统仿真 / 嵌入式","slug":"课程报告/A测：湿度测控仿真","date":"2023-10-05T15:35:20.000Z","updated":"2024-04-20T18:58:06.480Z","comments":true,"path":"post/20231005233520.html","permalink":"http://example.com/post/20231005233520.html","excerpt":"前言 A 测实验报告，实现一个根据湿度控制电机转动的简单嵌入式系统的仿真。此前没有接触过嵌入式，这也是我对嵌入式的初步认识。","text":"前言 A 测实验报告，实现一个根据湿度控制电机转动的简单嵌入式系统的仿真。此前没有接触过嵌入式，这也是我对嵌入式的初步认识。 实验要求 使用 Arduino UNO 微控制器，搭建一个 PC 上位机远程湿度检测控制系统。 具体来说功能可以分为如下两部分： 通信：串口和 Arduino UNO 系统双工通信。我们操作通过串口向仿真系统发送学号。同时，我们还可以从串口读取当前湿度。 反馈：当环境湿度低于等于预定的湿度时， Arduino UNO 启动直流电机转动；当环境湿度高于预定的湿度时，直流电机停止转动。 Arduino UNO 还会在 LCD 屏上显示之前输入的学号和湿度。 上述预定湿度的值为百分之“30+学号末位数”。 软件环境：推荐采用 Proteus 8.9 SP2 及以上仿真软件，Arduino IDE，串口调试助手软件，虚拟串口驱动软件 Virtual Serial Port Driver（VSPD）。 所谓微控制器，是一个高度集成的芯片，内部有 CPU 、内存等等，对外则提供各类接口，单片机也是一种微控制器，而 Arduino UNO 微控制器的核心是一个 Atmega328P 单片机。 Arduino 平台也有对应的软件开发工具，例如官方的 Arduino IDE。采用 VSC 等当然也可以，不过我们只是做一次作业，也就不花心思在如何配环境了。总之，透过这些软件，我们可以编写代码输送到开发板（此处是 Arduino UNO）中去执行。 而上述提到的串口则是“串行端口”的意思，具体来说，我们这里指的是 COM 口，即 Commuinication Port。串口通信较为简单而稳定。 整体系统框图如下： 实验环境 Windows 11 个人电脑 Proteus 8.9 SP2：仿真软件，老师提供的电路就是 Proteus 工程文件。 XCOM 2.0：用来在串口上进行通信的； VSPD 7.2.308：Virtual Serial Port Dirver，用来创建虚拟一对端口的，因为我们的微控制器是虚拟的，所以与之通信的串口也是虚拟的； Arduino 1.8.19：给 Arduino 开发板编写程序的 IDE；这里需要注意版本问题，官网的 2.x 版本似乎是无法看到 VSPD 创建的虚拟端口的； DHT 11 库：DHT 11 数字温湿度传感器配套的库，因为我们是在 Arduino 平台进行开发，因此需要对应的在 Arduino 平台的库，在这里我采用的是 Github 上找的 adidax/dht11: DHT11 library for Arduino。 操作步骤 环境配置，安装上述软件，并将 DHT 11 库添加到 Arduino IDE 中。其中 Proteus 需要安装在 C 盘根目录下，不然会识别不到库。 通过 VSPD 添加一对虚拟串口 COM1 和 COM2 进行虚拟串联。 XCOM 设置波特率为 9600，测试虚拟端口之间能否正常通信；并保持 COM1 为打开状态。 我们没有可以上传的真实开发板，而验证本身并不会传到开发板中，所以我们设置 Arduino IDE 的首选项（Preference），将编译和上传勾选。随后在 Arduino IDE 内编写程序并&quot;验证&quot;（程序代码见后文）。控制台会告诉我们在appdata 下的一个文件下下生成了编译文件，其中该目录下的 *.ino.hex 就是验证后编译生成的机器码文件，它就是我们要的。（注意这是临时文件，每次验证目录都会变化）。 在 Proteus U1 里指定编译生成的 .HEX 文件，P1 指定端口为 COM1。 运行仿真工程，输入学号，调节湿度，观察电机状态和 LCD 显示信息。 仿真结果 我的学号尾号为2，因此预定的湿度值是 32%。 初始状态只显示湿度值： 此时通过 XCOM（COM2） 发送学号，可以看到 LCD 显示屏上成功显示学号，并且 PC 机接收到湿度值。注意 XCOM 使用的 COM 2 而且应该处于打开状态，因为与之配对的 COM1 在模拟开发板上，我们无法通过 COM1 给COM1 自己发消息。 将设定湿度改到 32%，此时电机开始转动： 程序代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# include &lt;Wire.h&gt;# include &lt;dht11.h&gt; # include &lt;LiquidCrystal.h&gt; # define DHT11PIN 6# define EMPIN 7 LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // 初始化LCDdht11 DHT11;String stuID = &quot;&quot;; int len, lastNumNum = 0;int setHumidity, realHumidity = 0; void setup() &#123; Serial.begin(9600); // 初始化串口波特率为9600 lcd.begin(16, 2); pinMode(EMPIN, OUTPUT); // 设置连接直流电机引脚工作模式&#125; void loop() &#123; DHT11.read(DHT11PIN); realHumidity = (int)DHT11.humidity; lcd.print(&quot;ID:&quot;); if (Serial.available() &gt; 0) &#123; // 串口接收到数据 while (Serial.available() &gt; 0) &#123; stuID += (char)Serial.read(); delay(10); &#125; lcd.println(stuID); len = stuID.length(); lastNum = stuID.substring(len - 3, len - 2).toInt(); // 取末尾数字 setHumidity = 30 + lastNum; stuID = &quot;&quot;; len = 0; lastNum = 0; &#125; // LCD 输出 RH lcd.setCursor(0, 1); // 将光标定位在第0列，第1行（即下一列） lcd.print(&quot;RH:&quot;); lcd.print(realHumidity); lcd.println(&quot;%&quot;); lcd.home(); // 光标返回左上角 // 串口输出 RH Serial.print(&quot;Humidity:&quot;); Serial.print(realHumidity); Serial.println(&quot;%&quot;); if (realHumidity &lt;= setHumidity) &#123; digitalWrite(EMPIN, HIGH); // 电机转动 &#125; else &#123; digitalWrite(EMPIN, LOW); &#125; delay(1000);&#125; 参考 2023西电A测：湿度测控仿真系统-CSDN博客 西电A测：串口通信仿真-CSDN博客","categories":[],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]},{"title":"C++ STL 容器与容器适配器","slug":"C++ STL 容器简记","date":"2023-08-19T10:13:32.000Z","updated":"2024-04-20T19:08:41.565Z","comments":true,"path":"post/20230819181332.html","permalink":"http://example.com/post/20230819181332.html","excerpt":"前言 C++ STL 容器与容器适配器简记，这是一篇用法与底层实现思想的简记，不含源码解析。","text":"前言 C++ STL 容器与容器适配器简记，这是一篇用法与底层实现思想的简记，不含源码解析。 顺序容器 主要有这些： 顺序容器 arrary:定长数组 vector：动态数组 deque ：双端队列 list：双向循环链表 forward_list：单向链表 STL 库中的容器（以及 String）有一些相似的方法和特点，例如使用operator=赋值或assign()赋值，用operator==可以判相等等等，下面是一些个人觉得常见的方法。不过这些方法也并不一定是对所有容器有效，应该根据实际容器的特点来。（例如对于一个定长的array，显然我们也没办法要求 resize()或者push） 迭代器： begin()：指向开始的迭代器 end()：指向末尾的迭代器 容量： size()：当前大小 empty()：是否为空 max_size：理论上的最大大小。例如对于vector是可用 RAM 大小，对 array 则是声明的大小。 元素访问： operator[]：C风格的下标访问 at()：operator[]的不越界安全替代品 front：第一个元素 back()：最后一个元素 以及修改操作： push(_back)：压入一个元素（到尾部） pop(_back)：弹出一个元素（从尾部） emplace()：原地构造一个元素放入（对于自定义类型，避免来回构造析构不必要的临时变量） swap()：交换 insert()：在指定位置前插入元素 resize()：重整大小，小于原值就删去那些元素 clear()：清空所有 erase()：清空指定位置元素 Array 这是对 C 中的简单的 int a[] 这样的数组的替代品，提高了安全性。因此它也如原始数组一样不能变长等。 fill()：用指定元素赋值。 Vector 动态长度的数组。 在中间和前方插入值会消耗较多的时间，因为要挨个挪后面的元素。 内存结构：vector所采用的数据结构非常简单，线性连续空间（即数组），两个迭代器 Myfirst和 Mylast 分别指向配置得来的连续空间中目前已被使用的范围，并以迭代器 _Myend 指向整块连续内存空间的尾端。 扩容：扩充空间是“配置新空间-数据移动-释放旧空间”的大工程,时间成本很高。因此当容器满的时候，vector 会另辟一段空间（大小为 2^N ），将旧空间的内容复制到新空间然后释放旧空间。如果容器内存放的是自定义类型，那么C++会使用 move 将所有权转移到新空间内，而不是挨个调用构造函数。 迭代失效：对 vector 的任何操作，一旦引起空间的重新分配，指向原 vector 的所有迭代器就都失效了。 Deque：双端队列 deque 容器可以对其两段的数据进行操作，支持随机访问。它不需要像 vector 那样重新配置空间来扩容，因此，deque 没有 capacity 属性，没有 reserve() 功能。 在前端插入删除和后端插入删除一样方便，但是中间会需要挪元素。 deque 容器存储数据的空间是由一段一段等长的连续空间（数组）构成，各段空间之间并不一定是连续的，可以位于在内存的不同区域。为了管理这些连续空间，deque 容器用数组存储着各个连续空间的首地址。也就是说，容器中实际存储的都是指针，指向那些真正用来存储数据的各个连续空间。 这提高了在序列两端添加或删除元素的效率，但也使容器迭代器的底层实现变得更复杂。 为了实现遍历 deque 容器的功能，deque 迭代器定义了如下的结构(迭代的是那个指针数组的元素)： 12345678template&lt;class T,...&gt;struct __deque_iterator&#123; ... T* cur; T* first; T* last; map_pointer node;//map_pointer 等价于 T**&#125; 迭代器内部包含 4 个指针，它们各自的作用为： cur：指向当前正在遍历的元素； first：指向当前连续空间的首地址； last：指向当前连续空间的末尾地址； node：指向指针数组中“指向当前连续空间的指针”。 其中： start 迭代器记录着 map 数组中首个连续空间的信息。start 迭代器中的 cur 指针指向的是连续空间中首个元素； finish 迭代器记录着 map 数组中最后一个连续空间的信息。 finish 迭代器中的 cur 指针指向的是连续空间最后一个元素的下一个位置。 1234567891011121314151617181920212223242526272829303132//当迭代器处于当前连续空间边缘的位置时，如果继续遍历，就需要跳跃到其它的连续空间中，该函数可用来实现此功能void set_node(map_pointer new_node)&#123; node = new_node;//记录新的连续空间在 map 数组中的位置 first = *new_node; //更新 first 指针 //更新 last 指针，difference_type(buffer_size())表示每段连续空间的长度 last = first + difference_type(buffer_size());&#125;//重载 * 运算符reference operator*() const&#123;return *cur;&#125;pointer operator-&gt;() const&#123;return &amp;(operator *());&#125;//重载前置 ++ 运算符self &amp; operator++()&#123; ++cur; //处理 cur 处于连续空间边缘的特殊情况 if(cur == last)&#123; //调用该函数，将迭代器跳跃到下一个连续空间中 set_node(node+1); //对 cur 重新赋值 cur = first; &#125; return *this;&#125;//重置前置 -- 运算符self&amp; operator--()&#123; //如果 cur 位于连续空间边缘，则先将迭代器跳跃到前一个连续空间中 if(cur == first)&#123; set_node(node-1); cur == last; &#125; --cur; return *this;&#125; 内存调度策略 如果 deque 数组的总空间大于目前使用空间的两倍，那么不会重新分配内存。 否则会使用 reallocate_map()函数, 空间不足时： deque空间实际足够：这种情况由总是在一个方向插值造成 deque内部进行调整 start , 和 finish 当 deque 后端缓存耗尽时， deque 会将start复制到中间； 当 deque 前端缓存耗尽时， deque 会从后往前复制，将 start 复制到中间。（如果不从后向前复制，那么 start 移动后可能会落在之前的区间内，这时进行复制会覆盖尚未被复制的后部数据）。 deque空间真的不足 申请更大的空间 拷贝元素过去 修改 map 和 start, finish 指向 如果 deque 数组总空间小于目前使用空间的两倍。那么其会根据下列公式计算扩增倍数。 1__new_size = _M_size+max(_M_size,__nodes_to_add)+2 可以看出是至少 2 倍扩容，通过比较当前 deque 数组大小与插入节点数，同时还预留一个为 2 的常数，防止频繁map的重新分配。 List：双向循环链表 list 就是一个双向循环链表，list 节点有 prev 和 next 两个指针。对于任何位置的元素插入或元素移除， list 永远是常数时间。 既然是链表，因此它有一些链表的特点 插入、接合操作，不会造成迭代器失效。即使删除操作，只有指向删除元素的那个迭代器失效。 无法随机存取，但是方便随机插入删除。 不预留空间，每分配一个就是内存中取一块地。 node 指向尾端的一个空白节点，就能符合 ”前闭后开“ 区间的要求。 Forward_list：单向链表 具有和 list 容器相同的特性，但是单链表只能从前向后遍历，而不支持反向遍历。 关联式容器 关联式容器大体可以分为 set 和 map ，有序的均是以RB-Tree（红黑树）为底层架构，无序的（ Unordered_ 前缀）以哈希表为底层架构。 set/multiset map/multimap unordered_set/map/multiset/multimap 关联容器插入删除效率比用其他序列容器高，因为对于关联容器来说，不需要做内存拷贝和内存移动。而是键-值映射。 除了顺序容器中提到的各种方法，关联式容器中还常有 count()：匹配指定键的元素个数。 find()：找指定键的元素。 merge()：从另一个容器合并结点。 equal_range()：等于给定键的元素范围（？）。 lower/upper_bound():首个不小于/大于指定键的元素的迭代器。（再次提醒是不小于，不是小于）。 contains()(c++20):是否包含指定键。 extract()（c++17）：从另一个容器提取结点。 Set/ Multiset：集合 元素既是键(value)又是值(value)。 键（即元素）是不可被修改的。 insert()函数插入之后会自行被排序，默认是升序 set 不可插入重复值，multiset 则可以； Map/Multimap：映射（键值对） 类比 python 中的字典，拥有键值（key）和实值（value） 所有元素都会根据键值来自动排序，当对它的容器元素进行新增操作或者删除操作时，操作之前的所有迭代器，在操作完成之后依然有效。 map 中不允许出现重复键值， multimap 中允许。 map 重载了operator[]，但是 multimap 没有，因为键是不唯一的。 由于 map 是键值对，因此定义了 pair，这是一个有两个值的简单模板结构体。其中第一个值（键）是 const，即键无法修改，值可以修改。它还重载了 operator== 、构造等。而 map 就是一个 pair 结构的红黑树。 Unordered_xxxx 上述四种容器在 C++11 后均增加了 unordered_ 类。其与上述四种容器的区别是底层实现原理为哈希表。 这造成了两点重要影响： 不支持排序，迭代器做范围访问时效率更低（迭代器自加自减的访问效率更低）； 直接访问元素的速度更快（尤其在规模很大时），因为直接计算 key 的哈希值是O(1)复杂度。 容器适配器 容器适配器是一个封装了序列容器的一个类模板，它在一般的序列容器的基础上提供了一些不同的功能。之所以称为容器适配器，是因为它是适配容器来提供其它不一样的功能。通过对应的容器和成员函数来实现我们需要的功能 stack：栈 栈是什么就不必多说了。默认情况下 stack 底层容器是 deque 。也可以指定底层容器，标准容器 vector、deque、list 均符合需求。 stack 不提供遍历和随机访问功能，也不提供迭代器。只有 push 和 pop 操作。 queue：队列 默认情况下 queue 底层容器是 deque。 队列是一种 FIFO 的数据结构，允许从一端新增元素，从另一端移除元素。 queue不提供遍历功能，也不提供迭代器。 pripority_queue：优先队列/堆 优先队列的默认容器是 vector。 优先队列的核心特点在于其严格弱序特性（strict weak ordering）：也即 priority_queue 保证容器中的第一个元素始终是所有元素中最大的。为此，用户在实例化一个 priority_queue 时，必须为元素类型重载&lt;运算符，以用于元素排序。 更进一步的认识 更进一步当然就是需要阅读源码，除了源代码，也可以参考 一个发表于Github的源码解析文章：STL/README.md at master · FunctionDou/STL 你永远值得信任的 cppreference 老大哥： C++ 标准库 - cppreference.com","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"GAMES101-1：课程总览与笔记导航","slug":"GAMES101/GAMES101-1","date":"2023-08-15T16:26:06.000Z","updated":"2024-04-20T18:58:06.434Z","comments":true,"path":"/GAMES10101.html","permalink":"http://example.com/GAMES10101.html","excerpt":"前言 对我的 GAMES101 课程笔记的导览与最后一课的尾声小建议部分:","text":"前言 对我的 GAMES101 课程笔记的导览与最后一课的尾声小建议部分: 笔记导航 对应于 101 课程的四个板块：光栅化、几何、光线传播和动画模拟。标题是于原课程一一对应的。 其中： 笔记 2：回顾了矩阵的基本运算，叉积（判断向量的左右关系，右手定则）和点积（判断两个向量相似程度）。 笔记 3 ~ 10：光栅化： 3：对模型进行 M 变换，摆在空间中； 4：对模型 VP 变换到相机坐标系，并压到 1*1*1 的投影空间中； 5：光栅化打碎到屏幕上成像素； 6.1：光栅化中（和后）进行反走样处理； 6.2：光栅化中进行深度检测 Z-buffer； 7、8：贴上材质，应用 Blinn-Phong 模型等进行光照着色（平面着色/Gouraud 顶点着色/Phong 像素着色）（高光/环境光/漫反射光）； 9、10：重心坐标系插值进行纹理映射，像素金字塔（mipmap）反走样，纹理映射的另类应用：法线贴图 笔记 10 ~ 12：几何，例如贝塞尔曲线、网格细分等 10，11：什么是显式几何（参数，列表），什么是隐式几何（函数形式几何）； 11，12：贝塞尔曲线，网格细分（Loop 细分，Catmull-Clark 细分），网格简化（边坍缩）； 笔记 12 ~ 16：Whitted-Style 光线追踪与路径追踪 12，13：阴影映射，Whitted-Style 光线追踪，面线求交点（显式，算；隐式：AABB 包围盒）； 14：求交的优化：均匀空间划分、树形空间划分，按物体数划分； 15：基于物理（辐射度量学）的光线追踪：通过 BRDF 得反射方程，继而有全局光照 16：路径追踪，在光源进行蒙特卡洛积分，光源和像素上随机挑方向打路径； 笔记 16 ~ 20：光线传播的其他内容：物理材质与光场，这部分感觉比较偏介绍理解就行 17：材质就是 BRDF，用 BRDF 可以处理颜色，透明，抛光等等现象； 18：光线传播计算、外观材质、程序化生成； 19：摄像机的基本参数（光圈，快门，ISO……），光场； 20：色彩空间； 笔记 21 ~ 22：动画，即物理模拟 21：关键帧，用质点和弹簧来模拟形变面，正向运动学和逆向运动学，rigging（思想像三维贝塞尔）； 22：粒子在速度场中的运动模拟； 笔记可能会修改措辞、增删内容，我会在每次访问自己的博客时检查并修正错误。 后面有计划将我校的图形学课的内容也写出来（其实是 hawa 已经写好的），例如线扫描算法等。 后面会有计划将课程作业记录（报告？）写出来。 继续深入…… 对于渲染，请继续学习虎书，结合学习 OpenGL、Vulkan 等，学习各种各样的着色器等。 对于数学……呃，需要的时候再看吧，拓扑、流形什么的 如果对模拟与仿真感兴趣，请看 GAMES201 一些学术会议：ChinaVR、Chinagraph、Sigraph 当然目前我并没有科研的计划，但是如闫老师所言，以各种各样的视角和身份了解不同的领域是一件会很有收获的事。","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"}]},{"title":"GAMES101-22：动画2","slug":"GAMES101/GAMES101-20","date":"2023-08-14T15:41:16.000Z","updated":"2024-04-20T18:58:06.447Z","comments":true,"path":"/GAMES10120.html","permalink":"http://example.com/GAMES10120.html","excerpt":"前言 GAMES101-22:单粒子的运动的模拟方法（欧拉与其各种改进）、刚体模拟、流体模拟、网格法与质点法处理大量物体的移动问题","text":"前言 GAMES101-22:单粒子的运动的模拟方法（欧拉与其各种改进）、刚体模拟、流体模拟、网格法与质点法处理大量物体的移动问题 单粒子模拟 考虑一个粒子在速度场中速度随着时间的变化的模拟。即算常微分方程 x˙=v(x,t)\\dot{x} = v(x,t)x˙=v(x,t) 简单而基础的方法：（前向）欧拉方法 xt+Δt=xt+Δtx˙tx˙t+Δt=x˙t+Δtx¨tx^{t+\\Delta t} = x^t + \\Delta t \\dot{x}^t \\\\ \\dot{x}^{t+\\Delta t} = \\dot{x}^t + \\Delta t \\ddot{x}^t xt+Δt=xt+Δtx˙tx˙t+Δt=x˙t+Δtx¨t 其中右上角只是标记，不是指数；而一个点表示一次求导（即速度）。这种方式用上一帧的数据计算下一帧的数据。其问题在于： 不准确：步长（即两帧之间的间隔 Δt\\Delta tΔt）越大，结果越不准； 不稳定：对于圆周运动的情况，会变成螺旋形飞出去； 不准确在 CG 中往往可以理解容忍，但是不稳定、无论如何都得不到准确的结果是难以接受的。这种不稳定现象是欧拉方法试图用数值方法解微分方程的必然结果。 下面是一些解决了不稳定性的方法。 中点法 使用欧拉方法计算出在 o 点的粒子 p 下一步长所在的位置 a； 取 oa 中点 b 的速度场方向； 对（依然在 o 点的 p）应用 b 点的速度计算欧拉方法，得到实际到达的位置 c。 这样，中点法取了一个中间、更能代表平均运动方向的速度。 如果我们将中点法的公式推出来，那么，我们会发现中点法更准确的原因在于它引入了二阶导，而不是普通欧拉的一阶导。 自适应步长 使用欧拉方法计算出在 o 点的粒子 p 下一步长所在的位置 a； 使用欧拉方法计算出在 oa 中点的粒子下一步长所在的位置 b； 如果 a、b 距离甚远，那么说明步长过大，缩小步长重新计算； 如果 a、b 距离不大，那么说明步长已经缩得够小，取一个作为结果； 这种办法步长可变，所以能模拟得很好。 隐式/后向的欧拉方法 使用下一帧的速度而不是上一帧的速度。 xt+Δt=xt+Δtx˙t+Δtx˙t+Δt=x˙t+Δtx¨t+Δtx^{t+\\Delta t} = x^t + \\Delta t \\dot{x}^{t+\\Delta t} \\\\ \\dot{x}^{t+\\Delta t} = \\dot{x}^t + \\Delta t \\ddot{x}^{t+\\Delta t} xt+Δt=xt+Δtx˙t+Δtx˙t+Δt=x˙t+Δtx¨t+Δt 在实际情况中速度和加速度之间的关系往往并不是那么好直接解出。往往可能需要求根公式等导致速度会比显示慢得多————当然，也变得稳定得多。 龙格-库塔方法 通过中点法我们已经知道阶数越高效果越好。而龙格-库塔方法是一系列解常微分方程的很好的方法（同样基于欧拉），其中四阶的龙格库塔方法（RK4）最常用，它形如 xn+1=xn+16h(k1+2k2+2k3+4k4)tn+1=tn+hx_{n+1} = x_n + \\frac{1}{6}h(k_1 + 2k_2 + 2k_3 + 4k_4) \\\\ t_{n+1} = t_n + h xn+1​=xn​+61​h(k1​+2k2​+2k3​+4k4​)tn+1​=tn​+h 其中四个 k 是四个关于 x、t 的函数，懒得记了，用到再说。 对推导感兴趣的话请学习数值分析。 不基于物理的方法（Position-based / Verlet Intergration） 不基于物理的方法难以保证能量守恒，但是又快又简单。 参见作业 8. 衡量稳定性 通常我们不关心单步的误差（局部误差）和整体误差的值是多少，但是会关心它们和步长之间的关系。 以隐式欧拉为例，步长为 h，整体误差是 O(h)O(h)O(h)，局部误差是 O(h2)O(h^2)O(h2)，即如果步长减少一半，那么可以期望整体误差变为原来的一半，而局部误差可以期望变为原来的四分之一。 刚体模拟 刚体即不可变形的物体，刚体的模拟本质上就是一个大单体粒子的模拟。当然我们还需要考虑一些其他的属性，例如： 角度、角速度（一阶导，F/M）、角加速度（二阶导） 位置、速度、加速度 流体模拟 我们通过模拟小的刚体球（粒子）近似水体；并且认为水的密度是不变的，如果某处的密度改变了，那么就通过修正粒子的位置来进行修正。 物理模拟和渲染是有前后的两步，所以近似为小球不影响渲染。 每个粒子都可以对空间中的任意一点的密度产生影响。因此，为了达到“改变粒子的位置使得此处的密度降低”的目的，我们就需要知道密度对于所有粒子的位置的导数梯度。然后应用梯度下降法即可。（即改变对此处密度影响最大的粒子的位置） 以防万一：梯度是导数下降最快的方向。 这种模拟是不基于物理的，例如我们直接改了粒子的位置。当然为了避免水的运动停不下来，我们也可以加入能量衰减的公式。 大量物体的模拟方法（视角）：质点法与网格法 质点法：又称拉格朗日法，以质点为主体，研究观察质点的位置变化情况； 网格法：又称欧拉法，以空间网格为主体，研究观察一个空间中的固定位置的密度等信息（类似盯着那种大颗粒 LED 滚动屏的单个珠子看）。 材质点法：混合网格质点的方法，例如用粒子记录材质信息，然后用网格计算粒子的变迁，最后写回粒子里。 尾声 见笔记1。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-21：计算机动画 Next：完结撒花！","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"粒子","slug":"粒子","permalink":"http://example.com/tags/%E7%B2%92%E5%AD%90/"},{"name":"刚体","slug":"刚体","permalink":"http://example.com/tags/%E5%88%9A%E4%BD%93/"},{"name":"流体","slug":"流体","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93/"}]},{"title":"GAMES101-21：计算机动画","slug":"GAMES101/GAMES101-19","date":"2023-08-13T14:40:02.000Z","updated":"2024-04-20T18:58:06.445Z","comments":true,"path":"/GAMES10119.html","permalink":"http://example.com/GAMES10119.html","excerpt":"前言 GAMES101-21:动画的历史、关键帧、物理模拟、刚体、正向与逆向运动学、Rigging、动捕","text":"前言 GAMES101-21:动画的历史、关键帧、物理模拟、刚体、正向与逆向运动学、Rigging、动捕 动画 动画：给物体带来生命，一种交流工具。在计算机时代，我们可以认为动画就是不断连续输出模型随时间的变化的帧。 动画的历史 1963 年，就有了计算机动画：sketchPad 中的动画。 Pixar 的《玩具总动员》是一个里程碑式的作品：整个全长电影都是计算机渲染出来的。 关键帧 这个关键帧就是 PR 等中的关键帧。 以前的艺术家，会画出关键帧，然后由助手画中间的帧。 现在，我们希望计算机可以插值出中间的帧。当然，插值有许多的方式，不一定是线性插值。我们还可以期待例如 C1 连续的插值等。 基于物理的动画（物理模拟） 如果例如我们给出正确的力学公式和正确的力学模型，当然就可以更新模型的动作变化，即物理模拟。 其中很重要也很困难的一部分是流体模拟。 质点弹簧系统（Mass Spring System）：通过一系列的质点和连接的弹簧来进行模拟。 在 a，b两个质点之间用 l 长度的弹簧连接。弹簧现在被拉开，因此 a 受到向 b 的力，有应用胡克定律简单有 fa→b=ksb⃗−a⃗∥b⃗−a⃗∥(∥b⃗−a⃗∥−l)f_{a \\rarr b} = k_s\\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|}(\\| \\vec{b} - \\vec{a} \\|-l) fa→b​=ks​∥b−a∥b−a​(∥b−a∥−l) 仅仅应用上面的模型是不够的，因为能量守恒，要让弹簧停下来我们就需要加入摩擦力。摩擦力有这么几点特点 它与 a、b 之间的相对速度有关，而且是沿弹簧方向的相对速度。 与弹簧的力的方向相反。 基于此我们给出阻力公式（以 b 为例） fb=−kdb⃗−a⃗∥b⃗−a⃗∥⋅(b˙−a˙)⋅b⃗−a⃗∥b⃗−a⃗∥f_b = -k_d \\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|} \\cdot (\\boldsymbol{\\dot{b}}-\\boldsymbol{\\dot{a}}) \\cdot \\frac{\\vec{b}-\\vec{a}}{\\| \\vec{b} - \\vec{a} \\|} fb​=−kd​∥b−a∥b−a​⋅(b˙−a˙)⋅∥b−a∥b−a​ 其中 b˙−a˙\\boldsymbol{\\dot{b}}-\\boldsymbol{\\dot{a}}b˙−a˙ 中一个点表示一阶导，即这个方向上的速度。 我们这么理解这个公式：b 的向 a 方向的相对速度经过一个点乘投影到弹簧方向上，再经过一个点乘变成该方向的速度，最后乘以阻力系数并取反得到阻碍 b 向 a方向收缩的阻力的大小和方向。 应用这些力学公式，我们将点之间用弹簧按方格的形式连接起来，似乎就可以简单地表示一块布了。但实际上还有一些问题： 不能抵抗切变：即如果沿一个方向拉，我们不应该能将布拉成一个没有宽度的线。为此，我们需要在对角线上连接上弹簧来抵抗切变。 不能抵抗非平面弯曲：即如果把布折起来，我们不应该能将它折叠成一个平面。为此，我们将一个点与和它上下左右隔了一个点的点连起来，提供一个很弱的力。 于是结构长这样： 切变可复习第三课的基本变换矩阵部分。 其他的模拟方法， 有限元方法 FEM：用一种扩散的方式像热一样看力，适用于汽车碰撞的模拟。 粒子系统：用许多的粒子来模拟，粒子移动受一系列力的作用。这种方式的优点是易于理解、实现和规模可伸缩，挑战则是需要计算许多的粒子，计算需要考虑如何加速。 粒子的本质就是“描述个体与群体之间的关系”，因此实际上我们不仅仅可以用粒子来描述烟、雾、水等等，也可以用它来描述鸟群、蜜蜂、星系等等……例如，一个鸟“粒子”既会跟随鸟群中心移动方向移动，不希望离中心太远，也不会希望和其它鸟太近。 运动学（Kinematics）） 正向运动学（Forward Kinematics） 骨骼系统：描述关节之间的拓扑关系，本身形成了一种树形结构。关节有三种类型： Pin：只能在一个点上旋转（一维旋转） Ball：可以在二维平面内旋转（二维的旋转） Prismatic：可以拉伸 正向运动学只要我们传入好每个关节的角度等参数，就可以告诉我们运动的结果，关节停在了哪儿。这种方式简单而直接，但是并不方便艺术家的使用：显然我们不希望调整关节的方式是不断地挨个输入角度看什么时候调得合适。为此我们需要逆运动学。 逆运动学 逆运动学即我们调整关节的位置，计算机自动给出其他的关节应该如何随着变化。 逆运动学的一些挑战： 计算会比正向运动学复杂很多 多解情况 无解情况 现在用的一些优化方法：用梯度下降的方法而非解数学公式。 Rigging Rigging 是对物体形状的控制，就如木偶上的提线，让角色做出不同的动作造型。 Google Bard 将它翻译成了骨骼系统，不无道理可以参考但是骨骼感觉不能代表所有 Rigging。 这有些像三维世界的（贝塞尔）曲线调整，我们调节一些点使得样条变成我们想要的样子。 动作捕捉 干脆建立一个真人到虚拟人的控制点的映射，然后让人去做动作。 好处在于：真实度高、数据获取快（不用艺术家去一点一点调）； 缺点在于：准备工作非常多而复杂（例如穿控制点的衣服等等）、不一定能获取到需要的数据（非真实风的、控制点难以捕捉的）。控制点有很多办法来记录，例如穿绿幕衣服用摄像机 + CV 算法的方式，或者连接机器等等。 阿凡达的里程碑效应在于，其大量使用了面捕技术。 动画的生产管线：原画-&gt;模型-&gt;生产吧啦吧啦…… 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-20：颜色与感知 Next：GAMES101-22：动画2","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"计算机动画","slug":"计算机动画","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB/"},{"name":"关键帧","slug":"关键帧","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%B8%A7/"},{"name":"骨骼系统","slug":"骨骼系统","permalink":"http://example.com/tags/%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/"},{"name":"运动学","slug":"运动学","permalink":"http://example.com/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"Rigging","slug":"Rigging","permalink":"http://example.com/tags/Rigging/"}]},{"title":"GAMES101-20：颜色与感知","slug":"GAMES101/GAMES101-18","date":"2023-08-12T18:32:12.000Z","updated":"2024-04-20T18:58:06.444Z","comments":true,"path":"/GAMES10118.html","permalink":"http://example.com/GAMES10118.html","excerpt":"前言 GAMES101-20:颜色的物理基础、生物基础、色彩空间","text":"前言 GAMES101-20:颜色的物理基础、生物基础、色彩空间 note：色彩空间，听了三回啊三回………（悲。（CV、VR、GAMES101） 颜色 人对光有不同的颜色认知，原因是有不同的波长（和光的叠加）。我们用谱功率密度（SPD）曲线衡量一道光在不同波长上的分布。谱功率密度具有线性的性质，可以叠加。 需要特别强调的是，颜色是人对光的感知，不是光的固有属性。 人眼有棒状细胞感知灰度，杆状细胞感知色彩，三种杆状细胞分别对不同的波长敏感。 不同个体的三种杆状细胞的分布和占比都大不一样。 同色异谱现象，可以有两个光有一样的颜色不一样的 SPD。我们可以通过混合不同的光得到异谱的同色结果。这就是色彩匹配。 在纸上我们采取减色系统 CMYK，屏幕上加色系统如 RGB。 这样我们就可以做色彩匹配的实验，比如说尝试用调整 RGB 的比例来得到我们看到的所有颜色。但是这时，我们发现有的颜色是调 RGB 调不出来的，需要在需要被匹配的颜色上加光（即在匹配组加负数多的光）才行。这样，我们就可以用 (s)RGB 坐标表示任何波长的光。进而对任意 SPD 可以在 R、G、B 上积分（因为 SPD 上是连续的波长）。 把不同波长表示成一个坐标，那么就得到了一个色彩空间。 XYZ 色彩空间：不同于实验测定的 RGB，还有设计出来的 XYZ 色彩空间，它的优势在于避免了取负数坐标的问题。同时 Y 值被设计得可以表示亮度（明度）。我们计算 x，y 分别为 X、Y、Z 中 X、Y 的占比，那么固定 Y值，就可以把色彩空间表示在二维的面上（而 z = 1-x-y）。表示出来的图像是凸型或者说舌形的。故而可叫色度图、舌形图、色域图。 sRGB 只占色域空间中非常小的部分。 HSV 色彩空间：色调、饱和度、明度。色调选纯色、饱和度决定有多偏白、明度决定有多偏黑（暗）。 LAB 色彩空间：L:亮度（黑白互补对），a：红绿互补对，b：蓝黄互补对。 互补色的确定是人的眼睛的特性确定的。例如我们无法想象偏绿的红，可以想象偏绿的蓝。利用视觉暂留效应，我们可以短暂的看到一种颜色的互补色。 这里我们再次感知到颜色是人的感知效果。 CMYK：印刷减色系统。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-19：摄像机、透镜、光场 Next：GAMES101-21：计算机动画","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"颜色","slug":"颜色","permalink":"http://example.com/tags/%E9%A2%9C%E8%89%B2/"},{"name":"色彩空间","slug":"色彩空间","permalink":"http://example.com/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"}]},{"title":"GAMES101-19：摄像机、透镜、光场","slug":"GAMES101/GAMES101-17","date":"2023-08-11T17:25:54.000Z","updated":"2024-04-20T18:58:06.443Z","comments":true,"path":"/GAMES10117.html","permalink":"http://example.com/GAMES10117.html","excerpt":"前言 GAMES101-19:简单了解：摄像机的基本构造、光圈大小、快门、ISO、弥散圆、曝光、可视角度","text":"前言 GAMES101-19:简单了解：摄像机的基本构造、光圈大小、快门、ISO、弥散圆、曝光、可视角度 GAMES101-20:光场 图像：合成法与捕捉法 成像不一定是合成成像（例如模型），也可以是捕捉成像，例如相机拍拍拍。我们之前说的都是合成成像，本节讲捕捉成像。 相机的部件 小孔或透镜：小孔应用在针孔相机。用于聚光成像。 快门：控制进光时间。 传感器：记录辐照强度（Irradiance）。（如果没有小孔/透镜，一个点有各个地方的光，传感器成像就糊了。） 针孔摄像机利用小孔成像，没有深度（景深）可言，每个地方都是清晰的。我们此前介绍的光线追踪也是这种模型。 焦距和可视角度的关系，设传感器高度为 h，焦距为 f，那么在竖直方向上可视角度： FOV=2arctan⁡h2fFOV = 2\\arctan\\frac{h}{2f} FOV=2arctan2fh​ 由于 FOV 和传感器大小、焦距均有关系，所以一般会规定把焦距换算成 35mm（*24mm） 胶片下的焦距。 通常,对于 35mm 胶片, 17mm 焦距对应 104° 可视角度，是广角镜头，50mm 47°是普通镜头。 当然传感器大有大的好，分辨率可以上升。 曝光 曝光的公式 H=T×EH = T \\times EH=T×E,即曝光 = 曝光时间×辐照强度。曝光时间越长，照片越亮，因为传感器上累计的能量越多。 光圈大小，类似人眼瞳孔的设计，依据 F-Stop 参数控制光圈开合来控制进光多少。 F-Stop 也可以写成 FN、F/N，N 代表一个数。 FN 是焦距除以光圈直径。 光圈大进光多，自然会带来曝光度的提升。 光圈越大，还会导致景深越浅，远景变糊。 快门速度：快门能快速开关，控制开放进光的时间 快门时间过长，拍摄运动物体就会带来模糊效果，即运动模糊。 速度越快/快门越长越模糊。快门时间短，可以减轻运动模糊，但是也需要修正由此带来的亮度降低。 合适的运动模糊既可以增强人对速度的感知，也可以一定程度的反走样。 机械运快门打开不可能真正同时，在记录高速运动的物体（如飞机螺旋桨）的时候会带来扭曲现象。 ISO 感光度：后期处理的一步，在每个传感器数值上乘以一个倍率。 ISO 过大，在放大图像亮度的同时也会放大噪声，使得图像噪声过多。 联系光圈和快门，如果我们相同的曝光度下，想获得浅景深（大光圈），就得减少快门时间来维持曝光度的不变，这需要权衡。同时也意味着同时调整光圈和快门得到的同样曝光度的照片并不一致。 快门时间极短，就是高速摄影，快门时间极长，就是延时摄影。 理想薄透镜、弥散圆与光线追踪 设想一种理想薄透镜：没有厚度，可以改变焦距（基于现在调整透镜组的设计）。 薄透镜有下列关系： 1f=1zi1zo\\frac{1}{f}=\\frac{1}{z_i}\\frac{1}{z_o} f1​=zi​1​zo​1​ 其中 f 是焦距，ziz_izi​ 是物距，zoz_ozo​ 是像距。 失焦模糊：一个点经过透镜可以被聚焦在一个点上，但是我们的感光面并不在该点上，导致在感光面上就成了一个圆（CoC，Cirlcle of Confusion）。根据物距、焦距、感光面到透镜的距离(zsz_szs​)、透镜的大小(A)，我们可以计算 CoC 的大小 C。(像距（ziz_izi​）是中间步骤)： CA=∣zs−zi∣zi\\frac{C}{A}=\\frac{|z_s-z_i|}{z_i} AC​=zi​∣zs​−zi​∣​ 又光圈大小是焦距除以光圈直径，所以我们就知道了为什么大光圈意味浅景深。 光线追踪中加入景深：场景假如我们知道和传感器距离的透镜，一个传感器点随机命中透镜上点 a，我们知道传感器点经过透镜是会聚焦在点 b 的，那么 a 接下来就会往 b 去。 景深 景深就是在焦距附近，CoC 的大小还可以接受的那一段长度。 光场 全光函数：假设我们有一个完全真实的画，贴在墙上，那么我们就无法区分这是窗子还是画。从这个角度出发我们就可以定义函数 P(θ,ϕ,λ,t,Vx,y,z)P(\\theta,\\phi,\\lambda,t,V_{x,y,z})P(θ,ϕ,λ,t,Vx,y,z​)，量依次表示：一个观察者周围 360°的极坐标、该坐标的光强，光波长（颜色），时间，观察者的空间位置。这样，我们就能表示一个可以随处移动的人在任意地点时间任意向方向看到的东西（即我们现实观察的一切）。 定义光线，我们无论怎么定义光线总是需要一个点一个方向，这里它们都是二维的。因为点在物体表面（类似 uv 坐标），而方向可以是 θ，ϕ\\theta，\\phiθ，ϕ 两个方位角。 于是定义光场：一个物体上任意一点向任何方向看的光的信息。 于是我们通过光场（一个四维函数）可以知道任何方向看到这个物体的效果。 光场不一定要在物体表面，正如开头所说，我们只关心看到了什么，不关心看到的东西究竟是在墙上还是墙外。我们完全可以定义一个包围盒包围物体记录光场。 一种定义光场的办法是，定义两个平面，在两个平面（uv 平面和 st平面）上各取两个点，那么就可以确定一个光线。 假定 uv 是离摄像机近的面，st 是离物体近的面。那么可以讨论两种理解： 从 uv 上固定一个点看 st 上所有点：看到一个完整的物体。正如我们在普通摄像机看到的。 从 uv 上所有点看 st 的不同方向：看到一个点在不同方向的信息。 昆虫的复眼其实就是一种光场。我们的眼睛/摄像机之所以不能缺少透镜是因为缺少透镜使得不同方向来的光被混合在了一起，如果我们可以将来自不同方向打到同一点的光经过透镜以后分别存放在不同的感光元件上，那么就可以把光分开了。这样就同时可以看向不同方向。利用这种办法，有人发明了光场相机。 要从光场中还原一个普通的照片，我们可以选定一个方向去光场中获取信息。而光场照片比起普通照片的优点是，我们可以虚拟的移动相机的位置。而不用 CV 的一些手段。 当然，因为要记录大量的信息，光场照片数据量大，分辨率往往不足。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-18：渲染中的高级板块 Next：GAMES101-20：颜色与感知","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"光场","slug":"光场","permalink":"http://example.com/tags/%E5%85%89%E5%9C%BA/"},{"name":"透镜","slug":"透镜","permalink":"http://example.com/tags/%E9%80%8F%E9%95%9C/"}]},{"title":"GAMES101-18：渲染中的高级板块","slug":"GAMES101/GAMES101-16","date":"2023-08-11T14:29:04.000Z","updated":"2024-04-20T18:58:06.442Z","comments":true,"path":"/GAMES10116.html","permalink":"http://example.com/GAMES10116.html","excerpt":"前言 GAMES101-18:渲染中的高级内容（仅作了解，不涉及细节）：光线传播计算、外观材质、程序化生成","text":"前言 GAMES101-18:渲染中的高级内容（仅作了解，不涉及细节）：光线传播计算、外观材质、程序化生成 高级光线传播 有偏光线传播 双向路径追踪 BDPT MLT 无偏光线传播 光子映射 Photo Mapping VCM IR 无偏：蒙特卡洛积分不会引起系统误差，无论样本多少，期望都是正确的。反之则是有偏的。 双向路径追踪 BDPT 路径追踪：从相机打射线追踪到光源。双向路径追踪会先从相机和光源打出一些“半路径”，然后再连接这些半路径。 BDPT 在有的情况下表现比路径追踪好很多（例如光源是对着天花板打的灯，场景全是间接光）。但是相对的速度很慢，写对很难。 Metropolis 光线传播，Metropolis Light Transport，MLT Metropolis 是人名，姑且不译。 应用马尔科夫链蒙特卡洛积分（MCMC），马尔科夫链是一种采样方法，它可以根据当前样本生成靠近的新样本。这样，对于困难的光路，它也可以在局部不断进行探索最后得到新的路径，最后得到最佳概率密度函数（f（x）形状p（x）时）。 MLT 对于复杂光路处理非常好（例如游泳池波浪在水底聚焦的波纹，caustics 现象），因为只要有一个随便的函数就可以得到更多的形状。 缺点则有：难以估计收敛速度；像素之间没有关系，收敛速度不一；因此而得到脏结果；也因为像素不一定会每一帧都收敛，导致一般不用于动画渲染，会导致画面抖动。 光子映射 有多种方法。 步骤1：光子不断反射折射，直到打到漫反射的表面停下。记录下表面的光子数。 步骤2：摄像机打出射线不断反射折射，直到遇见漫反射表面停下。 然后进行计算，计算局部密度估计（local density estimation） ：找到射线附近最近的 N 个光子，计算它们占据的面积大小（密度）。因为我们知道，光子越多越密就应该越亮。 如果 N 过小，则结果噪声大；如果 N 过大，则结果会变糊。 光子映射是有偏的，因为光子数量有限，我们是用不无限小的面积 ΔA 去替代了无限小的面积 dA（数量 N 也是同理）。但是它是“一致的”，也就是极限（光子无穷多）的情况下结果是正确的。 为什么我们是找 N 个光子占的面积而不是找 A 面积内的光子数量？ 因为后者是有偏且不一致的：随着光子数量的增加，结果不会收敛的正确结果。 VCM（顶点连接与扩展） 结合 BDPT 和光子映射。 BDPT 打出的两边的半路径非常接近但是没有连接，就用光子映射的办法去它们作为光子收集起来发挥作用。 实时辐射度 Instant Radiosity 把反射光的平面看成新的光源。 缺点则有有的时候会有异常亮点，不能处理抛光面等。 高级外观（Appearance）模型 非表面模型 散射介质/参与介质:云雾 毛发、纤维 颗粒材质 表面模型 透光材质 布料（cloth） 程序化生成模型 散射介质 云雾会在传播过程中会被吸收也会被散射（往各个方向随机打）。 相位函数类似于 BRDF 决定了光怎样散射（均匀？主要前向？主要后散？）。 渲染：随机选一个弹射方向随机走一段距离，最后连到摄像机。 不是只有云雾才是散射介质，例如手电筒的光照亮捂在上面的手，这里光进入了手一定距离，这里手就是散射介质。 毛发外观 人头发 头发表面会有两种高光，无色的（漫画上的白光带）与有色的。 Kajiya-Kay 模型：效果不好。 Marshner Model：把头发局部视为玻璃圆柱，分为 cortex（表面） 和 cuticle（内部），并且表面会吸收光，内部会有色素。综合考虑 R（反射）、TT（两次折射）、TRT（折射反射折射）。 光会真的在一根根的头发中和头发间折射反射，计算量巨大。 动物毛发 人头发模型运用于动物毛发得到的结果是不对的。 因为毛发的最内层是 Medulla(（毛）髓质)，毛髓会发生散射现象，类似散射介质。而动物毛发的毛髓比人头发大得多。 因此，我们需要模拟毛髓。 进一步地我们也可以在人的头发上模拟（比动物毛发小的）毛髓，得到更真实更亮的头发。 同样用玻璃柱模拟毛髓，这就是更好的双玻璃柱模型。 颗粒材质（granular material） 一粒一粒的，例如盐、香料、沙子…… 可以将其视为一个个单元；然后再分析成分、渲染。 非常耗时间，应用不多。 透光材质（Translucent） 透光（Translucent）往往被翻译成半透明，但并不是半透明。这种性质的原理在于散射，使得光能透过，但是并不能由此看到什么。 例如捂住手电筒的手附近、玉、水母 为此我们引入次表面散射（BSSRDF）的概念，这是对 BRDF 概念的拓展，从一个点一个方向进入的光可以从另外一个点另外一个方向出去，记 S(xi,ωi,xo,ωo)S(x_i,\\omega_i,x_o,\\omega_o)S(xi​,ωi​,xo​,ωo​)。 Dipole 近似：在发生 BSSRDF 表面的地方上下加入两个光源，从而用 BRDF 近似 BSSRDF。 人的皮肤、大理石等等都会发生散射，因此使用 BSSRDF 都会得到更好的效果。 布料材质 纤维（fiber）绕成一股股（Ply），股再缠绕形成线（yarn），最后被织成布料。 渲染：BRDF 面；当成微小的体积单元，根据编织性质确定吸收和散射，向散射介质一样渲染（好，但是计算量大）；更暴力地，像头发一样渲染纤维。 细节外观 现实世界不是绝对完美的，有各种细节上的瑕疵，这反而使得我们的渲染结果不够真实。 如果我们使用的法线贴图（normal map）是完美线性的，就不够真实，如果每个法线既符合整体规律又有自己的特点，就更真实。 这样的微表面渲染非常困难，因为表面太小有太多无法从光源命中摄像机的路径。解决的办法是我们可以把一个像素覆盖的微表面找出来，计算这个像素在各个方向的 BRDF。如果覆盖像素多，则有总体的效果，覆盖的少，就有个体的性质。 如果表面极小，小到接近光波，那么就会需要考虑波动光学来计算 BRDF。 程序化生成的外观 如果我们存储三维空间的纹理，那就太复杂，太占空间了。我们可以用噪声函数，不存储，只在需要用的时候算出来该点的值即可。 一些噪声函数的应用：地形生成、水面生成、木头内外的年轮纹理等等。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-17：基于物理的材质（BRDF） Next：GAMES101-19：摄像机、透镜、光场","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"光线传播","slug":"光线传播","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E4%BC%A0%E6%92%AD/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"程序化生成","slug":"程序化生成","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"}]},{"title":"GAMES101-17：基于物理的材质（BRDF）","slug":"GAMES101/GAMES101-15","date":"2023-08-09T14:14:49.000Z","updated":"2024-04-20T18:58:06.441Z","comments":true,"path":"/GAMES10115.html","permalink":"http://example.com/GAMES10115.html","excerpt":"前言 GAMES101-17:各种各样的材质、反射率、斯涅耳定律与全反射现象、菲涅尔项、微表面材质、BRDF 的特点与测量","text":"前言 GAMES101-17:各种各样的材质、反射率、斯涅耳定律与全反射现象、菲涅尔项、微表面材质、BRDF 的特点与测量 材质就是 BRDF 我们现在已经知道，决定模型的光照效果是什么样的是不同的材质，而在我们的渲染方程(不考虑自发光)中，和物体自身相关的项只有 BRDF。这就是说， 材质就是 BRDF。 Lr(p,ωo)=∫H2Li(p,ωi)fr(p,ωi,ωo)(n⃗⋅ωi⃗)dωiL_r(p,\\omega_o)=\\int_{H^2}L_i(p,\\omega_i) f_r(p,\\omega_i, \\omega_o) (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i Lr​(p,ωo​)=∫H2​Li​(p,ωi​)fr​(p,ωi​,ωo​)(n⋅ωi​​)dωi​ 材质决定物体的光照效果，具体来说，即反射/折射系数、金属质感强弱、光滑感、柔软度等等； 纹理决定了物体的颜色，从物理上来说即吸收了不同波长的光，纹理的本质是一张图片（uv 图）； 纹理和材质是关系密切的因为它们事实上在渲染公式中的同一项。但是我们通常不会对一束光分成 RGB 三色进行考虑，所以就有了纹理图的需求。当然，准确地说，材质是只和漫反射系数有关的。 材质多种多样，除了漫反射和镜面反射，这里还介绍两种情况。 抛光（Glossy）材质：这种材质像打磨过的金属面，光被反射到一个小区间里，于是既有高光又不是完全的镜面。不同的金属的抛光面也有不同的质感，例如铜面发红，铝面发白。 折射：半透明类型的材质还会同时发生反射和折射。折射的光与物体内的物体发生反射于是我们就可以看到物体内的物体。如果折射的过程中光被吸收了一部分，我们则就会看到发生折射的物体的颜色。（例如水的绿色）。 漫反射与反射率 下面计算反射率。 假设一个完全不吸收光(纯白)的物体表面发生漫反射，就有对任意方向来的光都有 Lo=LiL_o=L_iLo​=Li​， 此时，光均匀地从各个方向来又被均匀的反射到各个方向去，物体本身不吸收任何能量。有： \\begin{align} L_r(p,\\omega_o) &amp;=\\int_{H^2}L_i f_r (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i \\nonumber\\\\\\nonumber\\\\\\nonumber &amp;= f_r L_i \\int_{H^2}\\cos\\theta_i \\mathrm{d}\\omega_i \\\\\\nonumber\\\\\\nonumber &amp;= \\pi f_r L_i \\\\\\nonumber\\\\\\nonumber &amp;\\dArr \\\\\\nonumber\\\\\\nonumber f_r &amp;= \\frac{1}{\\pi} \\end{align} 定义物体的**反射率(albedo)**衡量物体反射的强弱，值介于 0 到 1 之间，则由上式知道反射率和 BRDF 之间的关系是： fr=ρπf_r = \\frac{\\rho}{\\pi} fr​=πρ​ 而我们的情境就是物体反射率最强的时候，这时物体纯白。 Albedo 的定义方式多种多样，既可以是一个数，也可以是 RGB 三个数或一个光图。而 Albedo 纹理是一种特殊的纹理，它用于指定物体表面的颜色或基础反射率。 反射和折射 此外，半透明类型的材质还会同时发生反射和折射。折射的具体效果见上。 类比于 BRDF，对于折射的 “BRDF” 就是 BTDF，二者可以合称 BSDF。 反射 对于反射，我们知道入射角等于反射角。有两种计算反射方位的方式。 利用向量的性质，入射向量加出射向量与法线向量共线(左图)ωi+ωo=2cos⁡θn⃗=2(ωi⋅n⃗)n⃗⇒ωo=−ωi+2(ωi⋅n⃗)n⃗\\omega_i+\\omega_o=2\\cos \\theta\\vec{n} = 2(\\omega_i\\cdot\\vec{n})\\vec{n}\\\\ \\rArr \\omega_o = -\\omega_i+ 2(\\omega_i\\cdot\\vec{n})\\vec{n} ωi​+ωo​=2cosθn=2(ωi​⋅n)n⇒ωo​=−ωi​+2(ωi​⋅n)n 类似在立体角处的讨论，把角度分成与法线方向的夹角 ω\\omegaω 以及垂直俯视法线方向的平面上的角 ϕ\\phiϕ （右图），则 ω\\omegaω 不变，只需ϕo=(ϕi+π)mod 2π\\phi_o=(\\phi_i+\\pi)\\mod2\\pi ϕo​=(ϕi​+π)mod2π 镜面反射还需要涉及到狄拉克 δ 函数，这里没有展开。 折射 斯涅耳定律（Snell's Law）指出，光从环境 i 打到环境 t 中，折射率与折射角（于法线轴夹角）度满足： ηisin⁡θi=ηtsin⁡θt\\eta_i\\sin\\theta_i = \\eta_t\\sin\\theta_t ηi​sinθi​=ηt​sinθt​ 其中，真空的折射率为 1。而折射率越高，往法线方向（的负方向）偏移就越多。 折射在垂直于法线的平面上不改变光的方向。 由斯涅耳定律推出 \\begin{align} \\cos\\theta_t &amp;=\\sqrt{1-\\sin^2 \\theta_t}\\\\\\nonumber\\\\\\nonumber &amp;=\\sqrt{1-(\\frac{\\eta_i}{\\eta_t})^2 (1 - \\cos^2 \\theta_i)} \\\\\\nonumber\\\\\\nonumber &amp;\\dArr \\\\\\nonumber\\\\\\nonumber &amp;1-(\\frac{\\eta_i}{\\eta_t})^2 (1 - \\cos^2 \\theta_i) \\nless 0 \\end{align} 这意味着当入射介质的折射率大于出射介质折射率的情况下，有可能不会发生折射，这就是全反射现象。 Snell's Window 如果大折射率介质中看小折射率介质，我们只能看到有限的一个区域，这是因为其他较远的入射较大的入射角让光无法折射到人眼处了已经。这种情况就是 Snell's Window。 菲涅尔项 日常生活中可以观察到的现象：如果俯视一张光滑的桌子，几乎没有反光现象；如果接近平视，则发光现象明显。这说明，物体的反射折射率于光的入射角度有关，这可以用菲涅尔项描述。 简单地说，菲涅尔项告诉我们： 如果和法线方向夹角越大（最多90度到平面），反射率越高，甚至于几乎全部反射掉；如果夹角越小，则反射率也越小，最小值不为零。 不同物体有不同的菲涅尔项。 导体（金属）和绝缘体的菲涅尔项图像大不一样，主要体现在金属的最小反射率非常高，例如 0.9。 菲涅尔项的计算公式较为复杂，因此我们通常使用近似公式（施里克近似，Shilick's Approximation） R(θ)=R0+(1−R0)(1−cos⁡θ)5R0=(n1−n2n1+n2)2R(\\theta)=R_0+(1-R_0)(1-\\cos\\theta)^5\\\\ R_0=(\\frac{n_1-n_2}{n_1+n_2})^2 R(θ)=R0​+(1−R0​)(1−cosθ)5R0​=(n1​+n2​n1​−n2​​)2 其中 R0R_0R0​ 是最低反射率。 拓展，导体的反射率还会发生随着角度增大而在一定区域内发生降低。此外，导体的折射率是负数。 微表面材质 从太空看地球我们可以发现这样一个事情，我们看不见地球表面的山川地貌，而看得阳光在地球表面的山川各种作用后的整体光照情况。 微表面理论告诉我们，离得够远，就看不到物体表面细节但是可以看到整体的光照情况。 于是微表面材质： 宏观：平坦但粗糙 微观：崎岖的几何面且镜面反射，有自己的独立法线。 如果表面相对光滑，微表面反射的光集中在一个较小的区间，呈现抛光的效果；如果表面相对粗糙，微表面反射的光分散在一个较大的区间，呈现漫反射的效果。 微表面的 BRDF： f(i,o)=F(i,h)G(i,o,h)D(h)4(n,i)(n,o)f(i,o)=\\frac{F(i,h)G(i,o,h)D(h)}{4(n,i)(n,o)} f(i,o)=4(n,i)(n,o)F(i,h)G(i,o,h)D(h)​ 其中 h：中间向量方向，即入射与出射方向的中间方向； F：菲涅尔项，告诉我们当前角度的反射率； G：几何项/ Shadowing-masking term，告诉我们有多少微表面的反射被另外一个微表面遮挡而损失了。这可以修正在接近水平面时的过亮情况； D：查询微表面反射的方向和中间向量的位置关系； 各向同性材质与各项异性 各向同性：微表面没有非常明确的方向性；或者从 BRDF 的方向来说，入射角和出射角的方位角变化，但是相对角度不变，则光照效果不变。 各向异性：微表面有非常明确的方向性；从 BRDF 的方向来说，入射角和出射角的方位角变化，但是相对角度不变，光照效果会变。 各项异性的一个例子,沿一个表面刷过的金属器皿有条状/辐射状的高光。 这里的各项异性和我们前面提到的各项异性过滤是一样的内涵。 BRDF 的特性 总结 BRDF 的特点 非负性：能量的分布当然不可能是负数 线性：我们可以把 BRDF 拆分计算再相加（Blinn-Phong 中高光、漫反射、全局的处理） 可逆性：交换入射出射结果不变 能量吸收：BRDF积出来结果不会变多 如果各项同性，BRDF 只有三个维度（θi−θo,ϕi,ϕo\\theta_i-\\theta_o,\\phi_i,\\phi_oθi​−θo​,ϕi​,ϕo​），而不是四个。而且可逆导致第一项只用考虑绝对值。 BRDF 的测量 实际上的 BRDF 非常复杂，所以我们可以（要）测量 BRDF，而不是（不能）仅简单使用公式。 测量方法：可以枚举所有的光照方向和观察方向。 当然，如果各向同性可以砍一个维度。 拓展：MERL BRDF Database 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-16：辐射度量学与路径追踪 Next：GAMES101-18：渲染中的高级板块","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"反射率","slug":"反射率","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84%E7%8E%87/"},{"name":"折射","slug":"折射","permalink":"http://example.com/tags/%E6%8A%98%E5%B0%84/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"微表面","slug":"微表面","permalink":"http://example.com/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"},{"name":"菲涅尔项","slug":"菲涅尔项","permalink":"http://example.com/tags/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9/"}]},{"title":"GAMES101-16：辐射度量学与路径追踪","slug":"GAMES101/GAMES101-14","date":"2023-08-06T10:11:52.000Z","updated":"2024-04-20T18:58:06.439Z","comments":true,"path":"/GAMES10114.html","permalink":"http://example.com/GAMES10114.html","excerpt":"前言 GAMES101-16:蒙特卡罗积分、路径追踪","text":"前言 GAMES101-16:蒙特卡罗积分、路径追踪 蒙特卡罗积分 数学中将随机采样来求解问题的算法统称统称为蒙特卡罗方法，如果应用在积分上就是蒙特卡罗积分。在高数中，我们采取的是求不定积分的原函数在 a,b 的差的方法来积分，但是现在我们不关心原函数又或者说求原函数过于复杂，这种时候蒙特卡罗方法就很有用了。 蒙特卡罗积分的思想如下：对于每次采样 xix_ixi​ ，求得 f(xi)f(x_i)f(xi​)。以该值估算积分：∫baf(x)=f(xi)(a−b)\\int^a_b f(x)=f(x_i)(a-b)∫ba​f(x)=f(xi​)(a−b)，随机取 N 个点进行 N 次估算取平均值，则有： ∫baf(x)=1N∑f(xi)p(xi)\\int^a_b f(x)=\\frac{1}{N}\\sum \\frac{f(x_i)}{p(x_i)} ∫ba​f(x)=N1​∑p(xi​)f(xi​)​ 其中 p(xi)p(x_i)p(xi​) 是取到该点的概率密度。这就是蒙特卡罗积分的公式，这里我们只需要关心采样方法的概率密度函数就可以积分了。 一个点的概率密度就是在该点附近的面积占整个概率函数的面积。如果均匀取点，就有 p(xi)=1a−bp(x_i) = \\frac{1}{a-b}p(xi​)=a−b1​，那么式子就变成熟悉的 1N∑f(x)p(x)\\frac{1}{N}\\sum f(x)p(x)N1​∑f(x)p(x) 了。 路径追踪 Path Tracing Whitted-Style 光线追踪对光线如下处理： 如果是光滑面的镜面反射/折射，就进行光线追踪； 如果是漫反射，就停止追踪； 而这两种处理都是存在问题的。 对于镜面反射，并不是只有能映出影像的镜面，也有抛光（Glossy）面只有高光没有清晰倒影的情况。这也就是说，这种模糊的镜面反射的反射区间比镜面反射略大。 对于漫反射面，其事实上也能产生反射效果。下图左侧展示了不考虑漫反射出的光的后果（天花板与两个立方体侧面），右侧则展现了考略的后果。 上一节的辐射度量学已经指出漫反射将光向四面八方折射的情况 这也正是通过辐射度量学来构建光线追踪的意义所在。 逐步推出路径追踪算法 接下来考虑一个简单场景中的情况：场景中有一个面光源、几个遮挡物体与待渲染点。在这个不自发光的点有 Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)cos⁡θidωiL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)cosθi​dωi​ 应用蒙特卡罗方法进行积分，均匀在半球面上进行采样： Lr(p,ωr)=∫Ω+f(x)dωi≈1N∑i=1Nf(x)p(ωi)p(ωi)=12πL_r(p,\\omega_r)=\\int_{\\Omega^+}f(x)\\mathrm{d}\\omega_i \\approx \\frac{1}{N}\\sum^N_{i=1}\\frac{f(x)}{p(\\omega_i)} \\\\ p(\\omega_i)=\\frac{1}{2\\pi} Lr​(p,ωr​)=∫Ω+​f(x)dωi​≈N1​i=1∑N​p(ωi​)f(x)​p(ωi​)=2π1​ 也就是说，在该点向外随机选择 N 个方向进行采样，如果该方向遇见一个光源，则着色结果加上该方向经过蒙特卡洛积分后的结果，就得到该点的直接光渲染结果。 如果发出射线的方向（ωi\\omega_iωi​）遇见的是物体，那么我们就将该物体往渲染点方向（−ωi-\\omega_i−ωi​）反射的光视为光源的光进行着色，这样得到的就是全局光照。 这种算法的名字叫分布式光线追踪，这种算法并没有错，但是显然，只需要数次折射，追踪的光线的数量就会指数级增长（折射 k 次，则有 NkN^kNk）条光路。这使得这种算法并不实用。 人们对这个问题的解决办法非常简单粗暴：如果每个着色点只有一个采样方向（N = 1），那么折射多少次都不会发生指数爆炸。这样的一个经过多次折射形成的线路就是一个路径。至于噪声问题，则用在一个像素上发出多条路径并取平均的方式进行解决。这就是路径追踪。 路径递归的终止条件被称为俄罗斯轮盘赌方法（Russian Roulette，RR）。即类似于俄罗斯轮盘赌，我们取定一个概率 P，每次只有 P 的概率返回值 LoP\\frac{L_o}{P}PLo​​ ，而 （1-P） 的概率返回 0。这样，返回值的期望不变，但是光线不能无限次的折射下去。 此时，我们的算法如下： 这是一个正确的路径追踪算法了，唯一的问题在于不够高效，低采样率的情况下效果并不好。 造成这种问题的原因在于我们采取了所有方向随机采样的采样方式，低采样率时到光源的方向的可能性低。 在光源采样的高效路径追踪 既然我们想采样到打到光源的路径，那么直接在光源上采样不就好了吗？ 此时，由于我们是在光源上采样，那么也就需要在光源上进行积分，因此需要将渲染方程改写到光源上。设想场景如下： 在光源上进行平均采样，则概率密度是 1A\\frac{1}{A}A1​。将立体角换到光源的立体角上有 dω=dAcos⁡θ′∥x′−x∥2\\mathrm{d}\\omega = \\frac{\\mathrm{d}A\\cos\\theta&#x27;}{\\|x&#x27;-x\\|^2} dω=∥x′−x∥2dAcosθ′​ 于是（在不被遮挡的时候） Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)dAcos⁡θ′∥x′−x∥2dAL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\frac{\\mathrm{d}A\\cos\\theta&#x27;}{\\|x&#x27;-x\\|^2}\\mathrm{d}A Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)∥x′−x∥2dAcosθ′​dA 不过这只是对光源情况的特殊考虑，对于间接光我们还是采用之前的算法并依然采用俄罗斯轮盘赌的算法，所以这时的算法形如 ： 路径追踪是很难处理点光源的情况的，我们可以把它做成很小的面光源 路径追踪是几乎 100% 正确的一种算法，其效果和照片几乎一致： 一些眺望：SideNotes 现代光线追踪的定义：不止于 Whitted-Style 光线追踪 以前，光线追踪仅仅指 Whitted-Style，现在，这个词还可以指各类光线传播的算法，例如（单向、双向）路径追踪、VCM/UPBP、光子映射（Photon Mapping）…… 如何均匀地半球面上采样：本课不涉及 如何在蒙特卡洛积分中选择最佳的概率密度函数：拓展至“重要性采样理论” RR 中随机数的生成方式很重要：Low Discrepancy Sequences （低差异序列/拟随机序列， 一种均匀分布随机数的替代序列） 结合着色点半球面与光源上的采样方法：可行，MIS（Multiple Importance Sampling） 理论 考虑对一个像素的多个路径进行加权处理 路径追踪得到的最后 Radiance 不是着色结果，也和着色结果没有线性对应关系。 色彩空间、伽马校正…… 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-14&amp;15：辐射度量学 Next：GAMES101-17：基于物理的材质（BRDF）","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"路径追踪","slug":"路径追踪","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"name":"蒙特卡洛积分","slug":"蒙特卡洛积分","permalink":"http://example.com/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"}]},{"title":"GAMES101-14&15：辐射度量学","slug":"GAMES101/GAMES101-13","date":"2023-08-04T15:18:19.000Z","updated":"2024-04-20T18:58:06.438Z","comments":true,"path":"/GAMES10113.html","permalink":"http://example.com/GAMES10113.html","excerpt":"前言 GAMES101-14:辐射度量学的意义、能量，功率与辐射强度（intensity）的定义。 GAMES101-15:辐射度量学的基本概念：辐照强度、辐射通量，BRDF，渲染方程，全局光照","text":"前言 GAMES101-14:辐射度量学的意义、能量，功率与辐射强度（intensity）的定义。 GAMES101-15:辐射度量学的基本概念：辐照强度、辐射通量，BRDF，渲染方程，全局光照 辐射度量学 为什么要研究辐射度量学：Whitted-Style 光线追踪尽管可以在一些场景表现不错，但是其建立完全是基于经验值和表现的效果的，而不是实际的物理规律，因此其值不可能完全真实准确。这就是为什么我们需要辐射度量学。 要进行严谨度量，我们就要先定义单位（中文均为个人翻译，课程中没有中文名）： 辐射能 Radiant Energy：辐射出的能量 Q (J)(J)(J)。 辐射速率/功率 Radiant flux（power）：单位时间内辐射/吸收/反射的能量。对于光源即“有多亮” .Φ=dQdt\\Phi=\\frac{\\mathrm{d}Q}{\\mathrm{d}t}Φ=dtdQ​ ，单位 W(Watt)/lm(lumen)\\mathrm{W(Watt)/lm(lumen)}W(Watt)/lm(lumen) 注意：下文和图形学中说到的能量往往是指 flux 而非 energy，因为我们总是在关心眼下发生的情况（实时）而非累计的结果。 辐射强度 Radiant Intensity：一个单位立体角的功率。 I(ω)=dΦdωI(\\omega)=\\frac{\\mathrm{d}\\Phi}{\\mathrm{d}\\omega}I(ω)=dωdΦ​，单位 cd(candela)=lmsrorWsr\\mathrm{cd(candela)=\\frac{lm}{sr}or\\frac{W}{sr}}cd(candela)=srlm​orsrW​。 类比弧度，立体角（Solid angel）是指 Ω=Sr2\\Omega=\\frac{S}{r^2}Ω=r2S​，其中 S 是对应的表面积，一个球的立体角是 4π4\\pi4π。将面积表示成半径 r、和 y 轴（竖直轴）的夹角 θ\\thetaθ、和水平面 x 轴的夹角 ϕ\\phiϕ 的组合，就有： Ω=Sr2=sin⁡θdθdϕ\\Omega=\\frac{S}{r^2}=\\sin\\theta\\mathrm{d}\\theta \\mathrm{d}\\phi Ω=r2S​=sinθdθdϕ 如果一个点光源均匀地向所有方向辐射光，那么 Intensity 就简单的有 I=Φ4πI=\\frac{\\Phi}{4\\pi} I=4πΦ​ 辐照强度 Irradiance：单位面积接收到的(投影后的)能量（flux）。 E(x)=dΦ(x)dS=ΦScos⁡θE(x)=\\frac{\\mathrm{d}\\Phi (x)}{\\mathrm{d}S}=\\frac{\\Phi}{S}\\cos \\theta E(x)=dSdΦ(x)​=SΦ​cosθ 单位 lux=lmm2\\mathrm{lux}=\\frac{lm}{m^2}lux=m2lm​。此处要求的能量与面积是垂直的，如果不垂直则需要投影。这正是 Blinn-Phong 模型中应用的“物体接收到的光取决于与法线的余弦”（Lambert's Cosine Law）的物理意义。 随着距离的增加，辐射强度 Intensity 不会发生改变，但是辐照度 Irradiance 会衰减。 辐射通量 Radiance：单位立体角且单位面积内的辐射能量。换句话说，通量就是单位立体角中的辐照度（理解吸收）或单位面积的辐射强度（理解发出）。通量是一个有方向的量。 L(p,ω)=d2Φ(p,ω)dωdScos⁡θL(p,\\omega)=\\frac{\\mathrm{d^2}\\Phi(p,\\omega)}{\\mathrm{d}\\omega\\mathrm{d}S\\cos\\theta} L(p,ω)=dωdScosθd2Φ(p,ω)​ 单位nit=cdm2nit=\\frac{\\mathrm{cd}}{\\mathrm{m^2}}nit=m2cd​。 对来自单位面积来自所有方向的辐射积分，就有该面积的所有能量。再对面积积分，则有物体的所有接收能量。 这些概念中单位相对而言并不重要，请注意理解概念本身。 BRDF：双向反射分布函数 BRDF 的作用在于，将物体吸收的能量（Irradiance）和指定角度发出（反射）的能量（Radiance）联系了起来。对于一个极小区域 dA\\mathrm{d}AdA，一束从 ωi\\omega _iωi​ 入射的辐射是： dE(ωi)=L(ωi)cos⁡θidωi\\mathrm{d}E(\\omega_i)=L(\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i dE(ωi​)=L(ωi​)cosθi​dωi​ 物体吸收后发射（或者说物体反射）辐射到不同的方向，对于一个指定的方向 ωr\\omega_rωr​，反射的能量记为 dLr(ωr)\\mathrm{d}L_r(\\omega_r)dLr​(ωr​)。 此时，可以记 BRDF 为： fr(ωi→ωr)=dLr(ωr)dEi(ωi)=dLr(ωr)L(ωi)cos⁡θidωif_r(\\omega_i\\rarr \\omega_r)=\\frac{\\mathrm{d}L_r(\\omega_r)}{\\mathrm{d}E_i(\\omega_i)}=\\frac{\\mathrm{d}L_r(\\omega_r)}{L(\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i} fr​(ωi​→ωr​)=dEi​(ωi​)dLr​(ωr​)​=L(ωi​)cosθi​dωi​dLr​(ωr​)​ BRDF 的图像描述了辐射会被反射到哪个方向，例如如果是镜面反射，那么图像就是仅在镜面反射方向有值，其他方向没有多少值。 反射方程与渲染方程 把该点的所有入射光的 BRDF 累加起来，就可以算出该点反射了多少光，即该点的反射方程： Lr(p,ωr)=∫H2fr(p,ωi→ωr)L(p,ωi)cos⁡θidωiL_r(p,\\omega_r)=\\int_{H^2}f_r(p,\\omega_i\\rarr \\omega_r)L(p,\\omega_i)\\cos\\theta_i\\mathrm{d}\\omega_i Lr​(p,ωr​)=∫H2​fr​(p,ωi​→ωr​)L(p,ωi​)cosθi​dωi​ 添加自发光项使得公式对光源也适用： Lr(p,ωo)=Le(p,ωo)+∫H2Li(p,ωi)fr(p,ωi→ωo)(n⃗⋅ωi⃗)dωi L_r(p,\\omega_o)=L_e(p,\\omega_o)+\\int_{H^2}L_i(p,\\omega_i) f_r(p,\\omega_i\\rarr \\omega_o) (\\vec{n}\\cdot\\vec{\\omega_i}) \\mathrm{d}\\omega_i Lr​(p,ωo​)=Le​(p,ωo​)+∫H2​Li​(p,ωi​)fr​(p,ωi​→ωo​)(n⋅ωi​​)dωi​ 此时方程就是渲染方程。需要指出的是涉及的向量的方向都是从 p 点指向外的，而且通过积分域的限制，我们排除了下半球内的积分，因为这个方向肯定不会对渲染起作用。（相当于 Blinn-Phong 模型中的那个 max() ）。而且通过积分，我们不仅可以处理多个点光源，也可以处理面光源。 全局光照 把上面的式子简单分析一下，其实就是：反射光=自发光+入射光BRDF余弦角。其中未知量只有入射光和反射光。于是我们经过一系列的简化就可以有： L=E+KLL=E+KL L=E+KL 其中 I 是单位矩阵，因为反射的和入射能量没有改变所以两侧 L 相等可以直接合并。 考虑到入射的 L 也可以是其他物体反射的 L，所以类似泰勒展开有 L=E+KL⇒L=(I−K)−1E⇒L=E+KE+K2E+K3E+…L=E+KL\\\\ \\rArr L=(I-K)^{-1}E \\rArr L=E+KE+K^2E+K^3E+\\dots L=E+KL⇒L=(I−K)−1E⇒L=E+KE+K2E+K3E+… 其中， E 即直接进入摄像机的光，KE 即直接打在物体表面的光，二次即一次物体反射的间接光照，三次即在物体上反射了两次才打到渲染物体上的光……依此类推。 光栅化可以较容易的处理前两项，但是很难处理后面的项。这也是为什么我们需要光线追踪。 将所有的光进行考虑得出的结果就是全局光照。下面给一些计算了不同次数反射的全局光照结果对比。 仅直接光（效果类似相机）： 一次弹射，直接光+间接光（E+KE+K^2E）: 两次弹射: 四次弹射(效果愈发接近人眼): 随着次数的增加，弹射对效果的影响愈发的小，也愈发的接近人眼的效果。 需要注意的是，一次和二次光照的时候，屋顶的灯光反而变黑了，这是因为这里光两次折射还没有折出灯管，因此造成了错误。 最后说了一些概率论基础，没有特别需要记的必要。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化 Next：GAMES101-16：辐射度量学与路径追踪","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"渲染方程","slug":"渲染方程","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"},{"name":"全局光照","slug":"全局光照","permalink":"http://example.com/tags/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"}]},{"title":"GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化","slug":"GAMES101/GAMES101-12","date":"2023-08-01T16:56:18.000Z","updated":"2024-04-20T18:58:06.437Z","comments":true,"path":"/GAMES10112.html","permalink":"http://example.com/GAMES10112.html","excerpt":"前言 GAMES101-14: AABB 包围盒的加速方法：均匀网格、KD-Tree 划分、BVH 划分","text":"前言 GAMES101-14: AABB 包围盒的加速方法：均匀网格、KD-Tree 划分、BVH 划分 均匀网格（Uniform Grid）/均匀空间划分 思想/步骤： 建立一个大的 AABB 包围盒包围对空间中的所有物体，包围盒划分成均匀的若干立方网格； 每个网格判断与物体（的表面）是否相交并记录； 光线穿过空间中的若干网格，如果穿过的网格是一个与物体有交点的网格，那么光线与物体就有可能有交点。此时，对物体进行求交操作；否则，不进行求交。 光线穿过网格的算法和光栅化中的扫描线算法是类似的 网格划分的疏密问题 太稀疏：加速效果不明显； 太密：引入太多无效的网格判断，效率降低； （三维空间）合适的格子数：约等于 27 * 物体数。 网格划分思想适用于大量尺度接近的物体均匀分布在空间中的情况，不适用于空间分布很不均匀的情况（局部引起太稀疏的问题） 空间划分（Spatial Partition） 均匀空间划分的明显问题在于：如果空间分布疏密不一，在大块空的地方做了许多没有必要的划分。如果对空间进行不均匀的划分那么性能就会更好。 下面例举三种划分结构： Oct-Tree（八叉树）：把三维空间划分为八份（二维则是四份），如果一块中有物体，则尝试划分得更小，否则就停下这一块的继续划分。 这种划分方式的问题在于，划分数量与空间维度有关，不同维度的空间会形成了不同的数据结构。 BSP-Tree：从不同方向用线/平面/超平面二分空间。这种方式高维难以计算且破坏 AABB 的简单性。 KD-Tree：每次沿一个维度切一刀，例如三维空间就可以依次沿 x，y，z 轴切，二维则沿 x，y 轴切，从而使划分与空间维度无关。最后会形成一个二叉树。 这一部分与多媒体数据课在向量空间归类的思想很相似 KD-Tree 为树设计的数据结构应该： 在内部节点上： 划分轴：此结点应该被哪个轴划分 划分位置：轴在哪个位置坐标划分 子结点指针 不存储内部有哪些物体 叶子结点：存储内部有哪些物体 当光线进入一个空间划分区： 如果该区域有交点，那么检查是否是叶子结点 是：检查是否与内部物体有交点 否：检查与哪个子划分有交点 和该区域无交点：什么都不用做 不过，KD-Tree 也有自己的问题，如： 难以判断三角形与空间盒的相交情况：例如一个小盒子，三个顶点都在盒子外但是面与盒子有交集的情况。 一个物体可能会被划分到多个盒子里，多次检测。 物体划分：BVH（Bounding Volume Hierarchy） BVH 的特点在于是按物体而非空间进行划分，对于一个包围盒，递归地将其划分为子空间并计算子空间的子包围盒的边界。重复这个过程，直到盒子足够小（例如大致都有 x 个 物体）即可。数据结构上，同样是叶子结点存物体的树。 划分维度上可以有许多技巧，例如类似 KD-Tree 的依次轮换维度，或者每次从盒子最长的维度划分；抑或着每次从中间物体的位置划分。总之，应该尽量让空间划分均匀。 存在O（N）算法找到中位数，快速选择算法。 需要注意，由于是按物体进行划分，从空间上来说，包围盒之间可以相交。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-12&amp;13：Whitted-Style 光线追踪（1） Next：GAMES101-14&amp;15：辐射度量学","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"均匀网格","slug":"均匀网格","permalink":"http://example.com/tags/%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC/"}]},{"title":"GAMES101-12&13：Whitted-Style 光线追踪（1）","slug":"GAMES101/GAMES101-11","date":"2023-08-01T04:32:02.000Z","updated":"2024-04-20T18:58:06.436Z","comments":true,"path":"/GAMES10111.html","permalink":"http://example.com/GAMES10111.html","excerpt":"前言 GAMES101-12:光栅化下的处理思路：阴影映射、软阴影 GAMES101-13:Whitted-Style 光线追踪与求交问题、AABB 包围盒","text":"前言 GAMES101-12:光栅化下的处理思路：阴影映射、软阴影 GAMES101-13:Whitted-Style 光线追踪与求交问题、AABB 包围盒 光栅化下的阴影处理：阴影映射（Shadow Mapping ） 着色是一种局部现象，不考虑整体因此处理不了阴影，为此，人们发明了 Shadow Mapping。 Shadow Mapping 的思路：一个点不在阴影含义是，这个点必须同时被光源和摄像机看到。 步骤： 从光源做一次光栅化，记录光源看到的点的深度信息。（不用进行着色） 从摄像机做一次光栅化，对每个点投影回去，如果和“从光源看”的深度指向的点不一致，那么说明这个点在阴影里，否则不在阴影里。 Shadow Mapping 的特点： 不需要知道场景的几何信息； 阴影会产生走样现象：光源处分辨率的限制； 阴影带来巨大开销； 只能处理硬阴影：即要么是阴影，要么不是阴影的情况； 只能处理点光源 浮点数对比有的时候有很多脏数据； 光栅化下也有一些软阴影处理方案，此处不加以介绍。通常都比较麻烦而且不一定准确。 软阴影 软阴影即介于阴影和无阴影之间的的边界是软边界，模糊过渡的一种阴影。产生这种现象的原因是光源本身有不可忽略的大小，即非点光源。 一个例子是日食下的日月，光源太阳不是点光源。如果地球上一地区完全接收不到太阳光，那么这个地方就在月亮的硬阴影里；如果太阳被月亮挡住了部分，那么就是月亮的软阴影部分；否则，完全不被挡住，无阴影。 Whitted-Style 光线追踪 光栅化通常都是快速且近似的方法，光线追踪通常都比较慢。 光线追踪对光线的约束（尽管这些在物理学中不一定正确） 光沿直线传播； 光线之间不相互碰撞； 光从光源出发，抵达人的眼睛，并且光路可逆； 光线投射 从眼睛（一个点）发出光线（eye ray）经过屏幕上一个像素打到物体表面得到一个交点，这个交点就是需要被着色的点（因此光线追踪不需要深度测试）。 如果光源发出的线（shadow ray）可以直接打到该点，就会有一次着色，否则结束。 这个点经过反射、折射（如果有）得到的二次交点们同样检查是否被 shadow ray 照亮。 把二次交点们发出的折射/反射的光（记为 second ray）对一次交点的着色结果累加到一次交点。 对二次交点当然也可以递归上述过程。 求交点 光线是一个有起点的射线，我们如下定义 r(t)=o+td⃗(0≤t&lt;∞)r(t)=o+t\\vec{d} (0\\leq t&lt;\\infty) r(t)=o+td(0≤t&lt;∞) 其中向量 d 是单位向量表示方向。 对一个隐式几何表面 f(x,y,z)=0f(x,y,z)=0f(x,y,z)=0 求交就是说 f(r(t))=f(o+td⃗)=0f(r(t))=f(o+t\\vec{d})=0 f(r(t))=f(o+td)=0 当然多个交点时取最近的。 对于一个显式几何，最简单的办法是对每个三角形求交。思想如下： 首先求射线和三角形所在平面的交点； 射线如上表示为 r(t)r(t)r(t)，平面表示为点 p′p&#x27;p′ 和法线 N⃗\\vec{N}N 的组合。就有 平面上一点表示为 (p−p′)⋅N⃗=0(p-p&#x27;)\\cdot\\vec{N}=0(p−p′)⋅N=0，代入有 (o+td⃗−p′)⋅N⃗=0(o+t\\vec{d}-p&#x27;)\\cdot\\vec{N}=0 (o+td−p′)⋅N=0 于是 t=(p′−o)⋅N⃗d⃗⋅N⃗ (0≤t)t= \\frac{(p&#x27;-o)\\cdot\\vec{N}}{\\vec{d}\\cdot\\vec{N}} \\ \\ \\ (0\\leq t)t=d⋅N(p′−o)⋅N​ (0≤t) 然后判断是否在三角形内。例如使用叉积 或直接应用 Moller Trumbore 算法： 用三角形的重心坐标有： O⃗+tD⃗=(1−b1−b2)P0⃗+b1P1⃗+b2P2⃗\\vec{O}+t\\vec{D}=(1-b_1-b_2)\\vec{P_0}+b_1\\vec{P_1}+b_2\\vec{P_2} O+tD=(1−b1​−b2​)P0​​+b1​P1​​+b2​P2​​ 其中 O⃗\\vec{O}O、N⃗\\vec{N}N、Pi⃗\\vec{P_i}Pi​​ 都是三个数的坐标，应用克莱默法则即可求解。 若 (1−b1−b2)(1-b_1-b_2)(1−b1​−b2​)、b1b_1b1​、b2b_2b2​ 都满足重心坐标系的要求（在 [0,1] 之间）那么就说明和三角形相交。 我们还可以 隐式三角形求交的优化算法：AABB 包围盒 现代模型往往有百千万级别的面数，如果依次按上述方法求交，无疑太慢了。对此的一种改进方法是包围盒：用一个简单图形（例如长方体）包围模型，如果和这个包围盒都无交点，那就不需要求和模型的交点。 如果将包围盒定义为三个方向的面都平行于一个轴面，那三个方向就都可以都简单记为一个 x/y/z 轴上区间的情况，这种包围盒就叫 AABB 包围盒（Axis-Aligned Bounding Box，轴对齐包围盒）。 AABB 包围盒的好处： 对于普通包围盒： t=p′−o⋅Nd⋅Nt=\\frac{p&#x27;-o\\cdot N}{d\\cdot N} t=d⋅Np′−o⋅N​ 对于轴对齐包围盒(以 x 轴为例)： t=px′−oxdxt= \\frac{p&#x27;_x-o_x}{d_x} t=dx​px′​−ox​​ 对每个轴上的对立面求进入的“时间”和离开的时间，中间的差即在两个面之间的时间。对三个对立面分别这样处理，并取交集，即 tenter=max(tin)t_{enter}=max(t_in)tenter​=max(ti​n) 且 tleave=min(tout)t_{leave}=min(t_out)tleave​=min(to​ut)，那么就能得到光线在 AABB 包围盒中滞留的时间。进行分析： tenter&gt;0t_{enter}&gt;0tenter​&gt;0 且 tleave&gt;tentert_{leave}&gt;t_{enter}tleave​&gt;tenter​，正常地和 AABB 盒相交； tenter&lt;0t_{enter}&lt;0tenter​&lt;0 且 tleave&gt;0t_{leave}&gt;0tleave​&gt;0，光源在 AABB 盒内，到处都相交； tleave&lt;0t_{leave}&lt;0tleave​&lt;0 ，盒子在光源后面，没有实际的交点。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-11&amp;12：曲线与面 Next：GAMES101-14：Whitted-Style 光线追踪(2) 包围盒求交的速度优化","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"软阴影","slug":"软阴影","permalink":"http://example.com/tags/%E8%BD%AF%E9%98%B4%E5%BD%B1/"},{"name":"阴影映射","slug":"阴影映射","permalink":"http://example.com/tags/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"Whitted-Style 光线追踪","slug":"Whitted-Style-光线追踪","permalink":"http://example.com/tags/Whitted-Style-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"求交点","slug":"求交点","permalink":"http://example.com/tags/%E6%B1%82%E4%BA%A4%E7%82%B9/"}]},{"title":"GAMES101-11&12：曲线与面","slug":"GAMES101/GAMES101-10","date":"2023-07-31T06:53:48.000Z","updated":"2024-04-20T18:58:06.436Z","comments":true,"path":"/GAMES10110.html","permalink":"http://example.com/GAMES10110.html","excerpt":"前言 GAMES101-11:贝塞尔曲线与B样条 GAMES101-12:贝塞尔曲线与B样条","text":"前言 GAMES101-11:贝塞尔曲线与B样条 GAMES101-12:贝塞尔曲线与B样条 贝塞尔曲线 Bézier Curve 贝塞尔曲线要求给定多于两个点，那么从第一个首尾两个点决定始末，中间的点决定倾向（往哪里弯）。 德卡斯特里奥算法（de casteljau's algorithm）有一种简单的递归画贝塞尔曲线的方法： 假设我们依次有四个点 b0,b1,b2,b3b_0,b_1,b_2,b_3b0​,b1​,b2​,b3​，即三次贝塞尔曲线；一个点在曲线上运动，定义时间t = 0的时候在起点 b1b_1b1​，t = 1 在终点 b0b_0b0​。 连接 b0,b1,b2,b3b_0,b_1,b_2,b_3b0​,b1​,b2​,b3​，找到三条连线线上的 t 位置，定义此点为 b01b^1_0b01​、b11b^1_1b11​、b21b^1_2b21​； 连接 b01b^1_0b01​、b11b^1_1b11​、b21b^1_2b21​，继续找 t 时刻位置得到 b02b^2_0b02​、b12b^2_1b12​； 连接 b02b^2_0b02​、b12b^2_1b12​ 找 t 位置的点 P(b03b^3_0b03​)； P 就是时间 t 的时刻贝塞尔曲线上的点。 下面给出代数写法。 对第一次递归的点可以写成形如 b01=(1−t)b0+tb1b_0^1 = (1-t)b_0+tb_1b01​=(1−t)b0​+tb1​ 的形式； 第二次递归的点等于b02=(1−t)b01+tb11=(1−t)2b0+2t(1−t)b1+t2b2b_0^2 = (1-t)b_0^1+tb_1^1=(1-t)^2b_0+2t(1-t)b_1+t^2b_2b02​=(1−t)b01​+tb11​=(1−t)2b0​+2t(1−t)b1​+t2b2​，可以看到系数是二次项展开的形式； 第 n 次递归同理…… 最终有 bn(t)=∑j=0nbjBjn(t)b^n(t)= \\sum^n_{j=0}b_jB^n_j(t) bn(t)=j=0∑n​bj​Bjn​(t) 其中 bin(t)=Cinti(1−t)n−i=(ni)ti(1−t)n−ib_i^n(t)= C_i^nt^i(1-t)^{n-i}=\\binom{n}{i}t^i(1-t)^{n-i} bin​(t)=Cin​ti(1−t)n−i=(in​)ti(1−t)n−i 其中 tit^iti 前面的系数都是在表示组合数。 贝塞尔曲线的一些性质： 曲线的起点是第一个给出点，终点是最后一个点； 对于最常用的三次贝塞尔曲线，起点处斜率为 b′(0)=3(b1−b0)b&#x27;(0)=3(b1-b0)b′(0)=3(b1−b0)，终点处为 b′(3)=3(b3−b2)b&#x27;(3)=3(b3-b2)b′(3)=3(b3−b2)； 对贝塞尔曲线仿射变换等于对点进行仿射变换再求其贝塞尔曲线； 贝塞尔曲线一定在给定点的凸包内； 凸包：想象一个撑在几个钉子上的橡皮筋，橡皮筋即钉子们的凸包 分段贝塞尔曲线与连续 多次贝塞尔曲线存在的问题：多次贝塞尔曲线点对线的控制不够直观明显，很难体现具体一个点对曲线的影响。 因此，最常用的贝塞尔曲线是三次贝塞尔曲线，通过拼接多个贝塞尔曲线形成长曲线。这样一来，我们就需要考虑在拼接处的连续问题。要讨论两段曲线是否连续，我们先定义连续的概念： G0G^0G0(C0C^0C0)连续：两个曲线在该点首尾相连 G0G^0G0：拼接点切向量方向相同 C0C^0C0：拼接点切向量方向和大小均相同 GnG^nGn：拼接点切向量从 1 阶直到 n 阶导数的方向相同 CnC^nCn：拼接点切向量从 1 阶直到 n 阶导数的方向和大小均相同 其中 CiC^iCi 叫参数连续，GiG^iGi 叫几何连续。 B 样条 样条：一条可控的曲线，分段定义的多项式参数曲线。 早期工程制图时，制图者将一段柔性的条板固定住，中间用一些钉子等工具迫使条板弯曲并固定来得到一条需要的曲线。这个条板就是样条。 B 样条是指基函数样条（basis spline）。B 样条是贝塞尔曲线的一种一般化，在贝塞尔曲线里基函数是伯恩斯坦多项式。B 样条有一些很好的性质，例如局部性：更改一个点不会影响到整条曲线而可以只修改其局部。 一个基函数空间里，所有的函数可以用基函数的线性组合表示。 伯恩斯坦多项式里，每一个项是一个基函数。 贝塞尔曲面 在两个方向都进行贝塞尔曲线，例如水平方向每隔一段进行一次贝塞尔，然后竖直方向上没处把对应的取值作为控制点进行贝塞尔。 网格的几何处理 网格细分：网格拆分为更细的网格，并使模型变得更光滑； 网格简化：网格太细合为更大的网格； 网格正则化：让网格更接近“正”图形（如正三角形），减少网格的依赖。 网格细分 网格细分的两步操作：分出更多的网格、调整顶点位置使得模型更光滑。 Loop 细分 请注意这里的 Loop 是人名而非循环 步骤： 将一个三角形的中点连接，分成四个小三角形，这些中点是新的顶点； 对于新顶点，其在两个三角形的公用边上。假定此边两个老顶点为 AB，非此边上的老顶点为 CD。那么新顶点的位置改为：38(A+B)+18(C+D)\\frac{3}{8}(A+B)+\\frac{1}{8}(C+D)83​(A+B)+81​(C+D); 对于老顶点，其是多个三角形的共用顶点。那么它的新位置为P′=(1−nu)P0+u∑PiP&#x27;=(1-nu)P_0+u\\sum P_iP′=(1−nu)P0​+u∑Pi​，其中 P0P_0P0​ 是该点原本坐标，PiP_iPi​ 是与其通过一条边直接连接的点的坐标； n 是该点的度，即有多少个边与之相连； 若 n=3，则 u=316u=\\frac{3}{16}u=163​，否则，u=38nu=\\frac{3}{8n}u=8n3​ 老顶点的公式暗示：一个点如果连接的点越多，那么这个点的新坐标受周围点的影响就越大，否则，受自己的影响更大。 Catmull-Clark 细分 Catmull-Clark 可以对任意情况的网格使用而不局限于三角形网格。 定义奇异点：任何度不为 4 的顶点。 步骤： 每个边的中点和每一个面的中点都是新的顶点，并且连接一个面内的边中点和面中点； 经过这么一次细分以后，所有的非四边形面都不见了，而且同时会增加原本非四边形面那么多的奇异点。 对于 面中点：四个相邻老顶点的平均 边中点：两个相连的老顶点和两个面中点的平均 老顶点：四个面中点的一倍、四个边中点的两倍、本身位置的四倍的和进行平均 网格简化 有时我们希望在保留整体大致形状的情况下减少面的数量降低运算的压力，就需要网格简化。一种网格简化算法是边坍缩。边坍缩即把一个边两边的点挪动到一起使得该边“坍缩消失”。为了解决哪些边应该坍缩、探索后的点应该在哪的问题，我们则需要使用到二次误差度量算法。 二次度量误差：坍缩后的点的位置是原先有关面上点的距离的平方和（L2距离）的最小值的位置。 于是算法的核心思想：维护一个优先队列存储每条边坍缩会带来的二次度量误差，依次坍缩带来误差小的边，并更新受影响的边的误差值。 这是一种贪心算法，但是整体的效果还是不错的 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-10&amp;11：隐式几何与显式几何 Next：GAMES101-12&amp;13：Whitted-Style 光线追踪（1）","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://example.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"},{"name":"B 样条","slug":"B-样条","permalink":"http://example.com/tags/B-%E6%A0%B7%E6%9D%A1/"},{"name":"网格简化","slug":"网格简化","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96/"},{"name":"网格细分","slug":"网格细分","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%BB%86%E5%88%86/"},{"name":"Loop 细分","slug":"Loop-细分","permalink":"http://example.com/tags/Loop-%E7%BB%86%E5%88%86/"},{"name":"Catmull-Clark 细分","slug":"Catmull-Clark-细分","permalink":"http://example.com/tags/Catmull-Clark-%E7%BB%86%E5%88%86/"}]},{"title":"GAMES101-10&11：隐式几何与显式几何","slug":"GAMES101/GAMES101-9","date":"2023-07-30T16:24:59.000Z","updated":"2024-04-20T18:58:06.455Z","comments":true,"path":"/GAMES10109.html","permalink":"http://example.com/GAMES10109.html","excerpt":"前言 GAMES101-10:隐式几何","text":"前言 GAMES101-10:隐式几何 GAMES101-11:显式几何 用三角形面并不能很好的面对所有的情形，例如：庞大的城市如何简化远景、狗身上繁复细密的毛发、轻薄半透的纱衣…… CG 中将几何分为隐式几何与显式几何。下面分别讨论。 隐式几何 隐式几何：不指明点的位置，但是指明点的关系。例如 x2+y2+z2=1x^2+y^2+z^2=1x2+y2+z2=1。更通用地，隐式几何指明 f(x,y,z)=0f(x,y,z)=0f(x,y,z)=0。 隐式几何很难判断有满足条件的点都有哪些，但是很容易知道指定的一个点是否满足条件（在几何面上）。 在简单的几何情况下，我们容易写出f（x），但是几何体过于复杂时，虽然也可以找到合适的函数（傅里叶？），但是我们可以采用构造实体几何（CSG）的办法： 构造实体几何：对基本的隐式几何体进行基本的布尔运算（交并补等）得到复杂的几何（参考工图作业图）。 此外对于隐式几何我们还可以用距离函数： 距离函数：对任意一个点定义与几何体的，例如在面上距离为 0，面外为正，面内为负。 通过距离函数我们可以实现两个图形相融合的效果（空间中的点同时受到两个面的距离的拉扯），例如 空间中的一个点在图形 AB 的距离分别是 a，b，那么最后距离为 a+b，最后找出 a+b = 0 的地方就是融合后的新面上的地方。 为了表示好复杂情况下的等距离点的集合，我们应用水平集这个概念表示同一个水平线的点的集合，类似等高线。 如果定义在三维，存储为纹理图，那么我们就可以找到一个有同一特征的面形成纹理。 隐式几何我们还可以很方便的表示分形图形。 显式几何 显示几何的定义方法是直接给出（例如前面章节提到的三角形面）或参数映射（例如每个 （u，v）都能映射到一个（x，y，z））。 相对地，显式几何难以判断点是否在几何面上。 显式几何的一些例子： 点云：用一堆点表示面，可以表示任何图形，通常会被转化成多边形面。 多边形面：用多个三角形面拼接成图形 obj格式：一种存储模型的格式，存储用点和点的联系关系。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-9&amp;10：纹理映射的具体内容 Next：GAMES101-11&amp;12：曲线与面","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"隐式几何","slug":"隐式几何","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"显式几何","slug":"显式几何","permalink":"http://example.com/tags/%E6%98%BE%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"构造实体几何","slug":"构造实体几何","permalink":"http://example.com/tags/%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95/"},{"name":"距离函数","slug":"距离函数","permalink":"http://example.com/tags/%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0/"}]},{"title":"GAMES101-9&10：纹理映射的具体内容","slug":"GAMES101/GAMES101-8","date":"2023-07-29T06:00:12.000Z","updated":"2024-04-20T18:58:06.454Z","comments":true,"path":"/GAMES10108.html","permalink":"http://example.com/GAMES10108.html","excerpt":"前言 GAMES101-9:重心坐标、映射办法、纹理应用。 GAMES101-10:纹理应用。","text":"前言 GAMES101-9:重心坐标、映射办法、纹理应用。 GAMES101-10:纹理应用。 插值与重心坐标系 Gouraud 和 Phong 着色模型都要求在三角形内部插值，只是插值的不同，为了解决这个问题，我们应用重心坐标系。 对于任意三角形 △ABC\\triangle ABC△ABC 所在平面内点 P 有： P(x,y)=αA+βB+γCα+β+γ=1P(x,y) = \\alpha A + \\beta B + \\gamma C \\\\\\alpha+\\beta+\\gamma=1 P(x,y)=αA+βB+γCα+β+γ=1 当点在三角形内，则 α β γ\\alpha\\ \\beta\\ \\gammaα β γ 均为非负数。 这就是重心坐标系，通过重心坐标系，我们可以将三角形内的点坐标写成 (α,β,γ)(\\alpha,\\beta,\\gamma)(α,β,γ) 的形式。 已知 P 点的坐标，求重心坐标的办法如下： 连接 PA、PB、PC，把 △ABC\\triangle ABC△ABC 分成三个小三角形 △ABP\\triangle ABP△ABP、△APC\\triangle APC△APC、△PBC\\triangle PBC△PBC。 定义一个顶点对应的小三角形是与它不相邻的小三角形。如 A 对应 △PBC\\triangle PBC△PBC 定义三角形面积为 SSS 由于三角面积S=12l⋅h=12∣a⃗∣∣b⃗∣sin⁡θ=12∣a⃗×b⃗∣S=\\frac{1}{2}l\\cdot h=\\frac{1}{2}|\\vec{a}||\\vec{b}|\\sin\\theta=\\frac{1}{2}|\\vec{a}\\times \\vec{b}|S=21​l⋅h=21​∣a∣∣b∣sinθ=21​∣a×b∣，有：α=S△AS=BP⃗×BC⃗BA⃗×BC⃗β=S△BS=AP⃗×AC⃗BA⃗×BC⃗γ=S△CS=1−α−β\\alpha=\\frac{S_{\\triangle A}}{S}=\\frac{\\vec{BP}\\times\\vec{BC}}{\\vec{BA}\\times\\vec{BC}}\\\\ \\beta=\\frac{S_{\\triangle B}}{S}=\\frac{\\vec{AP}\\times\\vec{AC}}{\\vec{BA}\\times\\vec{BC}}\\\\ \\gamma=\\frac{S_{\\triangle C}}{S}=1-\\alpha-\\beta\\\\ α=SS△A​​=BA×BCBP×BC​β=SS△B​​=BA×BCAP×AC​γ=SS△C​​=1−α−β 当 α β γ\\alpha\\ \\beta\\ \\gammaα β γ 均为 13\\frac{1}{3}31​ 时，该点就是三角形的重心。重心将三角形分为三个面积相等的小三角形。 写成坐标就是： α=(y−yB)(xC−xB)−(x−xB)(yC−yB)(yA−yB)(xC−xB)−(xA−xB)(yC−yB)\\alpha=\\frac{(y-y_B)(x_C-x_B)-(x-x_B)(y_C-y_B)}{(y_A-y_B)(x_C-x_B)-(x_A-x_B)(y_C-y_B)} α=(yA​−yB​)(xC​−xB​)−(xA​−xB​)(yC​−yB​)(y−yB​)(xC​−xB​)−(x−xB​)(yC​−yB​)​ 这个公式没啥记忆的必要，知道向量形式公式咋来就行。 此外还需要注意，由于重心坐标没有投影不变性，因此插值应该在投影前完成而非投影后。 纹理映射 下面是一个简单的纹理映射逻辑： 我们已经知道了每个顶点对应的uv坐标是什么 对于每个像素/屏幕采样点的坐标 插值得到 uv 坐标 查询 uv 坐标对应的值 texcolor 像素的“颜色”（通常来说，漫反射系数）就设为 texcolor。 纹理放大带来的问题 如果纹理太小，分辨率太高，那么就相当于放大了纹理，每个像素求得的 uv 坐标将是小数。此时查询 uv 坐标的 texcolor 我们可以这么做： 对非整数的 uv 坐标直接取整：会导致多个连续像素对应同一个纹素（texel），导致马赛克。 双线性插值：综合考虑上下左右四个纹素的远近关系进行插值，像素过渡更自然连续。 双三次插值：综合考虑最近 16 个纹素的远近关系进行插值，像素过渡更自然连续，但是开销也比双线性更大。 纹理过小带来的问题 如果纹理太细小，那么一个像素对应太大的纹理区域，那么直接采样带来的结果和之前光栅化采样类似，采样频率过于稀疏，导致走样，产生摩尔纹锯齿等现象。超采样能解决问题，但是开销巨大，其他的一些解决办法是： Mipmap Mipmap 可以进行快速、近似、方形的一个范围内的平均值查询。 Mipmap 的思路是，如果使用范围查询，快速查询像素对应区域内纹素的平均值，那么也就不需要采样（点查询），也就规避了采样的问题了。 点查询即给定一个点查询对应点的值，范围查询则要求查询一个范围内的值，具体到此处是平均值。 Mipmap 会对每个图像不断构造分辨率变为原来 12×12\\frac{1}{2}\\times\\frac{1}{2}21​×21​ 后的图像形成层级关系。例如第零层是原图 128×128，那么第一层是 64×64，第二层是 32×32……依此类推。通过数学可以简单地证明这样做带来的开销并不算很大，极限多占用额外的 13\\frac{1}{3}31​ 空间。 Mipmap 也就是计算机视觉中的图像金字塔。 对于一个像素，我们求得它的覆盖的正方形面积（通过求它的邻居映射到哪个 uv 坐标取距离中间值或直接取像素四边对映射坐标等等）。根据边长为 L ，它对应的层级是D=log⁡2LD = \\log_2LD=log2​L,于是取在该层 mipmap 的值即可。 如果求得层级是非正数，那么直接舍入会带来割裂感。我们可以使用插值的办法解决 1.8 层这样的问题。 三线性插值：在下舍的层级进行双线性插值；在上入的层级进行双线性插值，最后对两层结果进行线性插值。 Mipmap 并不是完美的，下图展示了 由于 Mipmap 和三线性插值“平均”的特点导致远处过糊的问题。 各向异性过滤 各向异性过滤对 x 轴、y 轴可以单独压缩，通过这种方式，我们可以解决一个像素对应一个长方形纹理区域的问题，从而带来更好的效果。但是，各向异性过滤不能解决斜向四边形等问题。 各项异性过滤的极限是原图储存的三倍，而非三分之一。 纹理映射的应用 从 GPU 的角度看：纹理就是一段存在内存中的数据，GPU 可以对其进行点查询或范围查询。由此可以 启发我们对纹理映射的应用。 环境光照/环境光映射：记录哪个位置有（直接/间接）光形成纹理图，映射以后就能得到一种类似镜子的、看到周围环境的效果。 环境光映射球/立方：我们可以用“一个绝对光滑的球”记录一个环境里所有的光照来源方向。 凹凸贴图：定义一个点相对于附近的点的高度改变法线方向结果或者直接定义其法线方向，从而得到橘子皮似的凹凸表现结果。 首先计算出原来的法线（插值），求其在 uv 方向的偏导数，进而得到其垂直的法线结果，也就是我们要的“假法线”。 位移（displace ment）贴图：真的去偏移顶点而不是欺骗眼睛。 凹凸贴图的缺点是图像的边缘不会真的变得凹凸出现错误，内部的假凹凸也不会在邻近区域产生阴影。 但是位移贴图要求模型足够细，采样跟得上位移偏移的变化的频率。 3D纹理：通过三维噪声生成纹理贴图，达到处处有贴图的效果，即使一个物体被劈开，内部依然可以得到对应的贴图。 预计算着色：把着色结果记录在纹理图中。例如眉毛下对眼睛产生的阴影，规避一些影子计算的问题。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-7&amp;8：着色、纹理与图形管线 Next：GAMES101-10&amp;11：隐式几何与显式几何","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"重心坐标","slug":"重心坐标","permalink":"http://example.com/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"},{"name":"Mipmap","slug":"Mipmap","permalink":"http://example.com/tags/Mipmap/"},{"name":"线性插值","slug":"线性插值","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"}]},{"title":"GAMES101-7&8：着色、纹理与图形管线","slug":"GAMES101/GAMES101-7","date":"2023-07-26T13:01:54.000Z","updated":"2024-04-20T18:58:06.453Z","comments":true,"path":"/GAMES10107.html","permalink":"http://example.com/GAMES10107.html","excerpt":"前言 GAMES101-7、GAMES101-8:着色（Shading）、Blinn-Phong 着色模型、着色频率、纹理映射、图形管线","text":"前言 GAMES101-7、GAMES101-8:着色（Shading）、Blinn-Phong 着色模型、着色频率、纹理映射、图形管线 仅仅进行光栅化是不够的。想象一个纯色的方块，将它放在空间中，如果四面的颜色是一致，那么我们反而会觉得不够真实。因为我们期待会有明暗变化。也就是 Shading。 注：从本节开始，所引用的图片既有来源于 GAMES101 课程截图，亦有来源于西安电子科技大学《计算机图形学》课程的课件。 着色 Shade 指的是对物体对阳光遮挡产生的阴影。在绘画领域（例如素描）中，绘画者使用不同浓淡、疏密的墨水/线条来表现光线的明暗变化，这样的过程被叫做 Shading。在计算机图形学领域，Shading 基本上做的依然是这种工作，即根据表面和光线等条件确定表面的颜色。 shade 不等于 shadow，我们在这里只关注物体本身的明暗变化，不关心阴影的产生 定义一些概念 定义下面这么一些概念 着色点 p 着色点 p 的性质，例如颜色、闪亮程度（反光） 法线向量 n：垂直于 p 局部表面指向外面 观察者方向 v：从 p 指向观察的眼睛的方向 光线方向 l：从 p 指向光源的方向 Blinn-Phong 反射模型 模型将光分为三种： 高光区域：被光直接打到发生镜面发射的区域 漫反射区域：被光直接打到发生漫发射的区域 环境光区域：没有直接被光打到但是被其他地方反射出来的光照亮的区域 下面依次讨论 漫反射公式 我们认为漫反射会把光均匀的反射给所有的方向。此时，影响 shading 的因素是 这个局部平面接受到了多少来的光 接收到的光有多强 物体反射光的强度：我们知道物体表面会吸收一些光反射一些光 一个表面对于一束光线能接收到多少我们认为取决于法线方向与光线方向的夹角余弦值 cos⁡θ=n⃗⋅l⃗\\cos \\theta = \\vec{n}\\cdot\\vec{l}cosθ=n⋅l。 如果我们已经知道点光源向所有方向散发出的光强总共是 III，那么在距离点光源 rrr 的位置，总共 III 的光的强度（能量）散布在以 rrr 为半径的球上。球上任意一点的光强就是Ir2\\frac{I}{r^2}r2I​ 于是得到如下漫反射着色公式 Ld=kdIr2max(0,n⃗⋅l⃗)L_d=k_d\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{l}) Ld​=kd​r2I​max(0,n⋅l) 其中，max 函数的作用是丢弃从法线方向的反方向传过来的光线，kdk_dkd​ 是反射系数。 如果定义表面对 RGB 三色的不同反射系数，也就定义了表面对不同光的吸收程度。换言之，定义了物体表面的颜色。 下面是光源和位置不变时，不同 kdk_dkd​ 对物体表现的影响。 注意，漫反射意味着从任何方向看亮度都是一致的，这个定义没有暗示漫反射区域的亮暗。 高光公式 高光区域接近于产生镜面反射，我们只有在接近反射方向的时候才能看见明亮的光。 求光源方向 lll 关于 nnn 对称的 l′l&#x27;l′ 与观察方向 vvv 的接近程度比较不方便。衡量观察方向是否接近采用的方法如下： 求 lll 和 vvv 的角平分线方向上的向量（半程向量）hhh：由于 lll 和 vvv 都是单位向量，因此很方便地有h⃗=v⃗+l⃗∣∣v⃗+l⃗∣∣\\vec{h} = \\frac{\\vec{v}+\\vec{l}}{||\\vec{v}+\\vec{l}||} h=∣∣v+l∣∣v+l​ 计算 h⃗\\vec{h}h 和 n⃗\\vec{n}n 的余弦值 cos⁡α\\cos \\alphacosα 于是得到如下高光着色公式 Ls=ksIr2max(0,n⃗⋅h⃗)pL_s=k_s\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{h})^p Ls​=ks​r2I​max(0,n⋅h)p 其中指数 p 是控制高光大小的，即定义多接近反射方向算“接近”。通常取值在 100~200 下图展示了 cos 函数随指数的变化 下图展示了系数对高光的影响 环境光公式 环境光在不同的物体之间来回反射，我们简单地认为环境光是一个常量。公式为 La=kaIaL_a = k_aI_a La​=ka​Ia​ IaI_aIa​ 是环境光的强度，LaL_aLa​ 是环境光在物体表面造成的亮度 着色频率 前面讨论的模型是针对一个着色点进行的，着色频率即选取着色点的疏密。 有三种着色的方式，它们有不同的着色频率： Flat 着色：对一个面选取一个着色点，以该着色点的结果对整个面着色； Gouraud 着色：把每个顶点视为着色点，面内部的颜色使用线性插值得到；下面是计算插值的两种方式： 直接插值 增量法：利用前一步的计算结果加上增量得到当前的结果 当扫描线增加一个单位变为 y+1y+1y+1，对线上的点A、B 2.当逐个处理非线上的点，xxx 变为 x+1x+1x+1 Phong 着色：对面上的每一个像素点都进行着色，这些面内的着色点的法线方向是根据顶点法线方向插值得到。法线方向插值公式如下： 通常地说，Flat 着色（均匀着色）的着色结果最不准确；Gouraud 着色更加精细，但是也会有高光错误的问题；Phong 模型在三者中最精细但是计算量也远大于前二者。但是这种区别不是绝对的，随着技术的进步，如今模型的面数越来越多。而在面够多够小的情况下，Gouraud 甚至 Flat 也能取得不错的效果，当然，这种情况下由于面太多，它们的计算量也会升高。 如果面数多余像素数，那么 flat shading 的着色频率甚至比 phong shading 还高 点的法线向量的求法 数学告诉我们面的法线向量的求法（利用法线与所有面内向量垂直的特性），对于每个顶点，我们定义它的法线向量是它邻接的面的法线向量的（加权）平均： Nv=∑iNi∥∑iNi∥N_v = \\frac{\\sum_iN_i}{\\|\\sum_iN_i\\|} Nv​=∥∑i​Ni​∥∑i​Ni​​ 使用面积进行加权则： Nv=∑iSiNi∥∑iSiNi∥N_v = \\frac{\\sum_iS_iN_i}{\\|\\sum_iS_iN_i\\|} Nv​=∥∑i​Si​Ni​∥∑i​Si​Ni​​ 面内像素法线求法见上面 Phong 着色部分 图形管线（实时渲染管线） 简单地说，渲染管线就是将从 MVP 变换至今的所有流程组合在一起的过程（类似流水线的概念） 简要解读，步骤如下： 顶点处理： MVP 变换、顶点着色； 三角形处理：屏幕空间中的点生成三角形； 只要知道点和点之间的关系，我们没有必要对边进行 MVP，对点进行就够了 光栅化：打散成 fragment：每个 fragment 通常对应一个像素，但是如果应用 MSAA 等，那么多个也就 fragment 才能对应一个像素了； fragment 处理：对 fragment 进行深度检测、（可见的像素）着色； 帧缓存操作：放入缓存（buffer）中输出。 着色与着色器（Shader） 着色有两个可以发生的步骤，一是顶点处理时的顶点着色 Gouraud 着色，一是片段（fragment）处理时的 Phong 着色。 进行着色处理的代码就是着色器（Shader）。根据着色方式的不同，也就分为顶点着色器和像素/片段着色器。可编程 Shader 即我们自己编写一段逻辑操作硬件进行着色处理，这种逻辑会对每一个顶点/片段应用一次。 Shader 逻辑决定了像素颜色应该是什么。 一个可以写和探索 Shader 的网站:shadertoy 纹理映射（Texture Mapping） 在应用同一个模型同一个着色方案的时候，这些模型有相同的高光区域和漫反射，这就是材质。但是，我们依然希望一个物体表面上不同的点有不同区别，例如颜色。换言之我们需要一种对模型表面每个点的不同属性的表达方式，这即是纹理。 以 blinn-phong 公式为例 Ld=kdIr2max(0,n⃗⋅l⃗)L_d=k_d\\frac{I}{r^2}max(0,\\vec{n}\\cdot\\vec{l})Ld​=kd​r2I​max(0,n⋅l)，我们可以认为纹理就是决定了每个点 kdk_dkd​ 这一部分的取值应该是多少。 如果我们将一个模型表面展开，那么所有点都可以在一个平面上表示。因此我们用一个平面图（纹理图）存储点的属性，再将纹理图的点投射对应到物体表面上的点，那么模型就有了纹理。这就是纹理映射。 纹理图上点的坐标使用（u,v）表示。因此 uv 图即纹理坐标图。我们规定 u，v 的取值范围均为 [0,1][0,1][0,1] ，但是并不要求 uv 图必须是正方形。可视化时，我们还可以将 u 方向大用偏红，v 方向大用偏绿进行表示。 注意：没有规定一个模型的表面和 uv 图的点是一一对应的，一个 uv 坐标完全可以对应多个模型点坐标 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-6(2)：深度检测与 Z-buffer 算法 Next：GAMES101-9&amp;10：纹理映射的具体内容","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"着色器","slug":"着色器","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"},{"name":"Blinn-Phong 着色模型","slug":"Blinn-Phong-着色模型","permalink":"http://example.com/tags/Blinn-Phong-%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B/"},{"name":"纹理","slug":"纹理","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"uv 图","slug":"uv-图","permalink":"http://example.com/tags/uv-%E5%9B%BE/"},{"name":"图形管线","slug":"图形管线","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/"}]},{"title":"GAMES104-1&2：课程介绍、游戏引擎的层级","slug":"GAMES104/GAMES104-1","date":"2023-07-22T12:54:09.000Z","updated":"2024-04-20T18:58:06.458Z","comments":true,"path":"post/20230722205409.html","permalink":"http://example.com/post/20230722205409.html","excerpt":"前言 GAMES104-1:介绍 GAMES104-2：游戏引擎的层级结构","text":"前言 GAMES104-1:介绍 GAMES104-2：游戏引擎的层级结构 这节课介绍了什么 游戏引擎的基础结构：有几层结构？为什么要这样做？ 渲染：我们拿模型、材质、光照、渲染管线……去干些什么？ 动画 物理 游戏逻辑（Gameplay） 其它：特效、寻路、镜头 工具集：C++ Reflection 在线游戏 前沿技术 游戏引擎的结构 由上而下，我们可以简单做如下分层： 工具层：使用引擎的时候，我们就在不断调用各种编辑器：动画编辑器、关卡编辑器、资源管理器…… 功能层：物理计算、动画计算、渲染、脚本、镜头、输入……让游戏能看得见、动起来、可以玩 资源层：数据与资源的加载处理。 不同的资源格式不同需要统一、存储方式对于游戏引擎并不一定是最高效的 核心层：内存管理、线程、进程处理 平台层：OS差异、输入设备、发行平台、图像API…… 第三方库、中间件：在每一层都有不同的专精工具，它们如何与游戏引擎配合交流？ 以制作一个动画系统为例 资源层的工作：由资源到资产 将资源（resource）转化为资产（asset），舍弃不需要的信息，转化为适合机器处理的格式。 例如，分层信息、压缩算法导致的不高效 GUID：每个资产一个有唯一的身份识别 管理资产的生命周期：不断的加载与卸载、GC 功能层的工作：Tick 让游戏活起来：每一次 tick 计算逻辑和渲染。 逻辑：A 有没有打中 B ？A 要不要向前运动 x 米？ 渲染：光照、shader…… 功能的多线程问题： 早期：固定数个线程 现代主流：Thread Fork。例如 animation、物理等比较并行的东西用不同线程。 更好：Job system。分为不同的原子任务给任何有空的核心，但是难点是同步。 核心层 数学库 引擎中相对于精度，更注重速度 数据结构与容器：默认的结构可能不适合游戏。 例如，c++ vector 容量不够是按倍数扩张 内存管理：宗旨：尽可能放在一起、尽可能顺序访问、尽可能按块读写管理 平台层 其他部分的逻辑应该平台无关 平台差异 图形API：DX11、DX12、Vulkan 硬件不同、甚至文件路径的标记格式 工具层 可用性：让创作者简单地创造 DCC（Digital content creation）：不同的内外编辑器数据导入导出 为什么要分层 封装解耦：每一层都不需要关心其他层是怎么做事的。只要负责接收处理就好了。 这种解耦的思想在开发过程中时常遇见，分层、接口、消息广播……因为我们总是倾向于各司其职，而不是为了一件小事让所有人大动干戈。","categories":[{"name":"GAMES104","slug":"GAMES104","permalink":"http://example.com/categories/GAMES104/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"GMAES104","slug":"GMAES104","permalink":"http://example.com/tags/GMAES104/"},{"name":"导论","slug":"导论","permalink":"http://example.com/tags/%E5%AF%BC%E8%AE%BA/"}]},{"title":"GAMES101-6(1)：反走样","slug":"GAMES101/GAMES101-6-1","date":"2023-07-22T07:09:27.000Z","updated":"2024-04-20T18:58:06.451Z","comments":true,"path":"/GAMES1010601.html","permalink":"http://example.com/GAMES1010601.html","excerpt":"前言 GAMES101-P6：反走样","text":"前言 GAMES101-P6：反走样 走样现象 瑕疵（Artifact）：图形学中的一切错误、误差、不准确等。 经过采样以后，会看到明显的锯齿边缘，这是一种走样现象。 常见的走样现象：锯齿、摩尔纹、频闪效应 走样不仅可以发生在空间中，时间上也可以走样。例如频闪效应。 采样现象产生的原因：信号变化的频率对于采样频率而言高。（奈奎斯特定理） 采样频率高于信号频率两倍，才能完全恢复信息。 傅里叶变换 傅里叶变换：任何函数可以可以用一系列的基本三角函数的组合表示。 通过傅里叶变换我们可以将图像由时域迁移到频域。并且可以发现，对于大部分正常的图像，大部分信息集中在低频，高频信息很少。 我们应用滤波： 高通滤波：我们忽略掉低频信息，只保留高频信息，那么就能得到图像的边界（像素迅速变化的地方）。 低通滤波：我们忽略掉高频信息，只保留低频信息。那么就能得到模糊的图像。 保留区间内频率：一些不太明显的边界（太明显的当然是非常高频的信息）。 我们可以认为：滤波=卷积=平均（卷积的概念见维基） 卷积定理：时域上两个信号的卷积等价于频域上它们信号的乘积。 越大的卷积盒会保留越低的频率，带来越模糊的图像。 从频谱的角度理解采样： 采样就是在不同的频域上复制原有的频谱 采样率不够高，那么不同频域上的频谱就会混叠在一起 反走样的办法 增加采样率：简单暴力，直接提高采样率。 Pre-Filter：预先滤波。首先用滤波对原图进行模糊，这样边缘有的像素就会点上介乎于边界两边的中间色，例如更浅的颜色。 滤波必须在采样之前进行,否则得到的是模糊的锯齿(Blurred aliasing)，没有很好的反走样效果。 因为真实边界信息在采样过程中已经损失了，所以滤波只能平均/模糊错误的信息。 从频率的角度来理解，滤波的作用是削去了高频信号，这样就占用的频率带宽变小，原本会混叠的信号就不会混叠了 MSAA：对一个像素内设置更多的采样点。例如四个角各有一个像素点，如果只有 x 个点被覆盖就是 x/4 的灰度。 MSAA 并没有提高分辨率，只是提高了一个像素内的采样数量。 当然，MSAA 会显著提高计算量，不过当代工业界会通过复用像素等方法来降低消耗。4x MSAA 并不会让游戏帧率降低到 1/4。 FXAA（Fast Approxim AA）：不对图像而对图片进行处理。得到图像以后，图像匹配找到有锯齿的边界，用没有锯齿的边界进行替换。 TAA：复用上一帧的结果。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-5：(三角形的)光栅化 Next：GAMES101-6(2)：深度检测与 Z-buffer 算法","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"反走样","slug":"反走样","permalink":"http://example.com/tags/%E5%8F%8D%E8%B5%B0%E6%A0%B7/"}]},{"title":"GAMES101-6(2)：深度检测与 Z-buffer 算法","slug":"GAMES101/GAMES101-6-2","date":"2023-07-22T07:09:27.000Z","updated":"2024-04-20T18:58:06.452Z","comments":true,"path":"/GAMES1010602.html","permalink":"http://example.com/GAMES1010602.html","excerpt":"前言 GAMES101-P7：可见性问题：画家算法和 Z buffer 算法","text":"前言 GAMES101-P7：可见性问题：画家算法和 Z buffer 算法 场景中的不同远近的物体存在遮挡关系，我们需要根据深度（z 轴值）得出正确的遮挡关系。 画家算法：由油画家启发的算法 画家算法的思路：类似于油画画家的作画思路：画家先画最远的面，再画较近的面，最后画最近的面，就能得到完整的画面。 画家算法的做法：先对每个面进行深度排序，然后按远近顺序进行作画覆盖。 由于排序算法的时间复杂度最快是 O(nlog⁡n)O(n \\log n)O(nlogn), 因此画家算法至少会有这么多的时间复杂度 画家算法能得到一些正确的结果，但是不能保证一直正确，例如一个面上所有的点的深度不一致、循环遮挡等情况。下面是一个画家算法无法处理的情况 Z-Buffer 算法：深度缓冲算法 我们已经维护了一个帧缓存（frame buffer），其存储的每个单元就是屏幕显示的每个像素的颜色。我们现在再维护一个深度缓存（depth buffer/Z-buffer），存储当前像素点的深度信息。 一开始所有深度都为无穷大，每次放入一个面，就对其覆盖的像素检查深度值。深度浅于当前深度时，才会对应更新此像素点对应的深度值和颜色值。 伪代码： 1234567foreach T in triangles foreach pixel[x,y,z] in T if(z &gt; zBuffer[x,y]) frameBuffer[x,y] = pixel[x,y,z]; // update color zBuffer[x,y] = z; // update depth else do nonthing; Z buffer 的优点在于，Z buffer 不需要考虑到遍历的顺序问题，得到的结果总是正确的。而且速度优于画家算法：Z buffer 的时间复杂度可以认为是 O(n)O(n)O(n) 的，因为我们并没有进行排序，而只进行了遍历。 请注意： 我们没有考虑深度一致的问题 Z-buffer 无法处理透明效果 如果我们将 Z-buffer 与 MSAA 结合，那么对像素的处理就要对应变为对采样点的处理。 Z-buffer 是当前广泛采用的算法 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-6(1)：反走样 Next：GAMES101-7&amp;8：着色、纹理与图形管线","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"深度检测","slug":"深度检测","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"Z-Buffer 算法","slug":"Z-Buffer-算法","permalink":"http://example.com/tags/Z-Buffer-%E7%AE%97%E6%B3%95/"},{"name":"画家算法","slug":"画家算法","permalink":"http://example.com/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"}]},{"title":"GAMES101-5：(三角形的)光栅化","slug":"GAMES101/GAMES101-5","date":"2023-07-20T14:58:17.000Z","updated":"2024-04-20T18:58:06.449Z","comments":true,"path":"/GAMES10105.html","permalink":"http://example.com/GAMES10105.html","excerpt":"前言 GAMES101-P5：光栅化","text":"前言 GAMES101-P5：光栅化 本节介绍 MVP 变换之后的操作：光栅化 Rasterize 屏幕与光栅化 定义屏幕： 单元为像素的一个二维数组 分辨率：长宽像素 是一种光栅成像设备 光栅化：“画”到屏幕上 像素：显示由 RGB 混合的单一色彩。 pixel 是 picture element 的缩写 raster 其实是德语中的 screen 的意思 屏幕空间：定义方式不一，可以以左下角为（0，0）点第一象限定义空间。 XY方向的投影 将经历投影变换得到 [±1,±1][\\pm 1,\\pm 1][±1,±1] 宽高的面拉成屏幕的宽高[0,w]×[0,h][0,w]\\times[0,h][0,w]×[0,h]。变换矩阵： [w200w20w20h2001−n+f20001]\\begin{bmatrix} \\frac{w}{2} &amp; 0 &amp; 0 &amp; \\frac{w}{2} \\\\ 0 &amp; \\frac{w}{2} &amp; 0 &amp; \\frac{h}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} ⎣⎢⎢⎢⎡​2w​000​02w​00​0010​2w​2h​−2n+f​1​⎦⎥⎥⎥⎤​ 三角形的光栅化 光栅化即将多边形劈成数个像素的过程，这个过程中最基础的是三角形。 三角形的良好性质： 最基础的多边形，而且其他多边形都可以拆分为三角形 三角形定义的一定是平面（反例：沿对角线折了的四边形） 清楚的内外定义：没有凹凸之分，通过叉积可以简单判断在里还是外 三角形内点的属性可以由根据离三角形顶点的距离关系进行插值得到 如何判断一个像素该不该被点亮？ 采样 抽象地说，采样就是将一个函数离散化。 对像素中心进行采样： 如果像素中心在三角形内，则点亮，否则不点亮。 边界问题：如果落在边上，采取统一的处理方式即可。如①不认为在多边形内左下、②左下认右上不认； 判断点在三角形内：用三条边与点 q 连线进行叉乘。 如 P0P1P_0P_1P0​P1​、P1P2P_1P_2P1​P2​、P2P0P_2P_0P2​P0​ 分别对 P0QP_0QP0​Q、P1QP_1QP1​Q、P2QP_2QP2​Q 叉乘，得到的结果都在同一侧则说明在三角形内 对判断过程进行加速 包围盒方法：左于最左顶点高于最高顶点的肯定不用考虑。最上下左右的点围成的四边形就是三角形的包围盒。 记录边界的所有点。 Extend：关于显示设备 隔行扫描：造成画面撕裂 帧缓存（frame buffer）：将内存（显存）中的一块区域存储图像，并映射到屏幕。 LCD：液晶显示。通过液晶过滤指定的波改变光的颜色。 LED：发光二极管。小灯管组合发光。 墨水屏：控制黑色墨水面显示在上还是白色墨水面显示在上，刷新极慢。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-4：视图和投影变换 Next：GAMES101-6(1)：反走样","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"}]},{"title":"Unity的新按键输入系统","slug":"Unity/Unity的新按键输入系统","date":"2023-07-17T15:39:53.000Z","updated":"2024-04-20T18:58:06.461Z","comments":true,"path":"post/20230717233953.html","permalink":"http://example.com/post/20230717233953.html","excerpt":"前言 这是 Unity 新输入系统（input system）的简要笔记。","text":"前言 这是 Unity 新输入系统（input system）的简要笔记。 官方文档地址：Input System | Input System | 1.5.1 Actions Action Type Value 类型：每次值改变的时候触发OnAction报告值；适用于追踪持续改变状态的输入。 Button 类型：每次按下的时候触发； Passthrough 类型：看文档意思是一种冲突解决方案：对所有的控制类型都会响应。 因此，一次按下松开会使 Value 类型调用两次 OnAction，但是只会调用一次 Button 或 Passthrough。 检查 Action 的状态(委托与轮循) 可以使用下列三个 Action————此处 Action 是指一参无返的委托，不是 InputAction： action.started action.performed action.canceled 也可以使用下列函数进行轮循： 对于 value 类型： action.ReadValue&lt;T&gt;() action.PerformedThisFrame() 对于 Button 类型： action.IsPressed() action.WasPressedThisFrame() action.WasReleasedThisFrame","categories":[{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"}]},{"title":"Beautiful Times个人翻译","slug":"歌词翻译/Beautiful Times翻译","date":"2023-07-11T00:37:12.000Z","updated":"2024-04-20T18:58:06.474Z","comments":true,"path":"post/20230711083712.html","permalink":"http://example.com/post/20230711083712.html","excerpt":"前言 Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。","text":"前言 Beautiful Times 是 Owl City 收录于 EP 《Ultraviolet》 的一首歌。描述了一种走出黑暗走出抑郁的心情，适合在清晨六七点钟听。 除了旋律的优美与积极，另外一个另我印象深刻的点是排比和押韵的使用。大部分我都使用加粗、斜体、加粗斜体进行标识。这种韵律也是促使我翻译这个歌词的重要原因，尽管不太翻译出了其这一特点，但是这种用心琢磨一下文字的感觉实在让人心情很好。 翻译 A spark soaring down through the pouring rain 耀眼的电光穿过瓢泼大雨 And restoring life to the lighthouse 废弃的灯塔被它再次点燃 A slow motion wave on the ocean stirs 激荡的海面逐渐涌起巨浪 My emotion up like a raincloud 我的心绪如雨云一样高飞 When did the sky turn black? 天空什么时候没了光彩？ And when will the light come back? 阳光什么时候才会回来？ A cab driver turned to skydiver 的士司机当了跳伞者 Then to survivor, dying to break down 在幸存之后濒临崩溃 A blood brother,surrogate mother 代孕母亲和她的哥哥 Hugging each other,crying their eyes out 互相拥抱着泣不成声 When did the sky turn black? 世界什么时候没了光彩？ And when will the light come back? 光明什么时候才会回来？ I'm ecstatic like a drug addict 我喜悦的心情好似嗑药 locked in the attic. Strung out and spellbound 困在阁楼，疲惫又热情 I fought all through the night 我整晚都在顽强对抗它 Oh oh, but I made it alive 最后终于让我走了出来 The sun's starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 这场生的搏斗太难、太难、太难了 But I'm gonna survive 但我会把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 A bad feeling burned through the ceiling 就把消沉的心绪付之一炬 Leaving my healing heart with a new scar 只给我痊愈的心添道新疤 A dead fire rose and rose higher 死亡之火升腾得愈高愈旺 Like a vampire up from the graveyard 如飞起的吸血鬼凌于群鸦 When did the sky turn black? 世界什么时候失去光华？ And when will the light come back? 希望什么时候能够回家？ We all suffer but we recover 我们都饱经磨难但是挺了过来 Just to discover life where we all are 最后明白我们生命的意义在哪 I fought all through the night 我搏斗了整整一夜 Oh oh, but I made it alive 但最后我还是活了下来 The sun's starting to rise 天边开始逐渐亮了起来 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I'm gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 This fight of my life is so hard, so hard, so hard 与生活的搏斗太难、太难、太难了 But I'm gonna survive 但我还是把它击败 Oh oh, these are beautiful times 啊这是多么美丽的时光 My heart's burning bad and it's turning black 灼烧的心已焦黑几近焚毁 But I'm learning how to be stronger 但我已学着变得更加强大 And sincerely I love you dearly 亲爱的我真切地爱着你 Oh but I'm clearly destined to wander 但明显地我注定着要流浪","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"}]},{"title":"C# 中的委托机制(delegate、action、func)","slug":"Cs中的委托机制","date":"2023-07-06T13:40:05.000Z","updated":"2024-04-20T18:58:06.433Z","comments":true,"path":"post/20230706214005.html","permalink":"http://example.com/post/20230706214005.html","excerpt":"前言 简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是?","text":"前言 简单了解了 C# 中的 Delegate、Func、Event、Action。粗略理解：委托是一个规定了参数的函数待执行队列；Func 是只有一参一返的 Delegate；Action 是一参无返的 Delegate；Event 是? 主要参考了C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili，一个很好的视频。 委托 Delegate 委托的底层是一种函数指针。顾名思义委托的作用就是，当一个函数“不方便做某事”的时候，“拜托”另一个函数去做。可以用于实现事件与回调。 所有的委托都派生自 System.Delegate 类。 声明一个委托 委托的声明 1delegate &lt;return type&gt; &lt;delegate-name&gt; &lt;parameter list&gt; 委托经过声明以后决定其可以引用的方法。方法与声明有相同的参数、返回类型、标签（关于标签参考此 CSDN 博客）。换句话说，委托的声明决定了它能调用什么样的方法，委托是被调用方法的模板。 实例化委托 声明完成后，可以用 new 实例化一个委托实例，并且在参数中指定实例调用的方法。如下 1234public delegate void printString(string s);...printString ps1 = new printString(WriteToScreen);printString ps2 = new printString(WriteToFile); 最后向委托中传递参数即可。如下是一个完整的例子（From：runnoob） 1234567891011121314151617181920212223242526272829303132333435363738using System;delegate int NumberChanger(int n);namespace DelegateAppl&#123; class TestDelegate &#123; static int num = 10; public static int AddNum(int p) &#123; num += p; return num; &#125; public static int MultNum(int q) &#123; num *= q; return num; &#125; public static int getNum() &#123; return num; &#125; static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); // 使用委托对象调用方法 nc1(25); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); nc2(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; &#125;&#125; 委托的多播 如果委托对象（即实例）的类型相同，则可以合并、分离委托（使用 + 和 - 运算符），这被称之为委托的多播或组播。如下是一个例子（From：runnoob） 1234567891011121314...static void Main(string[] args) &#123; // 创建委托实例 NumberChanger nc; NumberChanger nc1 = new NumberChanger(AddNum); NumberChanger nc2 = new NumberChanger(MultNum); nc = nc1; nc += nc2; // 调用多播 nc(5); Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum()); Console.ReadKey(); &#125; Func Func 是委托的一种，它固定具有一个参数和一个返回值。 格式如下： 1Func &lt;parameter_type,return_type&gt; expression; expression 可以是一个 lambda 表达式，也可以是一个方法。是方法的时候，这个方法和 Func 一样必须有一个传入值和一个返回值。这样，就可以把方法作为参数进行传递，同时不必像委托一样显式的进行定义声明。 lambda 表达式的举例： 1234Func&lt;string, string&gt; convert = s =&gt; s.ToUpper();string name = &quot;Dakota&quot;;Console.WriteLine(convert(name)); 实例化委托方法的举例： 123456789Func&lt;string, string&gt; convertMethod = UppercaseString;string name = &quot;Dakota&quot;;Console.WriteLine(convertMethod(name));string UppercaseString(string inputString)&#123; return inputString.ToUpper();&#125; Action Action 也是委托的一种，它一定具有一个参数，并且没有返回值。 即： Action &lt;T&gt; name 总的来说，和 Func 差别不大。同样可以给它赋值为 lambda 表达式或方法。只要这个方法有一个参数并且没有返回值。 Event Event 是一种特殊的委托，但是其复制的权限为delegate。使用 Delegate 的时候，我们不一定想立刻为其赋值。这种情况下，我们可以考虑使用 Event。 事件的声明： 12345 delegate void MyDelegate(); event MyDelegate myEvent;// orevent Action myEvent //Action 的本质是 Delegate 事件声明完成后就是一个实例了（类似变量）。 当作为类成员的时候， event 只能在类中被调用。 Event 的一种用处：让类外成员可以观测到类的私有成员发生了变化。 在类中定义私有成员的 public {get;set;} 变量，set 时，invoke 类中的event； 类外事物需要观测时，在 event 中注册函数就会收到通知。 参考 C# 的委托与事件大致是怎么一回事_哔哩哔哩_bilibili C# 委托（Delegate） | 菜鸟教程 Func&lt;T,TResult&gt; 委托 (System) | Microsoft Learn 三分钟彻底搞懂委托，事件，Action，Func的作用和区别_哔哩哔哩_bilibili 延申 逆变与协变类型请参考：Covariance and Contravariance in Generics | Microsoft Learn lambda 表达式部分参考： Lambda表达式_百度百科 C++ 中的 Lambda 表达式 | Microsoft Learn","categories":[{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"}],"tags":[{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"}]},{"title":"向量数据库技术鉴赏观看记录","slug":"向量数据库技术鉴赏观看笔记","date":"2023-07-01T14:49:55.000Z","updated":"2024-04-20T18:58:06.466Z","comments":true,"path":"post/20230701224955.html","permalink":"http://example.com/post/20230701224955.html","excerpt":"前言 配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。","text":"前言 配合 Ele 实验室的下列视频食用： 【上集】向量数据库技术鉴赏_哔哩哔哩_bilibili 【下集】向量数据库技术鉴赏_哔哩哔哩_bilibili 和多媒体数据处理课的实验相关密切（联系拓展到了四个实验中的三个），所以做一个记录。 笔记 为什么要有向量数据库？ 我们可以将几乎所有的事物转化为数个值的组合来进行区别和描述。例如，一个狗={毛发长短，毛发颜色，体格大小，温顺程度……}，于是就可以用向量来表述一个东西。 向量一定程度的推理关系：如果“关系”作为向量的一环，那么我们会发现“警察与小偷”和“猫和老鼠”之间关系的相似性。 向量的应用： 图片领域：描述特征。实现“以图搜图”功能，参考计算机视觉实验和多媒体数据处理实验3（多媒体实验3：基于 BOF 进行相似图片搜索） 文本向量化：描述一个句子中有多少个x关键词，见上述多媒体数据处理实验3。相似文本内容查找。利于理解文本的实际内容，AI相关。 将相似对话输入给 chatGPT，极大提高输出效果。 问题：传统数据库不适合存储处理向量（在一些云计算的例子中，甚至只提供存储字符串类型）。 传统数据库：通过查询语句进行精准搜索 向量数据库：查询库中与查询向量最相似的向量转化为 KNN 问题，具有一定的模糊性。 向量数据库的核心：KNN（K最近邻算法） 距离的定义：欧几里得距离、余弦相似度、海明距离等…… 暴力搜索算法 聚类思想：如果我们先将数据进行分类，那么只在查询点所在类进行搜索，搜索的范围就小多了。 Kmeans 算法 指定聚 n 类，迭代 k 次。 随机生成 n 个代表点，按距离进行分类。 训练：将分类结果的平均点视为新代表点，重复此过程 k 次。 收敛：代表点数值趋于稳定 不能保证聚类不遗漏 近似最近邻 ANN：通常来说，试图提高速度的行为基本上都会带来准确率的下降。例如 Kmeans 中将一个点放入了错误的类中，算法得到的往往是近似的 KNN（参考 LSH 中的结果部分）。 局部敏感哈希算法 LSH：关于欧几里得距离的 LSH，见多媒体实验4：LSH局部敏感哈希 采用海明距离的LSH 哈希函数：随机一个有正反的超平面。判断点是在正面还是反面，记为0/1。 对两个点点被哈希得到的 01 串计算海明距离 把 01 串进行分段，只要有一个段一致就候选的策略，提高分到同一个桶的概率。 ANN 问题中的内存开销问题：量化与乘积量化（PQ） 内存开销问题：一个 128 维，每维一个浮点数（32 bit，4 byte）的向量需要占用 512 字节空间 B 树类数据结构可以为读写庞大数据库减少内存损耗。数据库存储在磁盘中，每次只读取其中的一个结点。见B 树、B+树、二叉搜索树与红黑树； 乘积量化可以减少一个向量本身占有的空间 用代表点代表类中的所有向量：有损压缩 量化：向量根据码本转化为代表点 使用码本记录代表点，记录码本索引值代替记录向量真实值 如果我们使用一个字节存储码本索引，最多可以记录 256 个代表点，此后的每个向量只需要一个字节即可表示。 维度灾难问题：每一个维度都会拉远点与代表点的距离，高维非常分散。要保证好的效果，就需要大量聚类，码本开销就十分巨大。 乘积量化PQ：用低维子向量拼接代替高维直接量化，缓解维度灾难问题 例如 128 维向量被分割为8 个 16 维向量分别量化，得到结果再拼接。每个子向量有自己的码本。 高维结果实际上是低维量化结果的笛卡尔积，所以叫 PQ。 从指数增长变成了加法增长。 主要减少了内存开销，但是一定程度地提高了速度（O(n+klog⁡klog⁡log⁡n)O(n+k\\log k \\log\\log n)O(n+klogkloglogn)）,与之相比，暴力搜索的时间复杂度是 O(kn)O(kn)O(kn)。 其他降维方法：主成分分析PCA，见多媒体实验2：PCA主成分分析 基于图结构的高效 KNN：导航小世界NSW 与 HNSW 内存相比于速度和准确度，只能被开发者感知，因此有的时候我们愿意牺牲内存提高ANN的准确性与速度 导航小世界NSW 基于图结构：向量与向量之间的六人理论 图的构建方法： 没有孤立点 如果两个点够近就一定有边相连 边尽可能少 德劳内三角：一种满足 NSW 需要的构建方法 构建方法 将点随机放回空间 每次放回，就将其与最近点相连 最终图中既有一开始生成的较长的边，也有后续生成的较短的边 通过长边，我们可以从随机的查询点快速移动到与待查询点较近的点（直接在点空间构建不具备这种性质） 通过短边，满足德劳内三角的图结构，准确找到待查询点 分层小世界HNSW： 越上层越粗略，快速导航 越下层越仔细，准确查找 算法层面保证了先粗后快的查找过程，数据量扩大时表现更优良，稳定且快速。 本质是对查询的一种跳表化。 小世界算法：没有压缩 + 维护复杂的图结构 = 内存爆炸 其他向量数据库问题 向量数据库依然是数据库，和传统数据库产品一样有许多方面需要考虑：访问接口、访问控制、备份、多节点、容错、机器的监控与追踪……","categories":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"}]},{"title":"B 树、B+树、二叉搜索树与红黑树","slug":"B树与红黑树","date":"2023-06-25T14:47:14.000Z","updated":"2024-04-20T18:58:06.433Z","comments":true,"path":"post/20230625224714.html","permalink":"http://example.com/post/20230625224714.html","excerpt":"前言 B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。","text":"前言 B 树是一种用于索引外部存储数据的数据结构。许多数据库系统与文件系统都有它或者它的变体的应用。我们在这里讨论 B 树，B+ 树以及其他的树，为理解基于 B+ 树的 iDistance 算法打下基础。 为什么需要 B 树（和其他平衡树） 我们早就知道可以构造这样的树：比根小的扔左边，比根大的扔右边，这样就可以轻松构建一个有序的结构了。但是如果根的左右两边不平衡，显然就会导致找其中一边化的时间比较变长。因此我们就需要一些把树变平衡的方法。由是得到平衡查找树。 平衡的方法各有不同，对于本文介绍的树们，它们的逻辑关系是这样的： 由于二叉查找树的不平衡性，人们设计 AVL 树。它通过左右旋保证左右子树高度差不超过 1； AVL 树严格的平衡反而导致开销过大，于是设计了不那么严格的红黑树。红黑树通过两种颜色的区别，保证左右高度差不超过一倍； B 树从另一个角度入手，一个结点上存多个值叉分出多个子树，通过“限定结点上值的数量”和“叶子结点都在同一层”，保证平衡。由于一个结点上有多个值，树比二叉树浅，适合磁盘上存储大量数据的数据库采用。 B+ 树把值全存在叶子结点上，相比 B 树检索速度更稳定。此外遍历和排序也都更方便了。 B* 树在 B+ 树的基础上提高了结点拆分合并的时间，因为一个结点被从兄弟中创建出来的时候拥有了上限的 2/3 而不是 1/2 的结点，需要拆分的次数降低了。 AVL 树 AVL 树是最先发明的自平衡二叉查找树。 在AVL树中任何节点的两个子树的高度最大差别为 1 。 AVL树增删操作后需要把失去平衡的结点重新变平衡。为此，引入左旋和右旋操作： 上图将 A 为根结点在树进行左旋，得到 B （原右孩子）为根结点的树。这个过程可以如下描述： B 的左子树成为 A 的右子树； A 成为 B 的新左子树； B 成为新的根结点； 类似地，右旋就有：（假设 A 是根结点，C 是 A 左结点） C 的右子树成为 A 的左子树； A 成为 C 的新左子树； C 成为新的根结点； 我们现在可以讨论 AVL 树的再平衡了。 我们规定一个结点左右子树高度差绝对值是平衡因子，那么 AVL 数平衡因子只能是 0 或 1。 显然一个结点（下的子树）失衡，说明之前其平衡因子是 1，现在变成了 2。这也说明，新结点插入的那个子树原先较长而且插入一个结点使其变得更长了。于是最靠近插入结点的失衡结点的一个子树现在的平衡因子必然为 1。 假设是插入在左子树。对于结点插入在左子树的左边的情况（左），我们可以把不平衡节点的子树右旋，使得插入了结点的左子树成为新根结点，则树恢复平衡。插入右边的情况，则先对左子树进行左旋，再对根结点右旋。插入在右子树的情况是类似的。总结如下： 对于最靠近插入结点的失衡结点 A： 插入结点在 A 的左结点 B 的左子树上：A 右旋 插入结点在 A 的左结点 B 的右子树上：B 左旋，再 A 右旋 插入结点在 A 的右结点 C 的右子树上：A 左旋 插入结点在 A 的右结点 C 的左子树上：C 右旋，再 A 左旋 红黑树 AVL 树对平衡要求很高，左右旋又是较为耗时的操作，增删比较频繁时，付出的代价甚至可能比获得的效率收益还多，故而它只适合用于插入删除次数比较少的情况，实际应用不多。 红黑树是对 AVL 树的一种改进，它只保证最长路径不超过最短路径的两倍，是一种弱平衡二叉树。因为平衡要求没那么严格，所以增删花费时间少，查询时间则有所增多。 红黑树每个结点非红即黑，而且有： 根节点、叶节点（请注意，叶子结点是 NULL 结点）都是黑的； 红结点的两儿子都是黑的； 对于任意节点而言，到其下叶子结点路径都包含相同数目的黑结点； 高度始终保持在h = logn 红黑树的插入 记新结点为 N，其父结点为 P，父结点的兄弟结点（叔父结点）为 U，父结点的父结点为祖父结点 G。首先，我们将结点 N 插入到树中，并标记它的颜色为红色。检查此时的情况： P 不存在，N 是根结点：把 N 染黑。 P 是黑结点：什么都不用干。因为 N 取代了一个黑空节点，到达 N 下空结点经过的黑色结点数没有变。 P 是红结点，此时 G 结点必存在为黑节点。 P、U 都是红结点：P、U 染黑。 G 是根结点：不动。 G 不是根结点：染红。 如果不动 PU，把 N 染黑，那么 G 到达 N 下结点经过的黑结点数就会比去 N 兄弟的路径多一个。 如果不染 G，那么 G 的父亲到达 G 下结点经过的黑结点数就会比去 G 兄弟经过的多一个。 P 左红 U 右黑，N 是右节点(记为 LR )：对 P 左旋，然后对 G 右旋，P 染黑，G 染红。 左旋一次以后，变为下面的 LL 情况。 P 左红 U 右黑，N 是左节点：对 G 右旋，P 染黑，G 染红。 N 的插入不会导致经过的黑色结点数发生改变，但是 P 子树深了一层，所以不管改 P 还是 N 都会导致经过黑点增加，除非同时通过 G 把增加黑点数减掉，但是这同时会导致 U 子树方向少掉一个黑点， P 子树还是多一个，因此通过单纯的染色是无法解决问题的。 通过旋转操作，相当于把 P、N 两个都在 P 子树的红点移了一个到 U 子树。由于 G、U 都是黑结点，因此在里面插一个红点不会有影响。这样就两边都没有红点相连的情况了。 P 右红 U 左黑：对照上面对称处理。 注意这些情况和 AVL 树的再平衡的相似。 红黑树的删除 假设删除的结点是 D 如果左右子树均不为空：将左子树中的最大值或右子树中的最小值挪过来覆盖，然后删除原来其在的结点。这个结点是最值，那么显然不可能有两个有值的孩子，于是转化为下面的情况。 左右子树至少有一个为空： D 是红结点：那么父结点和子结点都是黑色结点，直接接一起就完了。（当然优先的不空的子树） D 是黑结点，且非空孩子是红结点：删除 D，把非空孩子移上来并染黑。 D 是黑结点：可知两个孩子都为黑空，将 D 变成黑空，可知此时 D 子树少了一个黑色结点，然后有下面若干种情况。 假设删除的结点是 D，D 的父亲 P，兄弟 U，U 的左右孩子 NL，NR： 情况1：P 为空， D 是根结点：什么都不用干； P 为黑 情况2： U 为黑，NL，NR也为黑：U 变红，U 子树减一个黑色接结点；然后 P 子树减少了一个黑结点，对 P 思考该问题； 情况3： U 为红：对 P 左旋；然后 P 变红， U 变黑。然后情况 4, 5, 6： 相当于将兄弟子树的一个红节点拿了过来。 情况5： NL 为红，NR 为黑：U 右旋，NL 变红 ，U 变黑，变成情况 6； 情况6： NL 为黑，NR 为红：P 左旋，U 变 P 的颜色(黑)，P 变黑，U 的颜色，NR 变黑。 根结点的颜色不变，根的左子树补了一个黑结点（U）。 P 为红，U 为黑： 情况4： U 的孩子都为黑：对换 P、U 的颜色； 情况5： NL 为红，NR 为黑：U 右旋，NL 变红 ，U 变黑，变成情况 6； 情况6： NL 为黑，NR 为红：P 左旋，U 变 P 的颜色(红)，P 变黑，U 的颜色，NR 变黑。 根结点的颜色不变，根的左子树补了一个黑结点（P）。 B树 B 树（B-Tree）， B 普遍来说被认为是 Balanced 的意思，因为这是一种自平衡树。 有的地方翻译为 B-树，容易给人一种是 B “减”树的错觉，事实上 B-Tree 就是 B 树。 如果数据太大，我们就无法在内存中放下整个树，同时我们知道磁盘读取速度远慢于内存。因此这种情况下我们对“读取”操作非常敏感。如果是不够平衡的树，或者深度太深，检索速度就会很慢。在数据库应用中，B树的每个节点存储的数据量大约为4K, 这是因为磁盘数据存储每个块的大小为通常为 4K，这样每次磁盘 IO 可以读写刚好一个数据库结点。 B 树是多叉树，而且每个结点能存储多个值。它定义如下： 一个结点能存储多个值，这些值称之为键。 度：定义一颗树的度为 t(t≥2t\\geq 2t≥2)。度能决定树内的结点有多少键： 空树：0个； 根结点:[1,2t−1][1,2t-1][1,2t−1] 个； 普通结点：[t−1,2t−1][t-1,2t-1][t−1,2t−1]个。 子结点数：自己的键数 +1 个。一个键把数轴划为两个区间， n 个键自然就是 n+1 个区间。 叶子结点都在同一层。 例如：t = 2。此时的 B 树内部节点可以有 2、3 或 4 个孩子，称之为 2-3-4 树。 B 树的检索 在树 T 中检索关键字 k 的逻辑如下： 首先，查找 k 和 T 根结点的区间关系。 如果落在一个键上，那么就搜索到了 k 是 T.root 的第 i 关键字。 否则，继续第二步 在 k 落在区间的对应孩子上继续搜索。 当前结点没有孩子，说明没找到。 B 树的插入 逻辑： 如果结点的键槽没有满：结点添加一个新键。 如果结点满了（2t-1个键）：那把此结点的键分为三份，最中间的键插入到父结点，左右分裂为两个有 t-1 个键的结点。其孩子也对应分配给新分裂出来的结点。 如果父节点也满了：递归重复上面过程。 如果根结点都满了：创建一个空结点为新的根结点，然后分裂根结点 实际我们在确定新键位置的过程中，就沿途分裂了所有遇到的满结点。因此实际上这不是一个递归过程。 B 树的删除 假设问题是删除结点 x 中的键 k： 不少于 t-1 个键的叶子结点删除：直接删除； 内部结点： 找到 k 前面的区间对应的子结点 y，看是否有至少 t 个键： 如果 y 至少有 t 个键：找到结点 y 中最后一个键 k'（即 k 的前驱）。执行“删除结点 y 中 k' 键”的操作。x 中用 k' 替换 k。 否则：找到 k 后面的区间对应的子结点 z，看是否有至少 t 个键： 如果有：找到结点 z 中最后一个键 k'（即 k 的后继）。执行“删除结点 z 中 k' 键”的操作。x 中用 k' 替换 k。 否则：此时 y 和 z 加起来就只有 2t-2 个键。把键 k 和结点 z 都合并进 y。然后再在 y 中删除 k； 由上向下找 k 时如果确定 k 在一颗以 x 为根的子树中，并且 x 只有 t-1 个键，设 x 的父结点为 p： x 的一个相邻兄弟（y/z）结点有至少 t 个键：删除此键。根据是 y 或者 z，从 p 中对应给一个键给 x。从 y/z 中对应给一个键给 p； 相邻兄弟也只有 t-1 个键：合并 x 和 y/z、p 中由两个子结点夹着的键。如果p 是根结点而且本来就只有一个键，那么树的高度就缩减了。 B+ 树 B+ 树的特点是在 B 树上做了如下改动： 非叶子结点不存值，只有子结点的头元素的索引。即一个键（子结点头元素值）对应一个指向子结点的指针。 相邻叶子结点之间用指针直接串连。 根结点至少一个元素，非根结点有 [m/2, m-1] 个元素。其中 m 是 B+ 树的阶。 这样一来 B+ 树的查询速度基本恒定。 此外 B+ 树还有以下好处 遍历快：因为块与块之间有指针 天然排序：例如我我们想取一个区间内的数据，取出来就是有序的。 B+ 树的插入 当节点元素数量大于 m-1 ：按中间元素分裂成左右两部分，中间元素是右半部分的头结点。同时父节点添加中间元素当做索引。 B+ 树的删除 因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可。 删除元素后依然满足要求：直接删除 删除后元素个数不够 兄弟结点有多余元素：向兄弟要一个元素，修改父结点的索引值； 兄弟结点无多余元素：和兄弟合并。递归删除父结点的索引。 删除元素后 B* 树 很显然，B* 树又是对B+数的再一次改进，在 B+ 树的构建过程中，为了保持树的平衡，节点的合并拆分是比较耗费时间的，所以 B* 树就是在如何减少构建中节点合并和拆分的次数，从而提升树的数据插入、删除性能。 一个结点创建的时候有 upper(2/3)mupper(2/3)mupper(2/3)m 的键，而不是 upper(m/2)upper(m/2)upper(m/2)； 如果结点存满了，检查兄弟结点是否是满的： 不是满的：向兄弟节点转移关键字； 也是满的：和兄弟结点各拿 1/3 创建一个新结点； 参考 面试官问你B树和B+树，就把这篇文章丢给他 - 好好学java - SegmentFault 思否 二叉搜索树(BST)与平衡二叉树(AVL) - 知乎 万字大总结，一文搞懂二叉搜索树、B树、B+树、AVL树、红黑树 - 知乎 红黑树 - 维基百科，自由的百科全书 《算法导论》","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"多媒体实验4：LSH局部敏感哈希","slug":"课程报告/多媒体实验4LSH","date":"2023-06-14T03:47:13.000Z","updated":"2024-04-20T18:58:06.486Z","comments":true,"path":"post/20230614114713.html","permalink":"http://example.com/post/20230614114713.html","excerpt":"前言 KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。","text":"前言 KNN 问题是指求一个空间内一个点的 K 个最近邻的问题。DB 局部敏感哈希是 KNN 问题的一个快速求取方案，但是它的结果不能保证绝对准确。 目的 在corel数据集上实现LSH索引并分别进行近邻搜索，查询数据集前1000点的前10个最近邻，并统计搜索算法的性能(召回率，准确率，时间)。 局部敏感哈希的思想 常规的哈希思想是通过算法将被哈希后的值作为键去索引原来的值，由于根据值是可以算出键的，所以这就给我们的查找带来了方便。通过哈希，我们可以把一个稀疏矩阵紧密存放，但是又不损失索引的速度。 不过哈希函数也有别的用法，例如密码学哈希函数。这类特别的哈希算法旨在用哈希函数实现加密，因此其哈希值难以推出原值，而且对输入敏感，稍加变动就会彻底改变哈希值。此外，其对抗碰撞的要求也很高，因为碰撞意味着加密的不安全。 而局部敏感哈希则反其道而行之，其非常容易发生碰撞。实际上，这种哈希函数的目的是使邻近的值在经过哈希以后依然邻近，或者说干脆就相等了（这一步可以通过把处理后的值取整实现）。因此，通过局部敏感哈希，我们就相当于对数据集中的数进行了一次分类，这样以后需要搜索 KNN 时，我们就不需要搜索整个数据空间而只对与查询值具有相同哈希值的那些点进行计算即可。 当然，哈希函数不能保证所有被映射到一起的值均是邻近的值，因此 LSH 只能是 KNN 的近似算法，不能保证准确。 一个简单的例子是： 令哈希函数为 h((x，y))=xh((x，y))= xh((x，y))=x ，即 x 轴值。那么 y 轴方向上距离很大的点依然会被错误的认为是邻近点 为了提高准确性，我们可以试着改变哈希算法的一些参数，使得更多的点映射在一起，相当于扩大了“邻近”的范围从而匹配到更多的点。另一方面，我们也可以采用另外一个不同的哈希函数进行运算，看看结果是否会不同。对于多次哈希的结果，我们可以取邻近点的交集，也可以取邻近点的并集，只要参数适当，都可以取得还不错的结果。事实上，由于处理的数据往往维数很大，所以我们都需要采取多个哈希函数。 例如对于上面的例子，我们采用h((x，y))=yh((x，y))= yh((x，y))=y 作为第二个哈希函数算法，并且认为只有两次哈希结果均邻近才能算邻近值（取交集），那么 y 轴方向上距离很大的点就不会被认为是邻近点。 前人们已经总结出了许多的哈希函数，针对不同的要求，例如求的是点的什么距离，我们可以采取不同的哈希方法。因此我们可以不自己构造哈希函数。 总结一下，LSH 思想就是：通过构造哈希函数将相邻近的点映射到一起，用多次哈希提高精确度，用查找哈希值索引到可能的最邻近点并计算距离得出近似最邻近点。当参数取得合适，我们就可以保证 LSH 找到 KNN 的准确性可以接受。 性能评估：准确率、精确率、召回率 准确率、精确率、召回率是三个容易混淆的概念。 假设我们的问题是在所有样本中找出所有为真的样本。那么对于机器给出的结果，就有“机器判断正确/错误”和“机器判断是真/假”的组合共计四种情况，记前者为 True/False，后者为 Positive/Negative，并简记为TFPN。那么机器就将样本分为了 TN、TP、FN、FP 四种类别。于是： 准确率（accuracy）指机器对多少样本的判断是正确的，即 TP+TNTP+TN+FP+FN\\frac{TP+TN}{TP+TN+FP+FN}TP+TN+FP+FNTP+TN​。准确率只在乎判断得对不对; 精确率/查准率（precision）指预测为真的样本中有多少判断是正确的，也就是 TPTP+FP\\frac{TP}{TP+FP}TP+FPTP​，精确率要求没有找到错误的真点，不关心有没有漏找; 召回率/查全率（recall）指实际为真的样本中有多少判断是正确的，也就是究竟找（召）回了多少为真的样本，即TPTP+FN\\frac{TP}{TP+FN}TP+FNTP​，召回率只关心有没有找全真点，不关心有没有错误的点。 在灾害预报中，我们应该关心召回率，因为每一次没有预测到灾害都会给社会带来巨大损失；但是如果是人脸识别，那么就应该关心精确率，因为无法识别人脸用户可以使用其他方式继续，但是如果错误识别则可能给用户带来损失。 也可以用语言的角度进行理解，准确无疑是指我们判断对了没有，精确则是判读对了多少。因此前者关心整体的判断，而后者只关心预测为真的样本中的判断。 程序的基本结构 在这里，我采取的是计算欧几里得距离，这样，我们的哈希函数就可以形如 H(x)=floor((r⃗⋅p⃗)+bHsize)H(x) = floor(\\frac{(\\vec{r}\\cdot\\vec{p})+b}{H_{size}}) H(x)=floor(Hsize​(r⋅p​)+b​) 其中 HsizeH_{size}Hsize​ 是提前指定的值，p⃗\\vec{p}p​ 是输入点的向量形式，bbb 和 r⃗\\vec{r}r 是哈希函数中的随机偏移量和随机向量，bbb 的取值范围在 (0,Hsize)(0,H_{size})(0,Hsize​) 间。向下取整的 floor 函数负责将邻近的值舍入到一起。 在程序的一开始，我们根据需要的哈希数量和 HsizeH_{size}Hsize​ 的值随机生成 bbb 和 r⃗\\vec{r}r。由于矩阵的性质，我们可以直接将前者生成为一维数组，后者为每列一个 r⃗\\vec{r}r 的矩阵。然后对点进行计算。 得出计算结果后，我们使用字典列表按哈希值进行分类保存。这样索引就算建立完毕了。 搜索时，首先计算待查询值的哈希值，然后查询索引获得候选最邻近点。对不同哈希给出的候选集可以使用并集的方法，也可以采取交集的方法。最后对给出的所有候选点计算欧几里得距离，排序后选出最近的前 K 个点即可。选择并集或者交集需要适当的修改参数，不过总的来说，并集的效果好一些（见后面结果）。 在本例中，主要可以修改的参数是 HsizeH_{size}Hsize​ 是哈希函数的数量。前者决定了对计算结果的区分度， HsizeH_{size}Hsize​ 越大，被哈希到一起的邻近点就越多,速度就越慢，但是精确度相应提升。后者则可以从不同方向来判断邻近点，哈希函数越多，邻近点就越多，但是速度也同样会变慢。 为了判断精确度和用时，我们还需要构造一份正确答案。可以采取暴力计算的方式进行。将结果作为 JSON 文件存储于磁盘内，就可以加速在判断 LSH 准确性时的速度。 源代码 LSH: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172import numpy as npimport jsonimport time# region functionsdef get_hash_para(BUKET_SIZE): offsets = np.random.uniform(0, BUKET_SIZE, [1, BUCKET_NUM]) vectors = np.random.random([32, BUCKET_NUM]) return offsets, vectorsdef calc_LSH_indexes(data, bucket_num): &quot;&quot;&quot;&quot; 进行哈希计算并分配到哈希“桶”中\\\\ 哈希公式 H = （（dot（v·r）+b)）/BUCKET_SIZE）\\\\ 其中r是向量，b是一个数 &quot;&quot;&quot; buckets = [&#123;&#125;for _ in range(bucket_num)] # 结果是68040*15，每个向量在每个桶内映射为一个哈希值 mapped_indexes = np.floor( (np.dot(data, hash_vectors)+hash_offsets)/BUCKET_SIZE) # 由（数据向量值的）索引对应的一串桶中的哈希值，转变为桶中的哈希值对应的索引 # 方便由哈希值找索引 for index, hash_keys in enumerate(mapped_indexes): for j, hash_key in enumerate(hash_keys): buckets[j].setdefault(hash_key, []).append(index) return bucketsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def search(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.union( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef search_with_intersection(query, k): &quot;&quot;&quot;&quot;搜索点query的K最邻近,交集&quot;&quot;&quot; # 对该点哈希 # 1*【桶数】 query_hash_set = np.floor( (np.dot(query, hash_vectors)+hash_offsets)/BUCKET_SIZE) query_hash_set = query_hash_set[0] # get哈希值相同的点：候选点 for i, query_hash in enumerate(query_hash_set): if i == 0: candidate_set = set(buckets[i][query_hash]) else: candidate_set = candidate_set.intersection( buckets[i][query_hash]) candidate_set = list(candidate_set) # 计算排序候选点距离 distance = [] for i in candidate_set: distance.append(get_distance(query, data[i])) indexes_set = np.argsort(distance)[1:k+1] res = [candidate_set[i] for i in indexes_set] return resdef check_accuracy(chk_res, crrt_res): # 如果check-res中的元素在correct-res则append一个ture correct_num = sum([i in crrt_res for i in chk_res]) TP = correct_num FP = K - correct_num FN = K - correct_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # 变量 COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_RES_PATH = &#x27;./multi/4.10NN.json&#x27; BUCKET_NUM = 5 # 提高哈希量：增加准确性降低速度，时间的增加是几乎线性的 BUCKET_SIZE = 1.5 # （降低数值）提高区分度：降低准确性增加速度 K = 10 buckets = [] mean_precision = 0 mean_recall = 0 total_hash_time = -1 total_bf_time = -1 total_pre_time = -1 # 文件读取 data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) with open(CRRCT_RES_PATH, &#x27;r&#x27;) as f: correct_res_set = json.load(f) # 预处理 pre_start_time = time.time() hash_offsets, hash_vectors = get_hash_para(BUCKET_SIZE) buckets = calc_LSH_indexes(data, BUCKET_NUM) total_pre_time = time.time()-pre_start_time # 查询 hash_start_time = time.time() for query in range(0, 1000): # hash print(&#x27;query index:&#x27;, query) res = search_with_intersection(data[query], K) hash_end_time = time.time() # bf bf_res = correct_res_set[str(query)] # 评估 _, precision, recall = check_accuracy( chk_res=res, crrt_res=bf_res) mean_precision += precision mean_recall += recall total_hash_time += time.time()-hash_start_time + 1 # 结果 mean_precision /= 1000 mean_recall /= 1000 print(&#x27;hash used time:&#x27;, total_hash_time, &#x27;hash preprocess time &#x27;, total_pre_time, &#x27; bf used time:&#x27;, total_bf_time) print(&#x27;precision:&#x27;, mean_precision, &#x27;recall:&#x27;, mean_recall) 暴力： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import numpy as npfrom sklearn.cluster import KMeansfrom scipy.cluster.vq import vqimport jsonimport timefrom sklearn.metrics.pairwise import cosine_similarity# region functionsdef get_distance(a, b): &quot;&quot;&quot;&quot;获得欧几里得距离&quot;&quot;&quot; return np.sqrt(np.sum((a-b)**2))def check_accuracy(check_res, correct_res): accurate_num = sum([i in correct_res for i in check_res]) # false_num = K - accurate_num TP = accurate_num FP = K - accurate_num FN = K - accurate_num TN = (68040 - K) - FN accuracy = (TP+TN)/(TP+TN+FP+FN) precision = (TP)/(TP+FP) recall = (TP)/(TP+FN) return accuracy, precision, recall# endregionif __name__ == &#x27;__main__&#x27;: # variables COREL_PATH = &#x27;./multi/4.corel&#x27; CRRCT_PATH = &#x27;./multi/4.10NN.json&#x27; K = 10 # 预处理 hash_pre_time = time.time() data = np.loadtxt(COREL_PATH, usecols=range(1, 33)) hash_pre_used_time = time.time()-hash_pre_time # 查询 mean_accuracy = 0 mean_precision = 0 mean_recall = 0 total_hash_time = 0 total_bf_time = 0 bf_res_set = &#123;&#125; for query_index in range(0, 1000): bf_res = [get_distance(data[i], data[query_index]) for i in range(data.shape[0])] bf_res = np.argsort(bf_res)[1: 11].tolist() bf_res_set[query_index] = bf_res print(query_index) with open(CRRCT_PATH, &#x27;w&#x27;) as f: f.write(&#x27;&#123;\\n&#x27;) for i, (key, value) in enumerate(bf_res_set.items()): f.write(f&#x27; &quot;&#123;key&#125;&quot;: &#123;json.dumps(value)&#125;&#x27;) if i &lt; len(bf_res_set) - 1: f.write(&#x27;,&#x27;) f.write(&#x27;\\n&#x27;) f.write(&#x27;&#125;\\n&#x27;) 准确率与参数参考 需要说明是，准确性和时间受随机与性能的影响很大，因此以下结果仅作参考。 候选点交集： 交集 num：5 size = 1.5 search_time : 350 preicision: 0.94 num：5 size = 1.1 search_time : 168 preicision: 0.84 num：5 size = 1.0 search_time : 247 preicision: 0.91 num：5 size = 1.0 search_time : 119 preicision: 0.84 //这一步可以看到随机对结果和性能的影响 num：5 size = 0.5 search_time : 146 preicision: 0.77 num：5 size = 0.5 search_time : 100 preicision: 0.77 num：5 size = 0.2 search_time : 11 preicision: 0.53 num：5 size = 0.1 search_time : 3.39 preicision: 0.25 取并集： 并集 哈希一次 num：1 size = 0.02 search_time : 18 preicision:0.25 num：1 size = 0.05 search_time : 46 preicision:0.50 num：1 size = 0.10 search_time : 90 preicision:0.74 num：1 size = 0.20 search_time : 169 preicision:0.87 哈希三次 num： 3 size = 0.02 search_time : 58 preicision:0.60 num： 3 size = 0.05 search_time : 153 preicision:0.96 num： 3 size = 0.10 search_time : 230 preicision:0.97 哈希五次： num： 5 size = 0.01 search_time : 47 preicision:0.49 num： 5 size = 0.02 search_time : 86 preicision:0.72 num： 5 size = 0.05 search_time : 189 preicision:0.96 num： 5 size = 0.10 search_time : 290 preicision:0.997 参考 xducs/多媒体数据处理/LSH.ipynb at main · silence-tang/xducs · GitHub 一文看懂机器学习指标：准确率、精准率、召回率、F1、ROC曲线、AUC曲线 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"}]},{"title":"多媒体实验3：基于 BOF 进行相似图片搜索","slug":"课程报告/多媒体实验3图片搜索","date":"2023-06-12T21:10:47.000Z","updated":"2024-04-20T18:58:06.485Z","comments":true,"path":"post/20230613051047.html","permalink":"http://example.com/post/20230613051047.html","excerpt":"前言 BOF算法是一种通过特征来实现图像检索或分类的算法。","text":"前言 BOF算法是一种通过特征来实现图像检索或分类的算法。 目的/要求 使用BOF算法，在数据集上实现以图搜图：即输入数据集中某一张图，在剩下的999张图里搜索最邻近的10张图。数据集是按文件夹放好的 10 * 100 张 jpg 图片。 什么是BOF BOF，bag of features 是由自然语言处理领域的 BOW（bag of words）引申而来的。BOW，用一个袋子装起了一个个词，顾名思义就是用（关键）词为单位去处理文章句子。引申到图像领域，就用特征（feature）代替了关键词（words），即通过处理特征来处理图像。 具体地说，BOF的思想是这样的：每个图像的特征多少不一而足，我们将这些特征进行归类，就可以把一个的图像转化“有多少个xx”类特征这样的表述，从而方便计算和表述。这个过程就像是把图像的特征扔进一个个袋子里分类，即 bag of features。 而这就有了三个子问题：1.特征哪来？2.袋子哪儿来？3.咋扔？ 特征的来源很多，我们可以使 SIFT 特征，但是使用其他的特征也并非不可，例如 HOG 等。 袋子哪儿来？袋子并不是凭空出现的。而是根据数据集中的特征进行归类归出来的。这是一个把数据归类的问题，我们可以使用 KMeans 聚类算法把所有的数据归为人指定的 K 类。（K的值可能需要不断调整到最佳值） 扔进袋就是给一个查询点，将其放到最近的袋子中。我们可以使用 scipy 中 vq 来完成这一步。 这样，我们就完成了对一个数据集的初步 BOF 处理。 不过，为了更准确地进行搜索，我们还引入了 TD-IDF 对“单词”进行加权。 TI-IDF 想象一下下面两种情况： 在国际新闻中以“美国”为关键词进行搜索：搜索结果数量纷繁。 在国际新闻中以“贸易战”为关键词进行搜索：搜索的结果基本都和近年“中美贸易战”密切相关。 如果我们的目标是查询“2018年中美贸易战”有关的新闻报道，那么“贸易战”是比“美国”更重要的关键词。这是因为“美国”在几乎所有的文章中都频繁出现，而“贸易战”只在贸易战有关的新闻中频繁出现。 为此我们使用 TI-IDF进行评估。TF(term frequency)是某一个词语在一个文件中出现的频率，即词频。IDF（inverse document frequency，逆向文件频率）则衡量一个词语在所有文档中出现的频率。TF-IDF计算方法为： TF=文档中该词数量文档总词数TF=\\frac{文档中该词数量}{文档总词数}TF=文档总词数文档中该词数量​ IDF=lg文档总数包含该词的文档数IDF= lg\\frac{文档总数}{包含该词的文档数}IDF=lg包含该词的文档数文档总数​ $TFIDF= TF\\times IDF $ 只有在特定文件中高，但是在整体文件中低的词语，才能取得较高的TF-IDF值。 我们使用 TF-IDF 加权以后的特征来进行搜索以提高准确率。 程序的基本结构 有关功能基均有库可调，下面简单叙述我的程序中的各个函数。 get_dictionary()，读入图片，用 opencv 计算 SIFT特征。取特征的描述子使用 sklearn 中 KMeans 聚类，取聚类中心代表类。完成这一步，就相当于我们已经造好了“袋子”并找到了“词”。 corel_bof()：遍历前面保存的词，判断各个词最近的袋子是什么。并把结果存入一个 numpy.histogram 直方图中。这就相当于我们已经把词扔进了袋子，以后就可以用直方图代表此图片了。 tf_idf()：使用 sklearn 对直方图进行 TF-IDF 加权。 以上的步骤耗时较长，而且一经处理不再变动。因此可以将其导出为 JSON 或其他文件，方便后续使用。 搜索时则： search_similar()：对搜索图片同样进行上述三步处理。得到结果使用 sklearn 中 cosine_similarity计算其与我们的数据集的 TI-IDF 的余弦相似度。对其排序后返回最相近结果的前 K+1 个。因为我们的图片均来自数据集，因此最像的肯定是自己。 show_result：使用 pillow 显示最像的前 K 个图片。 程序中的一些小点 读入图片可以使用 glob.glob() 递归查找文件目录下的所有图片。 SIFT 的结果只要其中的描述子，这是因为关键点仅包含坐标信息，描述子才真正的表示了一个特征。我们所有的操作都是对描述子进行的。 cv2.imread 默认读入彩图是 BGR 格式，这会导致图片泛蓝。搜索和计算时这并不怎么影响，但是输出时就需要转为 RGB 格式或者直接用 pillow 的 Image.open()。 各个函数的格式要求不一，所以能见到反复转格式。特别是导出为 JSON 时需要转 NDArray 为 list。因为 JSON 是内置的库，但是 numpy 可不是。 试着使用了# region 来折叠代码，不过这不同于 C#，这并不是 python 本身提供的支持。我仅在 VScode 上验证可用。 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import numpy as npimport cv2import globimport jsonfrom PIL import Imagefrom scipy.cluster.vq import vqfrom sklearn.cluster import KMeansfrom sklearn.metrics.pairwise import cosine_similarityfrom sklearn.feature_extraction.text import TfidfTransformer# debugcorel_path = &#x27;./multi/corel/&#x27;query_img_path = &#x27;./multi/query.jpg&#x27;dict_file_path = &quot;./multi/dictionary.json&quot;bof_file_path = &quot;./multi/bof.json&quot;tfidf_file_path = &quot;./multi/tf-idf.json&quot;bag_of_features = []features = []tfidf_feature = []# region preProcessdef get_dictionary(mode): &quot;&quot;&quot; 根据图像生成特征字典：一共有这么多的特征。\\\\ 包含SIFT和KMeans两步 &quot;&quot;&quot; if (mode == &quot;load&quot;): with open(dict_file_path, &#x27;r&#x27;) as f: dictionary = np.array(json.load(f)) return dictionary progress = 0 for imgpath in glob.glob(corel_path+&#x27;*/*.jpg&#x27;): img = cv2.imread(imgpath) # 显示进度 print(&quot;load a pic success:&quot;+(progress+1).__str__()+&quot;/&quot;+&quot;100&quot;) progress += 1 # 获取img的所有描述子,不需要关键点 _, des = cv2.SIFT_create().detectAndCompute(img, None) features.append(des) # vertical stack,垂直堆叠二维数组 all_features = np.vstack(features) # KMeans对象对 all_features 聚类 k = 64 kmeans = KMeans(n_clusters=k, max_iter=300, n_init=10) kmeans.fit(all_features) # 词典即聚类中心 # k*128的二维数组 dictionary = kmeans.cluster_centers_ if (mode == &quot;save&quot;): with open(dict_file_path, &#x27;w&#x27;) as f: # ndarray不能直接输出为json json.dump(dictionary.tolist(), f) return dictionarydef corel_bof(dictionary, mode): &quot;&quot;&quot; 表示出每个图片包含特征字典中的哪些特征&quot;&quot;&quot; bag_of_features = [] if (mode == &#x27;load&#x27;): with open(bof_file_path, &#x27;r&#x27;) as f: bag_of_features = np.array(json.load(f)) return bag_of_features # 遍历所有描述子 for des in features: print(&quot;gennerated a des\\n&quot;) # 使用vq获得图片每个描述子最近的聚类中心（属于哪个聚类中心） code, _ = vq(des, dictionary) # 生成到直方图并归一化 # .shape[0]聚类中心的数量 hist, _ = np.histogram(code, bins=range(dictionary.shape[0]+1)) hist = hist/np.sum(hist) # 添加到列表中1000*64维 bag_of_features.append(hist) if (mode == &quot;save&quot;): with open(bof_file_path, &#x27;w&#x27;) as f: json.dump([arr.tolist() for arr in bag_of_features], f) return bag_of_featuresdef tf_idf(): &quot;&quot;&quot;&quot; 计算TF-IDF\\\\ TF值 = 词在文档中出现的次数 / 文档总词数\\\\ 逆向文件频率：IDF值 = log（语料库中包含某个词的文档总数 / 语料库中文档总数）\\\\ 每个词在每篇文档中的TF-IDF值：TF值*IDF\\\\ 在这篇“文章”中出现得多的且其他文章出现得少的“词”，才是能标明它身份的“词”\\\\ 大部分人都有的特征不算\\\\ &quot;&quot;&quot; # list[NDArray]-&gt;NDArray-&gt;稀疏矩阵-&gt;NDArray-&gt;list # 通过NDArray转化为list以输出 tfidf_feature = TfidfTransformer().fit_transform( np.array(bag_of_features)).toarray().tolist() with open(tfidf_file_path, &#x27;w&#x27;) as f: json.dump(tfidf_feature, f) return tfidf_feature# endregiondef searchSimilar(queryIMG, dictionary): # 对单个图像的ti-idf处理 _, m_des = cv2.SIFT_create().detectAndCompute(queryIMG, None) query_code, _ = vq(m_des, dict) query_hist, _ = np.histogram(query_code, bins=range(dictionary.shape[0]+1)) query_hist = query_hist/np.sum(query_hist) query_hist = np.array(query_hist).reshape(1, -1) query_tfidf = TfidfTransformer() query_tfidf = query_tfidf.fit_transform(query_hist).toarray() # reshape(1, -1)：转化为长度为一行的二维数组 # 返回1*1000的二维矩阵similarity similarity = cosine_similarity(query_tfidf.reshape(1, -1), tfidf_feature) top10_indices = np.argsort(similarity[0])[-11:][::-1] print(top10_indices) return top10_indicesdef show_result(result_array): imgs = [] total_width = 0 max_height = 0 for idx in result_array: img_path = corel_path+str(idx//100)+&quot;/&quot;+str(idx)+&quot;.jpg&quot; img = Image.open(img_path) imgs.append(img) total_width += img.width max_height = max(max_height, img.height) # 创建拼接后的图像 result_image = Image.new(&#x27;RGB&#x27;, (total_width, max_height)) # 拼接所有图像 x_offset = 0 for image in imgs: result_image.paste(image, (x_offset, 0)) x_offset += image.size[0] # 显示拼接后的图像 result_image.show()if __name__ == &#x27;__main__&#x27;: # load or save file_op = &quot;load&quot; # 字典、bof和tf-idf的获取 dict = get_dictionary(mode=file_op) bag_of_features = corel_bof(dict, mode=file_op) tfidf_feature = tf_idf() # 查询 query = cv2.imread(query_img_path, cv2.IMREAD_COLOR) result = searchSimilar(query, dict) # 结果 show_result(result) 参考资料 new bing 你是我爹","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"}]},{"title":"云计算实验：在 Windows 平台搭建 Hadoop","slug":"课程报告/Hadoop构建","date":"2023-05-23T11:00:56.000Z","updated":"2024-04-20T18:58:06.481Z","comments":true,"path":"post/20230523190056.html","permalink":"http://example.com/post/20230523190056.html","excerpt":"前言 云计算课程大作业：在本机配置一个 Hadoop 环境","text":"前言 云计算课程大作业：在本机配置一个 Hadoop 环境 准备工作 Hadoop 有三种运行模式：本地、伪分布、完全分布。由于这只是一次实验，我选择的是在本机搭建运行 Hadoop 的伪分布模式。此模式下，Hadoop 守护进程运行在本地机器上，模拟一个小规模的集群，形式上与完全分布相同，使用不同端口代表不同的机器。 我选择的平台与版本如下： Windows 11 Java 16.0.1 winutils 3.3.1 Hadoop 3.3.5 实验过程 下载 在 Apache 官网下载 Hadoop 的已编译版本，解压至指定目录（此处是 C:/Hadoop）中。 由于我已经装了 Java，所以本次实验我省略安装 Java 的步骤。 由于 Windows 不是 Hadoop 的最初开发和运行平台，目前支持还较为有限。为此，需要额外下载工具 winutils。此工具最初由官方社区开发者维护，但是较新版本来自开发者 github/kontext-tech。下载后放入 C:\\hadoop\\bin 文件夹内并复制一份hadoop.dll放到C:\\Windows\\System32下。yarn 已内置于此工具内。 配置文件 新建环境变量 HADOOP_HOME 指向 Hadoop 文件夹。Path添加 Hadoop 文件夹下 \\bin 和 \\sbin 文件夹的地址。完成后可以在终端内通过hadoop version检查是否能被正常识别且无错。 在 \\Hadoop 文件夹下新建文件夹如下： \\tmp \\data\\datanode \\data\\namenode 在 \\Hadoop\\etc\\hadoop 文件夹下,修改 core-site.xml 文件如下： 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/hadoop-3.1.3/data&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://your_host_name_or_localhost:9123&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 同文件夹下，，修改 hadoop-env.cmd 中的 Java_home 项的值为环境变量中 JAVA_HOME 的值，即指定 JDK 地址。 修改 hdfs-site.xml 文件如下，指定节点数量和实际存储地址。 1234567891011121314&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/C:/hadoop/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/C:/hadoopdata/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改mapred-site.xml 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改yarn-site.xml 12345678910&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services.mapreduce.shuffle.class&lt;/name&gt; &lt;value&gt;org.apache.hahoop.mapred.ShuffleHandler&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 特别地，在完成上述步骤后我遇到了端口冲突的问题，为了解决此问题，在 hdfs-site.xml 文件中继续添加参数如下: 123456789101112&lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9856&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.http.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9857&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.address&lt;/name&gt; &lt;value&gt;hdfs://localhost:9858&lt;/value&gt; &lt;/property&gt; 格式化与启动 在终端中输入 1hdfs namenode -format 进行节点格式化。观察到输出末尾有namenode has been successfully formatted 字样即格式化成功。 随后启动 \\hadoop\\sbin 目录下的 start-all.cmd。如果一切正常，那么将会弹出四个终端窗口且无报错。此时即已正常运行 Hadoop。 检查 在浏览器输入 localhost:9857 和 localhost:9856，访问 datanode 和 namenode。 使用 hadoop fs -put &lt;local_file&gt; &lt;hdfs_destination&gt; 命令上传文件、hadoop fs -get &lt;hdfs_file&gt; &lt;local_destination&gt;下载文件。创建文件夹（-mkdir）、列出文件（-ls）、删除文件（-rm）等命令与 Linux 系统相似。可以 在namenode中可以观察到上传成功，也可以使用 -ls 命令检查。 遇到的各种问题 winutils 的版本问题 最早的 Wintils 是由 Stevelougran开发的，他是 Hadoop 的提交者（committer）之一。由于忙碌，此仓库停留在了 3.0.0 版本，而后cdarlint继续开发并停留在了 3.2.2 版本，而kontext-tech继续在Fork cdarlint 后开发。 与本次作业的 Hadoop 版本（3.3.5）最接近的是 kontext-tech 的 3.3.1 版本，本次使用的就是此版本。经验证，能正常工作。 yarn --version 无结果 winutils 中包含了运行 Hadoop所需的 yarn，但是这一过程中我们没有给 yarn 配置环境变量，运行上述命令不成功。不过 yarn 实际上已经可以正常运行了。我们可以使用 where yarn（cmd）或where.exe yarn(powershell)来检查 yarn 存在的位置。 JAVA_HOME 的配置细节 需要注意的是，在 cmd 文件中 JAVA_HOME 指向使用的 Java 的地址。此地址不应该包含空格也不能通过打双引号的方式规避空格问题。二者的报错不一样但是均会有影响。前者为&quot;Error JAVA_HOME is incorrectly set.&quot;,后者为&quot;The filename, directory name, or volume label syntax is incorrect hadoop&quot; 针对空格源自 Progame files 的情况，可以通过改写为 PROGRA~1 来表达含义同时规避空格问题。（这是由于早期文件夹名不能包含空格引起的） 此外，电脑上还可能含有多个 Java 版本。通过如问题2所述 where 语句，我们可以检查到底有几个 Java 版本，在环境变量中调整顺序，使得需要的版本最前，即可保证 Java --version的检查结果和后续使用的是同一个版本。 格式化时结尾为&quot;SHUTDOWN_MSG: Shutting down NameNode at xxxx&quot; 这是正常现象，只要在其上可以找到namenode has been successfully formatted即可。 start-all.cmd 时出现&quot;error Couldn't find a package.json file in \\hadoop-2.7.7\\sbin&quot;错误 这一错误是由于有多个 yarn 引起的。例如 winutils 中包含了 yarn 而自己随后又通过 npm 安装了yarn。我选择了暂时卸载后者即可解决问题。 端口被占用 正常来说，我们可以通过杀死对应端口进程来结束占用。检查端口被进程占用的方法是终端中输入netstat -aon|findstr [端口号] 。然后结束对应进程（如果无返回结果则说明此端口无占用）。 但是奇怪的是我一开始并没有发现有什么进程占用了端口。不过通过上述第二部分改端口配置，可以成功解决 namenode 的端口占用问题。而 datanode 则还加了一次重启的步骤。 运行 start-all.cmd 后，可以通过使用 netstat -aon|findstr [端口号] node 对应端口号的方式确定程序在正常工作：各端口均有一个进程。 一个建议： 在配置过程中，不免频繁输入各类命令：例如不断运行 start-all.cmd 同时检查进程。这个过程中可以善用 Windows 终端的多窗口功能，将命令进行分类，使得窗口更加美观。不过，更改了环境变量以后，需要重新打开终端（而非shell）来使其生效。+ 参考资料 WIN10安装配置Hadoop-知乎 如何在windows系统下安装hadoop-CSDN Install Hadoop 3.3.0 on Windows 10 Step by Step Guide hadoop中修改端口号-李悠然-博客园","categories":[],"tags":[{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算","slug":"云计算","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"}]},{"title":"《第一行代码》笔记","slug":"AndroidNotes","date":"2023-05-13T12:00:39.000Z","updated":"2024-04-20T18:58:06.431Z","comments":true,"path":"post/20230513200039.html","permalink":"http://example.com/post/20230513200039.html","excerpt":"注意 这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。","text":"注意 这是一个长期更新的笔记，源于完全无基础的情况下阅读《第一行代码（第三版）》。不是一篇有条理的博文，并且会不断更新。 结构 Android视图不是真实视图但是屏蔽的文件基本无需修改。 project 目录下主要关心 app 文件夹。app 文件夹下 java：代码文件夹 res：图片、布局等资源 AndroidManifest.xml：项目配置文件 libs：第三方包 AndroidTest：测试","categories":[{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"}]},{"title":"从 &a+1 说起————数组变量、&和+运算符","slug":"数组名与指针与右值","date":"2023-04-20T15:04:57.000Z","updated":"2024-04-20T19:08:41.567Z","comments":true,"path":"post/20230420230457.html","permalink":"http://example.com/post/20230420230457.html","excerpt":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？","text":"摘录 对于数组a，&amp;a+1 输出了什么？&amp;和+在这里的作用是什么？ &amp;a+1 == ? 这个问题由和同学聊到这个标题而来，其中 a 是一个数组的名字。 一开始我想当然地认为：&amp;a 取得数组首地址，+1 指向数组首地址的下一个地址（字节）。但是事实并非如此，事实上，上面这个算式指向的数组末尾地址 +1 的那个地址。 为了搞懂这个问题，必须要理解一个在这之前的学习中被忽略的问题，即：数组是什么类型？int 型变量和 int 型数组和长度不同的 int 型数组，属于相同的变量类型吗？进而，我了解到了引用、左值与右值、以及关于指针的一些知识。 开始探索吧。 测试代码 我们以 c++ 来讨论这个问题，为此，定义变量并写下测试程序如下，我们稍后解释测试结果： 1234567891011121314151617181920212223// 数组int a[5];// 非数组变量int t = 2;int *p = &amp;t;// 引用int n = 4;int &amp;nn = n;// 数组值、大小printf(&quot;value: %d %d %d %d %d %d\\n&quot;, a, &amp;a, a + 1, &amp;a + 1, (int *)&amp;a + 1, (char *)&amp;a + 1);printf(&quot;sizeof: %d %d %d %d\\n&quot;, sizeof(a), sizeof(&amp;a), sizeof(a + 1), sizeof(&amp;a + 1)); // 20 8 8 8cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(a + 1).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;a + 1).name() &lt;&lt; endl;// 变量cout &lt;&lt; &quot;\\nsingle\\nvalue: &quot; &lt;&lt; p &lt;&lt; &#x27; &#x27; &lt;&lt; p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p &lt;&lt; &#x27; &#x27; &lt;&lt; &amp;p + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; *p &lt;&lt; &quot; &quot; &lt;&lt; *p + 1 &lt;&lt; endl;cout &lt;&lt; &quot;sizeof: &quot; &lt;&lt; sizeof(p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(&amp;p) &lt;&lt; &#x27; &#x27; &lt;&lt; sizeof(*p) &lt;&lt; endl;cout &lt;&lt; &quot;type: &quot; &lt;&lt; typeid(p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;p).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(*p).name() &lt;&lt; endl;// 引用cout &lt;&lt; &quot;\\n变量引用\\ntype: &quot; &lt;&lt; typeid(n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(&amp;n).name() &lt;&lt; &#x27; &#x27; &lt;&lt; typeid(nn).name() &lt;&lt; endl; 在上述代码中，我们使用了 sizeof 来检查输出变量的大小，typeid 运算符检查变量的类型。typeid 的 name 方法输出变量类型的名字。如下解读：A 指代 array，i 指代 int 型，P指代 pointer。其他的没有出现在输出中。 它的输出如下： 1234567891011value: 6487488 6487488 6487492 6487508 6487492 6487489sizeof: 20 8 8 8type: A5_i PA5_i Pi PA5_isinglevalue: 0x62fdb8 0x62fdbc 0x62fdb0 0x62fdb8 2 3sizeof: 8 8 4type: Pi PPi i变量引用type: i Pi i 对测试结果的解释 数组变量和数组退化 在定义一个数组变量，编译器将为数组分配一块连续的地址空间，并且产生一个数组变量 a。在这里，a 是数组名，也即所谓数组变量。数组变量是一种特殊的变量类型，它包含有【数组长度】个【数组单元变量类型】的变量。例如，我们的数组变量 a 就是包含了 5 个 int 型单元的数组变量。它不是一个 int 型变量，也不是含糊其辞的数组型变量。在我们是输出结果中，这被写作A5_i。 在很多情况中，数组变量 a 的表现和一个指向 a[0] 的指针一样，但是它们并不一样：指针不包含长度信息。很显然数组变量指明了数组的长度，但是一个指针并不清楚自己指向了一个数组单元还是一个变量。从数组变量变成指针，我们称之为“数组退化”。 “数组退化”的发生情况很多，最常见的一种是把它作为参数传入以后。为什么要这么设计很好理解：不同长度的数组是不同类型的变量，如果不退化成指针，写函数时就必须指定数组的长度，这很不方便。如果退化成指针，我们只需要再加一个参数指明数组长度就可以解决问题。 左值和右值 另一种会导致数组变化的原因是将其作为了右值。 左值和右值是 c++11 引入的特性。左值指能在内存寻址的值，右值则不是。我们用下面这个例子进行区分： 12int i;i= 12; 很明显我们不能说 12 存储在内存上的哪儿，但是可以说出 i 在内存的地址。 下面是数组变量因为作为右值而退化的例子（或者说，我们认为编译器在这里把数组名解释成了指向数组头的常量指针）。 123int a[5];a++;int *b = a+1 特别需要注意的是，尽管对左值进行自增操作是允许的，但是上面的 a++ 写法事实上是错误的，因为数组变量指向的地址是不可修改的。这也是为什么我们说它退化后是常量指针。 另外一个有意思的地方在于 a++ 和 a 一个返回右值一个返回左值。这是因为 a 操作先取得 a 的值，再返回 a 的值，最后把加一的值赋给 a ，++a 则完成了赋值操作再返回。这导致前者返回的值事实上不是 a 地址的值，所以只是右值。 关于 &amp; 符 &amp; 运算符有两种用法，第一种是取地址，第二种是取引用。 取地址当然就是取得变量地址，这意味着两件事：第一，它的右侧必须跟着一个左值；第二它返回的值的类型是指向某个地址的变量————即指针。 另一种引用是引用。引用相当于给 n 变量取了一个别名 nn。如果改变 n 的值，也就改变了 nn的值。这两个变量的地址是完全一样的，这不同于定义一个指针。nn 并不是一个指针，它和 n 有相同的变量类型和地址。 前面提到了 a++ 和 a ，而 &amp;a 和 &amp;++a 都是错误的，但是原因并不相同。前者是因为返回了右值，后者是因为视图修改常量指针。 指针的 + 运算 指针的 + 运算会得到不同的结果。具体来说就是，指针 +1 时，指的并不是地址 +1 字节，而是 +1 指针指向的变量大小单元。如果是 int 型指针，那么 +1 指的就是 4 字节，如果是 char 型，就是 1 字节。 如前所述，数组是数组类型而不是指针。所以一个指向数组的指针 +1 ，并不是加一个指针大小（64位系统上是 8 字节），而是加一个数组长度。首地址加数组长度，很显然指向的就是数组地址的尾地址 +1 了。 我们通过一个简单的小测试来验证这个说法：输出(int*)&amp;a+1和(cahr*)&amp;a+1。可以发现前者是在首地址基础上 +4，后者是 +1.这是因为数组变量型指针在 +1 前被转换成了 int型和 char 型，从而影响到了后续的 +1 操作的含义。 一个有趣的事情是，+ 运算符的优先级高于 &amp; 运算符。但是在 &amp;a+1 中会先执行 &amp; 运算，这是因为如果先执行 + 运算，返回的右值无法进行 &amp; 运算，出现语法错误，所以编译器隐式转换成了（&amp;a）+1。 总结 这里是前面的总结。 a:数组变量，直接输出得到其存储的数组起始地址。 a+1:数组变量退化成指向数组起始地址的指针常量，再加一个数组内单位长度 &amp;a：取数组变量的地址，会得到值是数组变量的起始地址，但是数据的类型是数组变量型指针 &amp;a+1：等价于 (&amp;a)+1，因此是数组变量地址的邻接地址 &amp;a++:错误,a++ 返回右值，返回值不是真正 a 的值，违反了 &amp; 的要求 &amp;++a:错误,++a返回左值，但是数组变量指向的地址不可修改 &amp;(a+1):错误，a+1是右值 （int*）&amp;a+1: 将数组变量类型指针转换为int型指针再加一个单位","categories":[{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"多媒体实验2：PCA主成分分析","slug":"课程报告/多媒体实验2PCA","date":"2023-04-10T14:47:38.000Z","updated":"2024-04-20T18:58:06.484Z","comments":true,"path":"post/20230410224738.html","permalink":"http://example.com/post/20230410224738.html","excerpt":"前言 PCA（Principal Component Analysis）是一种常用的数据分析方法。","text":"前言 PCA（Principal Component Analysis）是一种常用的数据分析方法。 从数据压缩说起 正如本课的课名所指出的,本课探究的是计算机对多媒体数据的处理分析过程。这个过程中，我们将人类看得懂的各类信息（声、图、文、语言等）输入计算机，期望计算机能对&quot;信息&quot;进行分析，进而发现&quot;知识&quot;，从中学习或者获得智能。把信息在人类载体（上述声、图、文、语言等）和机器载体（比特）之间变换的过程，就是编码和解码。数据压缩，就是在编码的过程中将庞杂的信息转化为更简短和信息，进而方便处理。 例如，对信息 111444444999995，我们可以记为 1#3 4#6 9#5 5#1 从而起到压缩的作用 在这个过程中可以注意到，不是所有的信息都具有相同的价值。压缩数据时，我们希望保留那么有价值的数据，而舍弃那些几乎没有关联的数据。这就带来了如何判断一个数据是否可以被舍弃的问题。 例如人的视觉和听觉中，对高频细节不敏感，可以在变换过程中滤除高频系数，保留低频系数，从而减少数据量。减少处理的难度。一个有名的例子是傅里叶变换。 我们首先定义数据的表示方式，我们记一条数据为一个向量，它的每一维都是一个类别的数据。我们希望对它进行处理，使得向量的维度尽可能的少，同时信息丢失尽可能的少。这个过程被称之为&quot;数据降维&quot;。 如果一个电商平台提供了浏览量和购买量两个数据，二者肯定不等价，但是浏览量高的店铺成交量往往更高。所以我们可以考虑舍弃其中一个数据，这样我们依然可以较好的衡量一个店铺的经营状况。 对此，我们可以采用 PCA。 PCA的思路--------重新发现 空间变换 我们已经知道 PCA 的目标是数据降维。接下来我们看看是如何做的。开始之前，我们先规定，一条数据是一个向量，多条数据排列就形成了一个矩阵。我们以矩阵为基本单位进行讨论。 以二维空间为例，如果对一个数据集，其点大致分布在直线 y=x 附近。我们可以想到，采用以 y=x 为轴而非 x、y 为轴的话，表示会更加简单。我们忽略 y=-x 方向上的量，把点投影到 y=x 上，此时仍可以基本保持原来的形状，同时，原来二维的数据被降维到了一维。 在这个过程中，我们进行了数据降维。本质上是把一个二维空间给变换到了一个一维空间。在线代中我们已经明白可以采取矩阵乘法进行变换。问题的关键是：我们已知需要变换到 K 维空间。如何选择此 K 维空间的基呢？即如何确定变换矩阵？ 具体来说，我们可以认为两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。 我们的目标是变换后尽量保留最多的原始信息。对此，一种直观的看法是：希望投影后值尽可能分散。 方差与协方差 高中阶段我们就已经知道，数学上使用方差来表达分散程度的概念。方差可以被如下表示： Var(a)=1m∑i=1m(ai−μ)2Var(a)=\\frac{1}{m}\\sum_{i=1}^m{(a_i-\\mu)^2} Var(a)=m1​i=1∑m​(ai​−μ)2 预先对矩阵进行处理使得均值为 0 ，则有 Var(a)=1m∑i=1mai2Var(a)=\\frac{1}{m}\\sum_{i=1}^m{a_i^2} Var(a)=m1​i=1∑m​ai2​ 多个维度中，我们希望尽可能多的表示原始信息，所以维度之间不应该存在相关性，否则它们的信息就会有重复。我们使用协方差衡量相关性。 Cov(a,b)=1m∑i=1maibiCov(a,b)=\\frac{1}{m}\\sum_{i=1}^m{a_ib_i} Cov(a,b)=m1​i=1∑m​ai​bi​ 相互之间协方差为 0 时，相关性最弱。所以我们需要选择相互之间协方差为 0 且字段方差尽可能大的一组向量作为基底。 在数学上，有：设 m 个 n 维数据记录排列成 n×mn\\times mn×m 的矩阵X，而 C=1mXXTC=\\frac{1}{m}XX^\\mathsf{T} C=m1​XXT 则 C 是一个对称矩阵。其对角线分别个各个字段的方差，而第 i 行 j 列和 j 行 i 列元素相同，表示 i 和 j 两个字段的协方差。 由前面的分析可知，我们使 C 非对角线为 0（协方差为 0 ），对角线由上到下递减。那么我们选取 X （而非 C ）的前 K 行，就得到了我们需要的变换矩阵。我们对 C 操作的这个过程被叫做矩阵的对角化。 现在问题变成了：如何使协方差矩阵对角化？ 特征值 一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量，设这n个特征向量为 e1,e2,⋯ ,ene_1,e_2,\\cdots,e_ne1​,e2​,⋯,en​ ，我们将其按列组成矩阵 E。对特征向量矩阵 E 和协方差矩阵 C，有： E^\\mathsf{T}CE =\\Lambda =\\begin{pmatrix} \\lambda_1 &amp; &amp; &amp; \\ &amp; \\lambda_2 &amp; &amp; \\ &amp; &amp; \\ddots &amp; \\ &amp; &amp; &amp; \\lambda_n \\end{pmatrix} $$ 进而我们需要的矩阵 P 有： $$P=E^\\mathsf{T} P 是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是 C 的一个特征向量。如果设P按照 Λ\\LambdaΛ 中特征值的从大到小，将特征向量从上到下排列，则用 P 的前 K 行组成的矩阵乘以原始数据矩阵 X ，就得到了我们需要的降维后的数据矩阵 Y 。 总结 总结 PCA 的思路。 目的：我们需要数据压缩，为此，将数据进行降维，删去那些没有带来额外信息或者带来信息极少的维度，即数据降维。 投影：我们将 M 维数据尽可能分散地投影到 K 维空间上。因为越聚集就代表投影以后（该方向）丢失的信息越多，得到的数据的信息越趋同。着我们尽可能让每个点的信息都被记录下来就需要分散。 例如: 在纸上画出一个立体图像的时候，我们会选用一个倾斜的角度展现三个面，而不是三视图中的一个面； 三维空间的直线投影到二维应该最好是投影成直线而不是一个点。 我们使用方差来衡量一个方向的数据分散程度，使用协方差来保证每个方向都是正交（相关性低）的。 我们使用特征值向量矩阵选取协方差矩阵中方差最大的 K 个正交方向（主成分），再把原始数据变换刚刚求出的 K 维空间中去即可。 PCA的具体步骤 我们可以把上述过程总结为下述步骤： 设有 m 条 n 维数据，我们将其排成 n 行 m 列（ n*m ）的矩阵 X，按一下步骤对齐进行 PCA： 将X的每个属性字段进行零均值化，即减去这一列的平均值（如果我们排成 m 行 n 列，也可以是减去行的均值）。 求出协方差矩阵 C=1mXXTC=\\frac{1}{m}XX^\\mathsf{T}C=m1​XXT 求出协方差矩阵的特征值及对应的特征向量 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 k 行组成矩阵 P 对 X 左乘矩阵 P，有 Y=PXY=PXY=PX 即为降维到k维后的数据。 PCA的python实现 我们可以使用 numpy 进行矩阵计算；使用 pandas 读取 ASC 文件中的数据 此外，scikit-learn 库中的 PCA 模块可以直接实现 PCA，我们可以使用它验证我们的代码。 具体来说，我们使用到了 numpy 的以下方法： np.mean() :求解行/列均值用于零均值化 np.dot(): 点积运算 instance.shape:获取行数、列数等数据 np.linalg.eig()：特征值 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import numpy as npimport pandasdef PCA(x, k): # n维n列 # m条m行 # m*n的矩阵 # 1\\. 形成样本矩阵，样本零均值化 # 压缩0轴（行），得到1轴（列）的均值 mean mean = np.mean(x, axis=0) x -= mean # 2\\. 计算样本矩阵的协方差矩阵 x_col = x.shape[1] cov = np.dot(x.T, x)/x.shape[0] # 3\\. 对协方差矩阵进行特征值分解 eig_vals, eig_vecs = np.linalg.eig(cov) # 对应特征值与特征向量 eig_pairs = [] for i in range(0, x_col): eig_val_i = np.abs(eig_vals[i]) eig_vec_i = eig_vecs[:, i] eig_pairs.append((eig_val_i, eig_vec_i)) # 选取最大的p个特征值对应的特征向量组成投影矩阵 eig_pairs.sort(reverse=True) feature = [] for i in range(0, k): feature.append(np.array(eig_pairs[i][1])) # 4\\. 对原始样本矩阵进行投影，得到降维后的新样本矩阵 reduced_data = np.dot(x, np.transpose(feature)) return reduced_dataFILEPATH = &quot;D:\\DocumentsSet\\ColorHistogram.asc&quot;data = pandas.read_csv(FILEPATH, sep=&#x27; &#x27;, header=None, index_col=0).valuesresult = PCA(data, 5)print(result) 参考资料 CodingLabs - PCA的数学原理","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"}]},{"title":"多媒体实验1：算术编码的 python 实现","slug":"课程报告/多媒体实验1算术编码","date":"2023-04-06T14:59:08.000Z","updated":"2024-04-20T18:58:06.482Z","comments":true,"path":"post/20230406225908.html","permalink":"http://example.com/post/20230406225908.html","excerpt":"前言 算术编码是一种编码算法，它比哈夫曼编码更高效。","text":"前言 算术编码是一种编码算法，它比哈夫曼编码更高效。 由哈夫曼编码说起 哈夫曼编码对于更高频的符号，使用更短的编码。由于编码的前缀是不一致的（短编码不是长编码的前缀），所以我们可以保证唯一确定一个编码的长度不发生混淆。 可以通过构造一个特殊的二叉树的方式求哈夫曼编码，这个树就是哈夫曼树。下面是一个哈夫曼树示例。 香农的信息熵公式指出 $$H(x)=-\\sum\\limits_{x} P(x)log_{2}[P(x)]$$ 其中 H(x)H(x)H(x) 为信息熵， P(x)P(x)P(x) 为每个符号出现的频次（概率）。 哈夫曼采用整数进行符号编码的，使得其不能更好的逼近信息熵极限。 例如，如果 A 的出现频次是 0.5，B 的出现频次是 0.4，C 的出现频次是 0.1。那么我们应该期待 B 的编码长度接近于 A，而不是 C，但是事实上 B 的编码长度和 C 一样长，是 A 的编码的两倍长。因此，其达不到最佳的编码长度。 一个更好的办法是：改用算术编码。 算术编码的原理 算术编码的本质思想，也是对于高频的字符进行短编码。但是具体实现并不相同。 设想一个区间被划分若干段。任给一个数字，通过比较我们就不难判断出其属于哪一个段。现在我们统计每个字符的频次，并将其依次对应到 [0,1)[0,1)[0,1) 区间内同样长度的一段内。编码一个字符，我们就找出对应的区间，并把区间内的一个数字作为编码值，就能唯一确定这个编码。 例如: 假设对字符 A、B、C，有 P(A) = 0.5 P(B) = 0.4 P(C) = 0.1 则对应到区间如下 A:[0,0.5) B:[0.5,0.9) C:[0.9,1)A:[0, 0.5)\\ B:[0.5, 0.9)\\ C:[0.9, 1)A:[0,0.5) B:[0.5,0.9) C:[0.9,1) 假设有编码值 E = 0.75，由于 0.75 在区间 [0.5,0.9)[0.5, 0.9)[0.5,0.9) 之间，所以对 E 进行解码就有解码值 D = &quot;B&quot; 在一个字符串内，我们重复这个过程，每次都在之前的编码区间内继续按比例进行划分。这样，我们就得到了为一确定了一个区间可以代表原来的文本。在区间里，按&quot;取二进制值最短的数作为编码值&quot;的原则取编码，就能得到算术编码的编码值。 解码的时候，我们进行上述操作的逆操作即可：不断划分区间，看编码在那个区间内，就继续对齐划分区间。 特别需要注意的是，在取编码值的时候，我们只考虑其编码值最短，这会引起一个解码时的问题，即我们不知道能解码多少位。因为所有以 MSG 为前缀的信息 MSG' 都处在 MSG 的编码区间内，我们难以确定是否 E 是 E(MSG),还是 E(MSGA) 或者 E(MSGB)。（吗） 算术编码的实现 下面给出我的算术编码代码思路。 decimal库：算术编码需要高精度的小数，在通常的浮点数运算中，很容易出现精度不够或者计算误差的情况（例如本应得到 0.3 但是实际内存中的值是 0.2999999999 或 0.3000000000041）。我们通过引入库 decimal 来解决计算位数和精度上的问题。 预设的比例区间 编码函数 encode：在上述区间内计算，得到一个结果区间。 解码函数 decode：对编码值转换为十进制，在上述区间内计算，确定属于什么区间，不断解码出信息。 十、二进制转换函数：我们使用十进制进行表示和计算，但是最终希望得到的编码是二进制值，因此，我们需要二者间的进制转换作为编码与解码的基础。特别的，bin() 求解的是区间（value。valueUp）区间内的最短值。具体来说，我们对左右区间不断转换二进制并比较，检查到二者的第一个相异位，此时左边界此为 0，右边界为1。我们取此位为 1。则得到最短编码值。只要我们认定编码值均小于等于右侧边界，就不会造成问题 源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import decimal# use Decimal for high precisiondef bin(value, valueRange): result = list() valueUp = D(value+valueRange) value = D(value) while 1: value *= D(&quot;2&quot;) valueUp *= D(&quot;2&quot;) # 均大于 if value &gt;= 1: value -= D(&#x27;1&#x27;) valueUp -= D(&#x27;1&#x27;) result.append(1) # 均小于 elif valueUp &lt; 1: result.append(0) # low0up1 else: if valueUp == D(&#x27;1&#x27;): result.append(0) result.append(1) break while 1: i = result.pop() if i: result.append(i) break return resultdef dec(value: list) -&gt; decimal.Decimal: w = D(&#x27;1&#x27;) result = D(&#x27;0&#x27;) for i in range(0, len(value)): w *= D(&#x27;0.5&#x27;) result += w*value[i] return resultdef encode(): encode_str = input() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) for i in encode_str: index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) return bin(l, nowRange) # h = thedict.get(encode_str[i]) # print(h)def decode(codebin: list, codelenth): codedec = dec(codebin) result = str() low = [D(&#x27;0&#x27;)] for i in range(0, len(distribute)): low.append(D(distribute[i])+D(low[i])) nowRange = D(&#x27;1&#x27;) l = D(&#x27;0&#x27;) st = D(&#x27;0&#x27;) for j in range(0, codelenth): for i in range(1, len(low)): st = (low[i])*nowRange+l # ed = st + nowRange if codedec &lt; st: index = i-1 # index = chars.index(i) l = l+nowRange*low[index] nowRange = nowRange*(low[index+1]-low[index]) result += chars[index] break return resultif __name__ == &#x27;__main__&#x27;: D = decimal.Decimal decimal.getcontext().prec = 32 chars = input(&quot;Dict:&quot;).split(&#x27;,&#x27;) # if default if chars[0] == &quot;0&quot;: chars = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;] distribute = [D(&#x27;0.1&#x27;), D(&#x27;0.4&#x27;), D(&#x27;0.2&#x27;), D(&#x27;0.3&#x27;)] else: distribute = input(&quot;Distribute:&quot;).split(&quot;,&quot;) ans = encode() print(str(ans)) ans = decode(ans, 7) print(ans) 参考资料 什么是算术编码 - 知乎","categories":[{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"}],"tags":[{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"}]},{"title":"2022 Seed 训练营笔记收录","slug":"Seed训练营笔记收纳","date":"2023-03-24T14:47:43.000Z","updated":"2024-04-20T18:58:06.459Z","comments":true,"path":"post/20230324224743.html","permalink":"http://example.com/post/20230324224743.html","excerpt":"前言 2022 年参加 Seed 训练营的笔记，另附 Seed 训练营感想。","text":"前言 2022 年参加 Seed 训练营的笔记，另附 Seed 训练营感想。 开发系列课 1.架构 架构的意义是什么？ 划定边界 生物属于动物，但是哪些东西能判定一个生物是动物？ 玩家操作player，玩家不能操作NPC，Bot属于NPC还是player？其他玩家属于player还是NPC？ 只有划定边界才能解决这个问题 设计就是不断的重新划定边界 例子：建筑师需要定义规格 建筑师的设计需要有极多的国家规范 软件项目也需要规格，设计者就是一种建筑师 例如player设计可能有三米高，但是建模只能允许两米以下的player进入 只有严格的物理计算参数才能有和谐的演示效果 设计可能存在的问题 性能的过度冗余：明明只有1000的在线，却考虑1000K的在线性能 功能的过度冗余：明明只需要打电话，却也考虑了打游戏的功能。 讨论架构需要画图 1.5.实现架构 抄 面向项目内代码编程 面向GitHub/Stack overflow编程 依葫芦画瓢 2.模块的基本目标 问题：区分边界：这个函数该在这个模块还是那个？ 要求：用词准确：没有二义性、也不过于繁琐失去宏观性。 困难：语言本身却存在模糊性 解决方案： 减少词的二义性： 形成团队共识 使用最基本的共识：自从词语最基本最字面的意思来使用。 举例：不使用“持有”而使用“拥有”或“在手上”。 注意：如果一个模块囊括了太多不同的功能，模块也就失去了它的意义（state controller） 反复绕来绕去的逻辑是bug的温床 2.5模块间的关系 关系A：关联、泛化、细化、依赖 关系B：聚合、组合 模块之间相互用到信息或服务 脚本可能是一个模块，模块和模块之间还可能构成一个更大的模块。不能忽视后者的存在。（如玩家移动模块和玩家背包模块可能同时构成玩家模块） 如果一个模块已经被聚合了，对外界应该是一个统一的模块。这就是说，外界应该统一从一个地方调用模块内部接口，而非在深入了解后从各自的地方调用。这样可以避免同步的问题等等。 3. Debug bug的三步走 重现bug 打断点是最快最方便的定位方法 有时过多断点需要通过条件过滤断点 分析原因 重新设计 避免不一致的设计 如果闻到“bad smell”那一定有什么不对劲 内部用户的易用性也是非常重要的，即使改动非常小 4. 项目程序规范 不提交无关的文件 删除调试代码 一次提交一个bug 提交时的注释很重要 注释中文还是英文：从大家利于理解的角度 有统一最重要，是什么不重要。 命名规范 代码风格 其他内容 创意与原型：创意部分 A.困惑 如何快速产生大量创意？ 如何清晰快速有感觉的展示？ 如何判断创意是否靠谱？ B.发现创意 step1：一个主题+三个词 标准：使用名词或动词,不使用形容词。因为每个人对形容词的感受是不一致的。 step2：一个名字+三句话 用三句话写明短中长期的玩家历程体验 step3：图文一页展示 找图片：要求贴合三句话、画风一致、符合自己的想法（包括对画风的想法） 排版等 step4：电梯演说概述游戏 电梯演说：高效地表达自己的想法 提高演说力：乔布斯的模拟演讲 e.g:“我想做一个野炊式画风崩坏式战斗的弱联机开放世界…“ C.设定Box 划出你的边界，游戏创意不能超出这个边界 如何设定box？ 从自己出发:兴趣、擅长 从市场出发:行业数据、市场调研 创意与原型：原型部分 原型不等于游戏：它只是解答问题、验证想法的游戏的部分模拟。 游戏demo又或者纸面原型。 A.明确问题 例如 sf4中，什么是玩家需要抉择的？ 皇室战争中，玩家会如何搭建自己的卡组？ PUBG，玩家会如何选择开局？带来什么体验？ 头脑风暴 rules： 头脑风暴不管对错，不做评价 头脑风暴时，点子越多越好 即使有人讲错了，只需要往最终的方向带就行 需要存在一个主持人 原型头脑风暴只为最终体验服务 不同类型的交通工具消耗成本、运载容量等数据固然重要，究竟是摩托车还是电瓶车却是更直观具象的游戏体验。 头脑风暴为游戏提供所需的元素 B.明确范围 以SF4为例： 时长：模拟的是一个回合的瞬间？还是一个回合？还是若干回合？ 时期：模拟游戏早期？末期？ C.明确形式 原型准备： 玩家输入 接单、过单… 系统输出 -出单、奖励…… 桌游 开票 跑团 玩 自己和自己 和策划 设计师眼中的游戏 1.游戏是构建体验的系统 为什么游戏是构建体验的系统 最核心的目标就是构建体验，但是为什么是游戏？ 游戏的互动性 体验大于玩法，玩法服务于体验。 同样的玩法，换一个设定，也许吸引的人就完全不一样。 构建体验的四要素 机制、设定、美学、技术 2. 体验从理解人类开始 A.理解用户 人的注意力是有限的 模式认知：人脑会自动识别抽象。 ￮ 容易认知模式 ￮ 不容易掌握 对比产生美 可塑的大脑：越练习，越熟练 情感黑盒：吊桥效应 大脑的偏见：看上去不一样长的线实际上一样长 人是千差万别的 男女差异、MBTI、职业、游戏经历…… 用户的动机 quanticfoundry的玩家动机理论，九种玩家 B.理解市场 市场是多变的，也是可预测的 市场的特点： 市场竞争 游戏是非竞争性商品 游戏可以被轻易的复制，不会因为我玩别人就没办法玩 马太效应 强者恒强，强力的游戏可以轻易吸走冷门游戏的用户 创新者的困境 巫师三让市场对2077有过高期待 英雄联盟让拳头难以花时间精力推出新的游戏 船大难调头 细分市场：细分市场是信息流转充分发达情况下的必然结果：适合大部分人的 80 分产品也许吸引不了大部分人，适合小部分人的 95 分产品却很有可能吸引小部分人中的大部分人。 未被开发的细分市场就是蓝海市场。 B.市场定位（竞争） 自我定位 在细分市场的定位 蓝海？还是红海？ 竞品？ 自己在和什么游戏对比？ 市场会拿来和什么游戏对比？ 哪些地方更好了？哪些地方可以被放弃? 3. 什么是好的游戏 A.好的体验 强烈的情感体验：高光时刻 心流体验：这个玩家太难，那个玩家也许太简单 沉浸： B.可持续发展 利润=营收-开发成本-营销成本 营收=用户规模*用户付费 营销也是产品设计的一部分：广告、买量、主播直播、黑魂是数值不平衡的垃圾游戏还是有挑战性的硬核游戏？（hook成本） 积累=提升质量、降低成本 作品管理入门（以三周的 Seed 项目为例） 如何把想法落地？ 排期表 开发流程前决定谁是 PM 玩法验证 不要复合验证，不要着眼于验证中新产生的想法 开发过程注意 完整流程与工作项的 mapping 优先交付高价值的部分 敏捷开发 晨会制度：同步成果、目标、困难 展示会 回顾会 情感表现 好的剧本可以拍出好的电影，但是好的剧本不一定能拍好电影 同样的事情，想要传达不同的情感会深刻改变游戏的： 场景调度 隐喻：破案感、发现穿帮镜头的兴奋感 节奏（情绪曲线）：好莱坞三段式… 引发回忆：引发群体回忆、各年度回顾 灯光：主光辅光轮廓光的软度硬度 转场 设计流程 学会根据需求预估工作量 多少模块？ 多长时间？ 多少行代码？ 需求分析 理解、分析、注意约束 未表达的要求 潜在的限定 未来可能的发展变化 系统责任和对外交互 逐个完成模块设计，然后汇合 需要的话，画状态图和（或）流程图辅助代码设计----“盖大楼”的“脚手架” 可能的设计方向 以点带面（最常见） 自顶向下（技术要求高） 自顶向上，逐步拼装 自中向下，在逐步拼中为大 要达到更高的技术要求，就要有从“以点带面”向“自中而下”靠拢的行动力。 不太重要的 不太重要，或者说我没太记的一些笔记。 音频 游戏中音乐类型 音效与音乐 音乐功能设计 氛围营造： 闪避效果：人声压背景 分轨设计：转阶段后不断叠加分轨音乐细节更加丰富 反馈信息： RTPC：实时根据游戏参数反馈改变音乐 娱乐效果： 游戏音乐内容制作 主流中间件：Wwise，Criware… 快捷制作 audio editor插件 心理 情绪曲线 心理需求 丰富的体验 消极情绪+积极情绪 消极情绪的作用：快速参与代入、高强度的代入 推荐 心理学家的面相术 情绪（蓝色粉笔字封面） emotionpolygon 游戏数据 制作是不断优化选择的过程 手上有多少东西可以选？ 游戏源自生活 电影和游戏 电影：剧本 游戏：机制+剧本 游戏： 纯机制的游戏是存在的 剧本可以辅助理解游戏机制 表达情感","categories":[{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"}]},{"title":"2022 Seed 训练营笔记收录","slug":"维塔士实习回顾","date":"2023-03-24T14:47:43.000Z","updated":"2024-04-20T18:58:06.479Z","comments":true,"path":"post/20230324224743.html","permalink":"http://example.com/post/20230324224743.html","excerpt":"","text":"前言 记第二次实习：在维塔士西安工作室的虚幻Demo。 开始与 Unreal 学习 七月的困顿中发现了老师在群里发的维塔士西安工作室的实习海报，于是抱着再怎么样也比在学校勉强自己对着牛客OJ发呆好的态度报名，然后面试等等各种流程走下来，也就是入职了。 维塔士西安是西安仅有的几家游戏公司，所以虽然本身是 2B 的业务但是居然也让我听过，再加上上个学期有参与 OpenDay 也就更熟了一点（和 NS 失之交臂呜呜）。 Git树上下 树下的肥（屎）料（山） 这次主要是负责了 Buff 系统;整个设计大概是这样的： 角色有 Buff 和技能； Buff 修改玩家的属性，技能则由玩家主动施放，由更多的自由度。 例如，我们可以将手雷设计为一种技能，血包设计为一种技能，他们有对应的按键，有特效，有各种独一无二的动画和逻辑…… 而 Buff 只需要储存什么修改了玩家的什么属性即可 所以 Buff 只需要是一种数据结构 Buff 有冲突、有一个 Buff 改多种属性、有时限，有延时增减等情况。 话是这么说，但是实际上写起来却乱七八糟。一开始我设想了一种基数据类，他存储了最基本的数据信息，然后，对于不同的时限等问题分开衍生子类。这样，就可以用一个指针队列存储所有的 Buff 了。但是这样做的问题在于数据类型实际上是不一样的，需要类型转换（例如我们也许会有 Float 型的血量，但是 int 型的金钱）。这样做技术上来说并没有问题，但是说到底 void* 指针强转本身就是不安全的。尽管在这一方向的尝试让我了解了模板的一些知识，但是最后我还是放弃了这种做法。 最后的“摆烂”做法是将所有的数据堆在了一个数据结构中，对于不需要的数据（例如一个无限时的 Buff）直接置空就行。这种做法当时看来是摆烂、权宜的做法现在想想其实是正确的。回头翻翻在西山居的代码，也是读表读出的字符串，然后在构造的时候做类型转换。（这里的类型转换是基本类型，而且不牵扯到内存地址，所以并不是那么的不安全）。那么对于这个数据结构，我们也完全可以做这样的权益，即大家都用 float 型，或者放大以后用 int 型，抑或 string，这样就可以使用统一的容器存储他们了。如果我们用的时候是做其他类型的值————无非int/ float / bool 等等，再去做类型转换就 ok 了，至于转换的逻辑，例如大于零则视为 bool 为真完全可以放到对应属性的逻辑函数中去做。 我原本的设想是数据结构中有一个指向其附属角色的指针，这样就抽象成将 *buff.AttributePtr 赋值为 buff.value 就可以了。但是事实上根本没有足够多的属性值得去这么做，即使有，也完全可以写成让 changeAttribute() 根据实际参数去定义一个对应的指针。 事实上，在云计算的课程中就讲到过，应该是 google 云计算数据库只能存入字符串类型的值，大大简化数据的存储管理，不管要什么值，要值的一方自己去做转换即可。毕竟索取值的一方自己肯定很清楚值的类型。 另一个值得一提的思考是属性组件，按理来说属性组件是存储所有的属性，但是事实上这样做不妥：如果是 public 那么属性是不安全的；如果是private/protected ，每个组件用到属性的地方都会产生一个函数调用。而且，UE 框架中的 MovementCoponent 本身已经是写好的了，我们总不能重载它去适应我们的属性组件吧？ 所以更好的办法是每次修改值的时候，属性组件去查询对应的组件的值然后做修改，如果有事件，不妨也在属性组件做通知。这样只要保证大家都从属性组件做修改就不会有问题。此外，可以所有的组件声明属性组件为友元，这样就可以不写函数接口，而只有属性组件能只有访问那些私有成员，其他的组件没有办法去做修改。（当然友元的写法会破坏面向对象的封装性，但是暂时想不到其他更好的解决办法了，也许最好的办法是不要AttributeComponent）。 其他的一些工作：改蓝图，让 Buff 加成的属性在血条上显示成蓝色（其实是做了两个血条）。以及各种情况下的读蓝图，也算会了点蓝图的基本操作。 树上的猴子 这次实习我们使用的是跑在局域网上的 Git 仓库，之前不能说没有用过 Git 但是还确实没用过其进行多人协同，这次也算是一次体验了。 rebase, merge, fetch,revert... 这些操作有些之前不是很熟悉也借此机会有了一定的了解。一次很离谱的操作则在于某次 push 后所有的 commit 都有我作为合作者了……另外一个麻烦的地方则在于每次有版本落后，即使没有冲突，使用 VS-git 也会自动创建一个 Merge commit 使得分支受到了一定的污染。 另一方面则是隔壁的某组模仿我们组没有使用 SVN，结果看到他们反复地请正式员工来做 git 的 debug……看到这种场景不由让人领会到自己平时的训练积累的重要性。说到底如果没有有关经验的人在正式项目中这么做的话，不提时间、效率的问题，也难免会让人产生挫败，消磨斗志。 其他的一些思考与牢骚 蓝图这种可读性居然需要通过挪格子和连乱七八糟的线来保证的产品，虽然降低了一点点门槛，但是看得真是让人头大。 不想和不会做变量命名、写出来的东西只有自己能 debug 的人说话。 远离指针…… 通勤时间实属人幸福感的一部分，每天七点过起床赶八点的高新六路，然后忍受堵车，下车找共享单车骑在早高峰的十字路口……这种体验实在是一个月就够了。","categories":[{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Unreal","slug":"Unreal","permalink":"http://example.com/tags/Unreal/"},{"name":"杂录","slug":"杂录","permalink":"http://example.com/tags/%E6%9D%82%E5%BD%95/"}]},{"title":"GAMES101-4：视图和投影变换","slug":"GAMES101/GAMES101-4","date":"2023-03-18T09:14:50.000Z","updated":"2024-04-20T18:58:06.449Z","comments":true,"path":"/GAMES10104.html","permalink":"http://example.com/GAMES10104.html","excerpt":"前言 GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5","text":"前言 GAMES101-P4：视图变换和投影变换（正交投影、透视投影）。透视投影部分内容在原视频P5 如何拍一张照片：MVP变换 Model Transformation:摆好位置 View Transformation：找好拍照角度 Projection Transformation：拍照。 视图变换：View 思考：任何情况下进行拍照，照片都只和物体相对于相机的坐标有关。 所以建立一个新的坐标系（相机坐标系）规定 相机处于原点； 相机的向上方向是 Y （up at Y）； 相机看向 -Z 方向。 将坐标转换： 平移相机至原点 旋转使向上方向为 Y，旋转使相机看向的方向为 -Z。 求此处旋转矩阵，可以求坐标轴旋转为相机轴的旋转矩阵，然后转置。 投影变换：Projection 两种投影方式： Orthographic Projection：正交投影 Perspective Projection：透视投影 透视投影更接近人眼成像，会有“近大远小”、“平行线相交于一点”等效果。 在如下图所示的模型中，透视事实上就是拍下了锥形视野内的 [n,f] 内的一段区间内的物体，正交则是相机处于无限远处的一个特例。 正交投影 构建相机坐标系 构建一个包含所有物体的空间立方体，描述它为 [l,r]×[b,t]×[f,n][l,r]×[b,t]\\times [f,n][l,r]×[b,t]×[f,n] 的一个立方体（左右下上远近）。是由远及近是由于右手坐标系且看向 -Z 方向导致远处 Z 坐标更小。 将结果规范化在一个 [±1,±1,±1][\\pm1,\\pm1, \\pm1][±1,±1,±1] 的方块内 矩阵形式：中心移至原点，再缩放 Mz=[2r−l00002t−b00002n−f00001]×[100−r+l2010−b+t2001−n+f20001]M_z=\\begin{bmatrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\times \\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{b+t}{2}\\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Mz​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎥⎤​×⎣⎢⎢⎢⎡​1000​0100​0010​−2r+l​−2b+t​−2n+f​1​⎦⎥⎥⎥⎤​ 透视投影 对如上图的透视，定义近平面 n 和远平面 f，有： 近平面保持不变，其余地方进行“挤压”使得其与近平面一样大。使上图左侧变成右侧形状。 进行正交投影 透视投影的变换矩阵 这里有一个需要注意的地方是，挤压以后，坐标的 Z 轴值“可能”会发生变化。对此我们规定： n 平面上的坐标不变 f 平面上的坐标 Z 轴不变，且平面中点坐标不变 对于任意的点 (x,y,z)(x,y,z)(x,y,z) ，对应到一个 n 平面上的点 (x′,y′,z′)(x&#x27;,y&#x27;,z&#x27;)(x′,y′,z′)。相似三角形有 \\begin{align} y&#039; =\\frac{n}{z}y\\\\ x&#039;=\\frac{n}{z}x \\end{align} 接下来求解 Z 轴的变换方程，即矩阵的第三行。 假设变换矩阵为 M，有： M(x,y,z,1)T=(nzx,nzy,z1,1)T=(nx,ny,z2,z)TM(x,y,z,1)^T=(\\frac{n}{z}x,\\frac{n}{z}y,z_1,1)^T=(nx,ny,z_2,z)^T M(x,y,z,1)T=(zn​x,zn​y,z1​,1)T=(nx,ny,z2​,z)T 其中 z1,z2z_1,z_2z1​,z2​ 未知。 z1z_1z1​ 的值的变换向量是 M 矩阵中的第三行，所以可以只关心第三行。又因为 Z 坐标值显然和 XY 没有关系，所以此行可以写为 (0,0,A,B)(0,0,A,B)(0,0,A,B) 其中 A、B 未知。 n 平面上的点满足变换矩阵且 Z 坐标不变。所以 n 平面上的坐标可以写成 (x,y,n,1)T(x,y,n,1)^T(x,y,n,1)T 。同时乘以坐标 n，代表的点依然不变：(nx,ny,n2,n)T(nx,ny,n^2,n)^T(nx,ny,n2,n)T。 所以有 (0,0,A,B)(x,y,n,1)T=n2(0,0,A,B)(x,y,n,1)^T=n^2(0,0,A,B)(x,y,n,1)T=n2 f 平面同样中点 (0,0,f,1)(0,0,f,1)(0,0,f,1) 满足变换矩阵且 Z 坐标不变。于是 (0,0,A,B)(0,0,f,1)T=f2(0,0,A,B)(0,0,f,1)^T=f^2 (0,0,A,B)(0,0,f,1)T=f2 于是可以联解 \\begin{align} An+B =n^2\\\\ Af+B =f^2 \\end{align} 得 \\begin{align} A = n+f\\\\ B = -nf \\end{align} 所以解出 Z 轴变换方程值， M 矩阵 [n0000n0000n+f−nf0010]\\begin{bmatrix} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -nf \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix}⎣⎢⎢⎢⎡​n000​0n00​00n+f1​00−nf0​⎦⎥⎥⎥⎤​ 近平面的表示方法：可视角度 我们通常认定近、远平面的深度（z轴）是已知的，所以现在的问题是如何描述近平面： 指定近平面四个点的坐标 指定宽高比和可视角度。下图为 y 轴可视角度的表示，根据 y 轴可视角度和宽高比可以求出 x 轴的可视角度 两种表示是可以互相转换的，如下： 其中近平面的范围为[±r,±t][\\pm r,\\pm t][±r,±t]，aspect 为宽高比。 跳转 Home：GAMES101-1：课程总览与笔记导航 Prev：GAMES101-3：变换 Next：GAMES101-5：(三角形的)光栅化","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"}]},{"title":"GAMES101-3：变换","slug":"GAMES101/GAMES101-3","date":"2023-03-10T05:28:27.000Z","updated":"2024-04-20T18:58:06.448Z","comments":true,"path":"/GAMES10103.html","permalink":"http://example.com/GAMES10103.html","excerpt":"前言 GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。","text":"前言 GAMES101-P3：基本线性变换（旋转、缩放、切变）和平移、仿射变换矩阵、齐次坐标、三维变换中的旋转问题。 对图形进行各种变换，可以相当于对其左乘对应矩阵。 基本线性变换 缩放矩阵 [sx00sy]\\begin{bmatrix} s_x &amp; 0\\\\ 0 &amp; s_y \\end{bmatrix}[sx​0​0sy​​] 切变 （Shear） 矩阵: [1a01]\\begin{bmatrix} 1 &amp; a\\\\ 0 &amp; 1 \\end{bmatrix}[10​a1​] 切变的本质就是将矩形变成平行四边形。坐标不变的一条边称之为依赖轴，变换称之为方向轴。下图为一个 y 为依赖轴的例子： 旋转：旋转点通常是原点。[cosθ−sinθsinθcosθ]\\begin{bmatrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{bmatrix}[cosθsinθ​−sinθcosθ​] 对旋转矩阵，其反方向旋转的对应矩阵为其逆矩阵同时也是转置矩阵。 齐次坐标和仿射变换 使用 n+1n+1n+1 维坐标表示 nnn 维坐标。其中，对于点，记为 (x,y,1)T(x,y,1)^T(x,y,1)T，对于向量，记为 (x,y,0)T(x,y,0)^T(x,y,0)T 由于平移，不能写成左乘形式进而与其余变换统一。所以我们引入齐次坐标，使得平移矩阵为 [10tx01ty001]\\begin{bmatrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}⎣⎢⎡​100​010​tx​ty​1​⎦⎥⎤​ 思考：为什么向量和点的第三维不一样？ 对于向量，具有平移不变性，我们不希望其左乘平移矩阵得到的结果是新的向量，对于点的想法则相反。因此向量的最后一维应为 0 使得其不受平移矩阵影响。 进一步地，有： 向量 + 向量 = 向量 向量 + 点 = 点 点 - 点 = 向量 点 + 点 = 二者中点 …… 可以发现向量为 0 而点为 1 的情况对于上述现象也可以解释得很好。 仿射变换 定义仿射变换：仿射变换 = 线性变换 + 平移。 使用齐次坐标可以表示仿射变换。齐次坐标等于多个线性变换矩阵、平移变换矩阵左乘后的结果。 M=[abtxcdty001]M=\\begin{bmatrix} a &amp; b &amp; t_x \\\\ c &amp; d &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{bmatrix}M=⎣⎢⎡​ac0​bd0​tx​ty​1​⎦⎥⎤​ 其中 a,b,c,da,b,c,da,b,c,d 表示旋转、缩放、切变，tx,tyt_x,t_ytx​,ty​ 表示平移。 逆矩阵 对于仿射变换矩阵 M，定义逆矩阵： MM−1=EMM^{-1} = E MM−1=E 其中 E 为单位矩阵。 M 的逆矩阵恰好对应原来仿射变换的逆变换。 特别地，对于旋转变换，其逆矩阵和转置矩阵相同，使得求其逆变换变得方便。逆矩阵等于转置矩阵的矩阵被称为正交矩阵。 矩阵不满足交换律，变换也不满足交换律。变换的顺序很重要。 绕任意点的旋转 设任意点为 P，将旋转分解为：把 P 平移回原点、旋转 α 度、平移 P 回 P 点。 于是有变换矩阵： T=T(P)T(α)T(−P)T = T(P)T(\\alpha)T(-P) T=T(P)T(α)T(−P) (注意顺序是由右到左表示的) 三维变换 对于三维变换，可以简单地写出缩放和平移，重点关注旋转。 绕轴旋转 考虑简单的旋转：绕一个轴在一个平面内旋转。 Rx=[10000cos⁡α−sin⁡α00sin⁡αcos⁡α00001]R_x=\\begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 \\\\ 0 &amp; \\sin\\alpha &amp; \\cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Rx​=⎣⎢⎢⎢⎡​1000​0cosαsinα0​0−sinαcosα0​0001​⎦⎥⎥⎥⎤​ Ry=[cos⁡α0sin⁡α00100−sin⁡α0cos⁡α00001]R_y=\\begin{bmatrix} \\cos\\alpha &amp; 0 &amp; \\sin\\alpha &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -\\sin\\alpha &amp; 0 &amp; \\cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Ry​=⎣⎢⎢⎢⎡​cosα0−sinα0​0100​sinα0cosα0​0001​⎦⎥⎥⎥⎤​ Rz=[sin⁡αcos⁡α00cos⁡α−sin⁡α0000000001]R_z=\\begin{bmatrix} \\sin\\alpha &amp; \\cos\\alpha &amp; 0 &amp; 0 \\\\ \\cos\\alpha &amp; -\\sin\\alpha &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} Rz​=⎣⎢⎢⎢⎡​sinαcosα00​cosα−sinα00​0000​0001​⎦⎥⎥⎥⎤​ 请注意 y 轴中 sinαsin\\alphasinα 的正负号与其他情况不同。 这是因为旋转矩阵的循环对称性。即 xyzxyz 的矩阵循环中，一个的值等于前面两个的值相乘。所以对 R_y 有 Rz×Rz=RyR_z \\times R_z = R_yRz​×Rz​=Ry​ 而非相反。 绕任意轴旋转 对于任意角度的过原点轴，可以把它分解为三个轴上的角度（欧拉角）。变成三个轴的变换矩阵的乘积。 对绕任意轴 nnn 旋转 α\\alphaα 角，有 Rodrigues' Rotation Formula 如下： R(n,α)=cos⁡(α)I+(1−cos⁡(α))nnT+sin⁡(α)N\\bold{R}(\\bold{n},\\alpha) = \\cos(\\alpha)\\bold{I}+(1-\\cos(\\alpha))\\bold{n}\\bold{n^T}+\\sin(\\alpha)\\bold{N} R(n,α)=cos(α)I+(1−cos(α))nnT+sin(α)N 其中 N=[0−nznynz0−nx−nynx0]\\bold{N}=\\begin{bmatrix} 0 &amp; -n_z &amp; n_y \\\\ n_z &amp; 0 &amp; -n_x \\\\ -n_y &amp; n_x &amp; 0 \\end{bmatrix} N=⎣⎢⎡​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎦⎥⎤​ 其中，称 N\\bold{N}N 为 n 的反对称矩阵，也就是向量 n 的叉积（n⃗×a⃗\\vec{n}\\times\\bold{\\vec{a}}n×a ）的矩阵形式。 对于任意不过原点的旋转，把其分解为平移原点、旋转、平移回去的过程。 引入四元数是为了更好地对旋转进行插值，关于四元数，另行参考。 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-2：回顾线代 Next：GAMES101-4：视图和投影变换","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"基本线性变换","slug":"基本线性变换","permalink":"http://example.com/tags/%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"}]},{"title":"GAMES101-2：回顾线代","slug":"GAMES101/GAMES101-2","date":"2023-03-09T06:53:39.000Z","updated":"2024-04-20T18:58:06.446Z","comments":true,"path":"/GAMES10102.html","permalink":"http://example.com/GAMES10102.html","excerpt":"前言 GAMES101-P2：回顾线代：向量、矩阵。","text":"前言 GAMES101-P2：回顾线代：向量、矩阵。 向量 向量： 向量的定义和性质 模与规一化( normalization )a^ = ∥a⃗ ∥a⃗\\hat a = \\frac{\\Vert \\vec a \\Vert}{\\vec a}a^ = a∥a ∥​ 向量相加：三角形法则 / 平行四边形法则、坐标 向量的矩阵形式 AT=(x,y)A^T=(x,y)AT=(x,y) 点乘 a⃗⋅b⃗=∥a⃗∥∥b⃗∥cosθ\\vec{a}\\cdot \\vec{b}=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert cos\\thetaa⋅b=∥a∥∥b∥cosθ。考虑矩阵形式。 投影、找夹角 两个向量方向接近的程度，是否基本同一个方向 叉乘 a×b=−b×a=∥a⃗∥∥b⃗∥sinθa\\times b=-b\\times a=\\Vert\\vec{a}\\Vert\\Vert\\vec{b}\\Vert sin\\thetaa×b=−b×a=∥a∥∥b∥sinθ 右手定则与右手坐标系。叉乘确定一个平面。不满足结合律。 判断向量的左右关系 判断点与三角形的内外关系：对每条边都在同一侧 矩阵 矩阵 基本运算：乘积 没有交换律。AB≠BAAB\\neq BAAB=BA 转置 TTT (AB)T=B−1A−1(AB)^T=B^{-1}A^{-1}(AB)T=B−1A−1 单位矩阵 III A−1A=IA^{-1}A=IA−1A=I 齐次坐标 跳转 Home:GAMES101-1：课程总览与笔记导航 Prev:GAMES101-1：课程总览与笔记导航 Next：GAMES101-3：变换","categories":[{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"}]},{"title":"VSCode 的设置系统的粗浅理解","slug":"VScode的设置系统","date":"2022-11-21T05:20:25.000Z","updated":"2024-04-20T18:58:06.463Z","comments":true,"path":"post/20221121132025.html","permalink":"http://example.com/post/20221121132025.html","excerpt":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却……","text":"试图调整 VS Code 的 C/C++ 编译默认设置，结果却…… 我需要一个默认的编译设置 众所周知，VSCode 的推荐或者说设计使用方法是对不同代码建立不同的工作区。这确实是对不同项目、不同语言的代码进行管理的优良方法。但是在学习的过程之中，不是所有情况都是非常理想的“我可以将所有的代码都井井有条的打在一个文件夹（工作区）中”的。学习中，QQ 上接收测试别人的代码、想临时测试某个功能是否如记忆一样等等情况，这样的代码，具有临时性或者独立性，我不希望将其和我固有的代码文件混淆在一起，又不希望记一个层层目录之下的草稿工作区分门别类。因此最理想的情况就是能在不打开特定工作区或文件夹的情况下对单个文件进行编译和调试。也就是一个全局的，或者说更通用的设置。 之前种种原因，对 VSCode 的设置理解停留在了一种一知半解的程度，借此机会，我希望能对此加深理解。 VSCode 中的设置的基本结构 优先级和工作区、文件夹 VSCode 的设置结构优先级由低到高是 “默认设置（不能更改）→ 用户设置 → 工作区设置 → 文件夹设置”。VSCode 会优先使用优先级高的设置，如果没有，就用优先级次高的设置。 知道写到这里我才注意到的一个事实是工作区（workspace）和文件夹（folder）是不一样的存在。我们可以认为一个“文件夹”是一个项目，一个工作区则是同类项目的集合点。例如所有的 Python 项目为一个工作区，而对其中的任意一个项目设置为单独的一个文件夹。Python 项目的共通性设置放于“工作区设置”中，而项目如果有特殊设置则放在“文件夹设置”里。 需要注意的是，如果只有一个文件夹，那么这个文件夹本身就是一个工作区。VSCode 会把这个文件夹设置显示为工作区设置，这也是为什么我会一开始没有发现这俩是不同概念的原因。 下面是工作区和文件夹在 VSCode 资源管理侧栏界面的对比，工作区会额外注明工作区二字。 设置文件的存储格式 所有这些设置，都是以 JSON 文件存储在电脑上的文件中的（尽管工作区文件不以.JSON结尾）。JSON（JavaScript Object Notation） 是一种独立于 语言的轻量级数据交换格式，采用键和值的格式存储数据。 而VSCode 的每一项设置都是一对键和值。 其中，用户设置位于 VSCode 的数据目录下( C 盘 appData 文件夹下)；工作区设置会是一个名为&#123;名字.code-workspace的文件（此文件不一定位于工作区文件夹内）；如果是文件夹，则会存储于文件夹下自动生成的.vscode文件夹下。 插件的设置 使用 VSCode 的时候，我们还会添加许多的插件，例如本文的初衷：在非工作区 / 文件夹环境下编译 C/C++ 程序就需要 MS 官方的 C/C++ 插件。这些插件的设置也会被写入到 Uersettings 文件中。因此，所有的插件和软件设置都是对同一个文件的内容的修改。既然目的是更改默认的编译软件，那么我们就是需要修改 Usersettings 文件即可.事情到这一步似乎离解决已经不远了。可是真的是这样吗？ 结论 在设置中，我们找到了下面两个设置。第一个的设置具体还不是很懂，第二个则没有发挥作用（图中值为自己填的）。 所以很遗憾，事情没有以完美解决落幕。依然要选择编译和调试器如图： 不过，至少我搞清楚了为什么这里会有三个选项，在官方文档中提到， The compilerPath search order is: First check for the Microsoft Visual C++ compiler Then look for g++ on Windows Subsystem for Linux (WSL) Then g++ for Mingw-w64. 因此，VSCode 会扫描到 mingw-w64 中的 cpp 和 g++ 两个程序，以及 VS 中带有的的 cl ，因此 VSCode 会有不知道用什么的疑问。但是 cl 被限制为只能在 VS 中使用，这也就导致了此选项实际上不能正常运行。目前的解决办法还得是选一遍，然后 VSCode 会在这一窗口中记住你的选择。 这一选项的原因可能是 VSCode 中的并没有选项能存储此默认设置，它会优先去寻找 launch.json,找不到时，则会发出此疑问。 还没有理解的问题 Q：既然 JSON 文件支持注释，那 JSON 和 JSONC（JSON with comments）有什么区别，为什么要创造 JSONC？VS Code 采用的是 JSON 还是 JSON with comments？","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"如何管理我的文章、笔记","slug":"如何管理我的文章、笔记","date":"2022-11-15T14:58:57.000Z","updated":"2024-04-20T18:58:06.468Z","comments":true,"path":"post/20221115225857.html","permalink":"http://example.com/post/20221115225857.html","excerpt":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。","text":"Pre：生活中总是免不了和各类文章、笔记、心得产生交到。有被动地学习，也有主动的思考产出。各类文字（下统称日志）的质量、功能、隐私性等等不一而足。这里，通过反思和整理，我将给出我的答案。 0.我的笔记环境 各类记笔记的软件繁多冗杂、不一而足，由上述两段可见一斑。而在经过两年多的跌打过后，我目前得出的教训是：有的就是好的，没有的就坏的。手上的工具再差，其已经配好了这一特点就胜出许多，因为这一点意味着当拥有想法的时候，你不会工具没有配好没发写而难受。 因此，做事的正确的顺序应该是先写起来，先用起来，习惯起来然后再酌情学习更换。否则就是配这个，踩一遍坑、配那个，踩一遍坑……到头来时间耽误不少，工具用了挺多，产出是一个没有，精通的也一个都没有……或者哪怕找到了趁手的武器，写文章的心境也早没了，只能任由心绪烂在心里。 下面简要介绍我的情况： 我是计算机类大学生，存在记笔记的需要，偶有写文章的冲动，但是依据过去进行判断的话，没有做日记或笔耕不辍的习惯。习惯于使用Markdown。 我目前使用的记录软件包括：小米笔记、Notion、VSC+MPE（就是这个博客）、Goodnotes、Notbility、Obsidian、备忘录（苹果）。 其他有所耳闻的应用还有各类在线博客平台（如CSDN、知乎专栏、掘金）、logseq、OneNote、typora等。 下面依次对我使用的工具的职责和功能进行介绍和明晰。 1.小米笔记：便捷的文字集散地 小米笔记用于我的 MIUI 手机上。其实功能不少，界面也很美观。既可以添加待办，也可以很方便的写一些短文字，还有思维笔记的功能。格式相似于 Markdown ，主要是荧光笔、触屏涂鸦和中/左对齐等功能，不过不支持 Markdown 语法。 显然这个就是主打轻量化的软件。由于手机一般就在身边，因此想到什么就马上开记，不要了就删掉是其最大的好处。 此外，小米笔记还有摘录功能，即复制后在侧滑功能栏里可以直接添加到笔记。或者也可以先侧滑打开摘录功能，然后接下来复制的多段文字均会在结束的时候被添加到同一个笔记中。 目前我对他的定位是做一个简单的快速记录软件、日记软件。将其分为了“垃圾话”、“灵感”和未分类三个部分。 “垃圾话”存储的是一些突然涌现的思绪，例如突然涌上心头的后悔、思念、思考、感悟……“灵感”则存一些更有价值的创造，比如说现在里面有的一篇小故事。我深知我无法将其扩写成一篇完美而精致的小说。但是我依然可以在小米笔记里把梗概存下来。至于未分类则就更是乱七八糟了，临时记录的东西。例如预备购买的手机的优缺点、给别人发一大段话前组织语言……这是笔记的默认分类。 至于隐私空间，则是一个简单的生活秘密空间。例如某个密码锁的密码，可以存在这里以防万一。从而使得应用本身并不需要上锁。 2.Notion：基于云端的长文字集散地 Notion 的好处很多，不过展开了说就有些长了，再说了我也没有完全摸透，大体上看是可以简单担任日历、待办、笔记、备忘录等等功能……（我甚至在拿它记账！）。总的来说，Notion 是极富有野心也极强大的的网络云笔记平台。支持类 Markdown 语法、按段落拖动等都是他的的优势。尽管如此，它也不是十全十美的。 其基于云端本身就意味着访问不稳定和隐私风险的等问题的存在。而且在国内特定的网络环境下，直接后果就是你需要开启代理，否则从一开始就不能登录，即使登录了，丢字、光标移动不稳定等问题依然会不时的困扰着人，这也是我尝试 Obsidian 和转移到 iPad 的原因之一。（另一原因是手写笔记的排版自由）。 尽管如此，一些具有多端阅读需求和多端编辑需求的文章还是可以放在 Notion 上。例如读书笔记或者单纯的笔记之类的。我曾经使用 Notion 作为课堂笔记过相当长一段时间。 3.Obsidian：移动端的 Markdown 基于移动端的 Markdown 写作平台，很可惜的是需要付费才能解锁多端同步的问题。因此，Obsidian 主要是作为小米笔记的 MarkDown 补全品出现。（文本迁移到 Notion 有格式转化的一大堆问题，不能作为 Notion 的补全品。但是可以作为 Notion 的替代品。具体来说就是一个小说的写作地。 4.Leeka的酒馆（VS Code）：成熟文章的集合 通过VS Code + MPE，可以进行较长篇幅的文章写作。同时，虽然没有人看，但是公开网站的性质也使得这里不适合放一些强隐私性的东西。这里主要堆积的是完成度高、成体系、长的文章。通过 Markdown 进行编辑可以使得我专注于内容本身。至于缺点则是虽然发布内容可以全平台浏览，但只能在电脑上进行编辑，而且会想折腾各种写作环境。目前来说，新建文章的方式也不够优雅。 5.Goodnotes &amp; Notebility：上课笔记、下课草稿（iPad） 目前的分工是 Goodnotes 记录课堂笔记，Notebility 负责一些更不正式、预备稿、涂鸦、灵感一类的东西。这里的一大原因是 Notebility采取了昂贵的订阅制，虽然可以白嫖朋友的 classic 版，但是说到底还是不适合与之深度绑定。 Goodnotes 等的缺点在于，除非导出为 PDF，否则不能在 iPad 以外的设备上进行查看，而且本身是手写用的。 6.备忘录（iPad） 备忘录的优势在于双击启动，虽然写起来不如 G 或者 N 爽，但是用来写一些用后即焚的东西（例如打草稿）还是有一定优势的。","categories":[{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"}],"tags":[{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"Take You Down ---至少不能让你受我连累","slug":"TakeYouDown","date":"2022-04-17T06:52:25.000Z","updated":"2024-04-20T18:58:06.460Z","comments":true,"path":"post/20220417145225.html","permalink":"http://example.com/post/20220417145225.html","excerpt":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？","text":"七年后，当 Nick 在发布他大热的第三张专辑《ASCEND》的时候，是否还会想起2012年吸毒过量后被抢救回来的那天？ 背景故事 《Take You Down》是收录于 ILLENIUM 的第三张录音室专辑《ASCEND》的一首歌。在《Take You Down》作为《Ascend》的先行曲发布时， Nick 在 YouTube 的介绍页写下了长长的一段话，告诉了粉丝自己过去和毒瘾战斗的艰辛过往，并感谢这一过程中音乐、母亲和其他爱他的人给他的激励。 如今，31岁的 Illenium 是全球最有名的 DJ 和电子音乐制作人之一，《ASCEND》曾登上得 Billboard 电子舞曲专辑的第一名的位置，而凭借第四专《Fallen Embers》，他赢得了一项格莱美音乐提名。而他则和家人、女朋友、朋友生活在美国丹佛。 以下是他在 Youtube 上写下的感悟： Yo Fam, I've been wanting to share something super personal for a while and just wasn't exactly sure how to do it. I'm at the point now where I've heard countless stories from you. Some of you have said my music changed your life, helped you through depression, addiction, a lost loved one, the list goes on. Honestly, I feel bad because you don't know how much that truly means to me, because I've been there too... In the depths. Six years ago I overdosed on heroin. I struggled with opiate addiction from a young age. I was trapped in it, had no passion, no direction, and truly hated myself. It was such a dark time for me and my family because when it gets bad enough, hope begins to dim and there's no escaping reality. I'm not telling you to preach or say how I found some magical cure or that everyone needs to live like I do. I'm the biggest advocate for people living their own lives and spreading their own love in their own ways. I'm just sharing my story and relating because music saved my life too. With everything that has been going on with my career, I always keep reminding myself of that. My main goal with music is to try and help people overcome their struggles and also enjoy the moment. With all that said , 'Take You Down' is about my struggles with addiction and what it can do to families and loved ones. It's more specifically about my mom, and how no matter what, she never gave up on me and always continued to see the good even though all I was doing was messing up. To anyone struggling like I did, not just with addiction but anything in life, I hope you guys can find peace in your struggles and know that anything can be overcome. I've been clean since that overdose and I owe that to finding my passion and being surrounded by the most loving people I could ever ask for. Thank you for always listening and being open. Thank you for sharing your own stories and your love of music with me. Love you all forever : ) 翻译 嗨，朋友们： 我一直想和你们分享一下一些完全私人的情感，但是却不知道该如何开口。眼下，我已从你们那儿听到了许许多多的故事。有的人告诉我，我的音乐改变了他的生活，帮助他渡过了诸如抑郁、药物成瘾、失恋……种种人生坎坷。老实说，我的感觉并不好，因为你们根本不知道这对我意味着什么：我也曾生活在那种糟糕境况中……深陷其中。 六年前，我遭遇吸食海洛因过量的事。我还很年轻的时候就和阿片药物成瘾对抗着。我踩进了毒品的圈套，生活没有热情、没有方向、自我厌恶。这对我和我的家庭都是一段非常黑暗的岁月，因为成瘾太深以后，就很难再回避事实了：戒毒的希望已经很渺茫。我不是要给你们讲大道理或者要说我找到了什么神奇的戒毒方法，又或者是要大谈什么你们都应该像我一样生活。我完全赞成每个人应该有自己生活和表达爱的方式。我只是想和你们分享一下我的相关遭遇，因为音乐也拯救了我的生命。当我的职业生涯日益发展，我也总是不断提醒着自己这一点。我做音乐的主要目标就是试着帮助人们克服遇到的困难，并享受当下。 总而言之，‘Take You Down’讲的是我和毒瘾的抗争以及这种抗争对我的家人和所爱的人的影响。尤其是我的母亲，无论发生了什么，她从未对我失去信心，总是以积极的一面看我——尽管我干的事就是把一切都搞砸了。对于那些像过去的我一样反抗着什么的人——不仅仅毒瘾，也包括人生中的其他种种问题——我希望你们能在反抗的过程中寻得心灵的栖身之所，而且能相信没有什么困难是克服不了的。自从那次吸毒过量以后，我再也没有碰过毒品。我也明白我得找回生命的激情并和那些我能寻求到的最有爱的人呆在一起。谢谢你们一直以来对我和我的音乐的支持。欢迎和我分享你的故事以及你对音乐的爱。永远爱你们 : ) 歌词翻译 I didn't mean to hurt you when I hurt myself 当我伤害自己，我无意连你一起伤害 It's just an empty voice screaming out for help 空洞又凄厉的哀叫只是 为寻求帮助 No, I didn't mean to scare you 不，我不曾想让你失措 But I couldn't see 但我不明了： That when I went to hell I was taking you with me 当我迈向深渊，我也在将你推入其中 When I close my eyes 而当我闭上眼… I'm climbing in the dark 就仿佛正在黑暗中攀登 Trying not to fall apart 竭力只求不要跌落 Sometimes I get so high 看到脚下的万丈深渊 Falling is the only out I see 坠落好似我唯一的出路 And I don't wanna take you down with me 而我不愿牵连你一同坠落 You're the love in my heart 只因我真心地爱你 Only love in my heart 你是我最爱的人 Take you down 坠下崖…… Take you down with me 与我一同坠崖 Don't wanna take you down 绝不愿你与我一同 Take you down 落入深渊 Take you down with me 落入痛苦的无底深渊 #Drop# This life is like a razor 这样的生活就如一把利刃 When it cuts, I bleed 令我伤痕累累 But it's in my hand 但这是我的抉择 And I'm doing it to me 是我在不断地伤害自己 Sometimes it's like an ocean 有时它又如一片幽邃的深渊 And it gets too deep 而我深没其中 And there's no way that now you could rescue me 如今你已没有办法拯救我 When I close my eyes 而当我闭上眼 I'm fighting in the dark 就仿佛正在黑暗中搏斗 Trying not to break your heart 竭力不要让你伤心 Sometimes I get so high 有时在我恍登极乐 Falling is the only out I see 堕落是我唯一可见的未来 And I don't wanna take you down with me 而我不愿你与我一同堕落 You need to let it go now 如今你该放下这一切 Before you drown 趁你尚未被牵连太深 I know that you won't understand 我知道你不会理解这些 But you need to let go of these hands 但啥时候放开拉着我的双手了 'Cause I'm going down 因为我无药可救 And I don't wanna take you down with me 可我不想牵连你一同饱受痛苦 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) #drop# And I don't wanna take you down with me 可我不愿牵连你一同跌入深渊 (You're the love in my heart) (因为你是我深爱的人啊) (Only love in my heart) (我最爱的人啊) Take you down, down with me 怎愿致你痛苦，和我一样痛苦","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"}]},{"title":"用批处理简化hexo命令操作","slug":"用批处理简化hexo命令操作","date":"2022-03-23T16:19:24.000Z","updated":"2024-04-20T18:58:06.477Z","comments":true,"path":"post/20220324001924.html","permalink":"http://example.com/post/20220324001924.html","excerpt":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？","text":"使用 git bash 新建博文过于繁琐，有没有更简单无脑的办法？ 背景 搭建好博客网站后，之所以长时间没有更新，当然是因为本人懒狗，不过除此之外，hexo 糟糕的新建博文方法也是一大原因。 有两种方法可以新建一篇博文： 在博客的本地地址建立一个新的 Markdown 文件，然后依次修改它的各部分内容。 在博客的本地地址右键选择 git bash，然后输入命令进行操作。 第一个简单，但是糟糕的地方是头部信并不是自动生成的，需要从老博文里面复制。麻烦不说，时间戳不是自动生成的、混用 _drafts 和_posts 也总让我感觉有些难受。 第二个能自动生成头部信息，但是需要输入命令然后再关掉窗口打开编辑器，实际上也很麻烦。 但是，既然每次输入的命令都是类似的，这就自然让人想到能不能用例如 bat 批处理脚本来自动化这个过程。 答案是可以的， bat 脚本事实上就是一连串的命令。在 bat 文件中写 hexo help 和 新建一个 cmd 黑窗口输入 hexo help 没有任何差别。 使用批处理以后，可以从重复而繁琐的命令中解放时间，更好的专注于写作本身、也可以让草稿和博文真正的很清楚（而我还没有搞清楚hexo的开发者的初始设想到底是如何使用？想必不是让用户自己写批处理XD) 下面是脚本代码 实现 新建博文草稿并用编辑器打开 newDraft.bat 12345678@echo off@REM 跳转到博客地址D:cd D:\\***\\***@REM 输入文件名set /p name= input Name: @REM 新建文件、唤起第二个脚本hexo new draft %name% &amp;&amp; call openEditor.bat %name% openEditor.bat 1234echo the input is %1set name=%1echo %name%start /d &quot;C:\\***\\***\\VSCode的安装地址\\&quot; Code.exe &quot;D:\\博客的本地地址\\source\\_drafts\\%name%.md&quot; 这里，第一个脚本建立草稿文件，并唤起第二个脚本用编辑器（这里是VS Code）打开新建的 Markdown 文件。为什么不能写成一个文件这里我还不是非常清楚，似乎bat文件会在运行到 hexo ***后自动结束导致后面的命令运行不了。 发布（Publish）文章 publish.bat 123@echo offset /p publishBlog=hexo publish %publishBlog% 此脚本将指定名字的 blog 发布到 _post 文件夹中。 上传到博客网站 deploy.bat 1234start clean.batstart /min /w mshta vbscript:setTimeout(&quot;window.close()&quot;,2000)start generateAndDeploy.batexit 分别调用clean和generateAndDeploy，清理缓存、生成并部署。 clean.bat 123@echo offhexo cleanexit generateAndDeploy.bat 12hexo g -dexit 总结 有效激发了本人的写作热情，写好脚本以后当场写（水）了这篇博文。 算是对 bat 有了一点粗浅的认识，当然还有搞不懂的地方，例如为什么运行到hexo ***以后就退出了呢？还是需要以后再看，今天鉴于时间因素，还是就此暂停了。 自己用命令测试的时候请记住要用 CMD 运行！powershell的话你大概会遇到因为在此系统上禁止运行脚本的错误,这里是可能的参考解决方法。 这篇文章是向CSDN上“蓝蓝223”的这篇文章:《bat批处理脚本自动部署Hexo博客》学习后的成果。我对代码进行了一点无关痛痒的小改动。 代码块在MPE上预览要敲 batch 才有高亮，但是要生成的网页有中有高亮得敲 dos…… 我不理解orz","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"批处理脚本","slug":"批处理脚本","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"}]},{"title":"Heavenly Side ---我愿与你逃向天国","slug":"歌词翻译/Heavenly Side个人翻译","date":"2022-02-14T15:59:59.000Z","updated":"2024-04-20T18:58:06.475Z","comments":true,"path":"post/20220214235959.html","permalink":"http://example.com/post/20220214235959.html","excerpt":"前言 Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。","text":"前言 Heavenly Side 是收录于ILLENIUM的第四张专辑的一首歌。虽然之前吐槽水啊水之类的，但是没想到这首歌比feat Nurko的Sideways让我上头多了。虽然网易云音乐的翻译也未必没有可取之处，但是个人感觉还是略显谜语人和机翻，在“没有人比我更懂歌词内涵”的思想下，写了这个翻译。由于写的时候考虑到能否唱出来而硬拗了一些词，不足之处欢迎指正。 翻译 《Heavenly Side》 -ILLENIUM -《Fallen Embers》 I've got an anger problem 我总是喜怒无常 I've got a selfish need 还变得自私自利 I like to burn my focus 我在琐事中忙碌 Just to watch my true colors bleed 只为将真我遗弃 I've got a taste for failure 我已饱尝失败的滋味 I find it in everything 生活中处处碰壁 But I hear the voice inside you 但我却听到你内心的声音 Say I could be more than need 告诉我存在的意义 You can't let go if you want to 若愿意你可永不放手 'Cause I love you all the same 只因我的爱永不改变 It's a long way down from here（Oh, Oh, Oh, Oh ） 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我美好的一面随时为你展现 And I killed myself last year(Oh, oh, oh, oh) 与过去的我一刀两断 My heavenly side is comin' alive if you want me（Oh, Oh, Oh, Oh ） 只要你愿意我温柔的一面随时为你展现 If you want me 只要你愿意 I know that I'm the problem 我知道我就是麻烦所在 I know that I'm to blame 我知道我应该饱受谴责 But I hear the heart inside you 但我也听到你内心的声音 And it's calling out my name 正呼唤着我的名字 You can't let go if you want to 若愿意你可永不放手 'Cause I love you all the same 因为我的爱永不改变 It's a long way down from here 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me 若你愿意我美好的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin' alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意 It's a long way down from here 此后还有漫漫长路要走 My heavenly side is comin' alive if you want me 只要你愿意我天使的一面随时为你展现 And I killed myself last year 与过去的我一刀两断 My heavenly side is comin' alive if you want me 只要你愿意我恶魔的一面将会永埋心中 Don't you let go 不要放手 I found my soul 是你将我挽救 Don't you let go 不要放手 I found my soul 灵魂怎可弄丢 My heavenly side is comin' alive if you want me 只要你愿意我美好的一面随时为你展现 If you want me 只要你愿意","categories":[{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"}],"tags":[{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"}]},{"title":"天国王朝语摘","slug":"天国王朝","date":"2022-01-15T06:13:35.000Z","updated":"2024-04-20T18:58:06.467Z","comments":true,"path":"post/20220115141335.html","permalink":"http://example.com/post/20220115141335.html","excerpt":"天国王朝语摘，自翻与所看版本的翻译","text":"天国王朝语摘，自翻与所看版本的翻译 What man is a man who does not make the world better ? trans：大丈夫生于世当造福苍生 Be without fear in the face of your enemies; Be brave and upright that God may love thee; Speak the truth always, even if it leads to your death; Safeguard the helpless and no wrong; that is your oath. trans（LEEKA）： 临敌不惧 神佑勇义 护良扶弱 纵死不诳 这就是你的册封誓言 trans： 强敌当前 无畏不惧 果敢忠义 无愧上帝 耿直正言 宁死不诳 保护弱者 无怪天理 这是你的誓词","categories":[{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"}],"tags":[{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98/"},{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"}]},{"title":"VSCode 中自定义代码模板（snippet）","slug":"VS code中建立代码模板","date":"2022-01-05T14:01:55.000Z","updated":"2024-04-20T18:58:06.462Z","comments":true,"path":"post/20220105220155.html","permalink":"http://example.com/post/20220105220155.html","excerpt":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。","text":"这个功能在VS code 中被叫做片段（snippet），其功能是在输入用户定义好的触发词后，可以像代码补全一样补出一段代码。 具体操作倒也不难，如下： 1.打开VS code，选择文件 =&gt; 首选项 =&gt; 用户片段 =&gt;选择对应的语言 在弹出的以下窗口中选择对应的语言、文件夹或全局，则，仅会在该语言环境、该文件夹抑或全局触发补全该代码片段。此处我以C++为例了。 2.输入代码 在弹出的窗口中，你能看到已经有数行注释如下 12345678910111213// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:// $1, $2 for tab stops, $0 for the final cursor position, and $&#123;1:label&#125;, $&#123;2:another&#125; for placeholders. Placeholders with the // same ids are connected.// Example:// &quot;Print to console&quot;: &#123;// &quot;prefix&quot;: &quot;log&quot;,// &quot;body&quot;: [// &quot;console.log(&#x27;$1&#x27;);&quot;,// &quot;$2&quot;// ],// &quot;description&quot;: &quot;Log output to console&quot;// &#125; 事实上这段英语教程已经说得比较清楚，但是作为英语苦手，还是有一定的理解苦难，这就是这篇博文诞生的原因。下做翻译补充： 每一个“代码片段”都应该由如下三部分构成，前缀（prefix）、主干和描述。 前缀是代码片段的触发器，当你在编辑代码时输入前缀（的部分），VS code 就会联想到你的对应代码片段； 主干是被补全的内容，也就是“模板”部分。你应该把代码分行写在 body 的中括号内，并把它们用双引号包括起来，同时在引号外别忘了添加逗号。即 1&quot;your code here;&quot;, 描述被用来描述代码片段的作用，当你有多个相近名字的代码片段时，这无疑有助于你区分它们。此外，这部分也允许你输入中文，或干脆不写（尽管不建议）。 需要额外注意的是最后提到的由 $ 开头的这个小功能。 它的写法是 $加一个数字或在 $ 后的大括号内依次写入”数字”“冒号”和“占位字符串”。如 123$0$&#123;1&#125;$&#123;1:spaceholder&#125; 在补全代码后，你的光标会首先停在数值最小的一个 $ 字符处，随后每次按 Tab 依次停在次小的 $ 处，最后停在代码片段的末尾或你指定的 $0 处。（尽管测试下来允许数字不连贯，但是我建议还是使用连贯的从1开始的数字比较好）。如果有多个相同数字的地方，那么光标会同时存在于这些地方。 在上方 spaceholder 部分，你可以填入默认的代码，它们在会光标（按 Tab 转移到此处时被选中以备替换）。 3. 实例 接下啦，仿照给出的 Example 在下方输入你的代码即可。 123456789101112131415161718192021222324252627&#123;//这个括号是默认生成的 &quot;Print to sample&quot;://sample字段可被替换，还没找到其意义 &#123; &quot;prefix&quot;: &quot;test&quot;,//触发词 &quot;body&quot;: [ &quot;#include &lt;iostream&gt;&quot;, &quot;#include &lt;cstdio&gt;&quot;, &quot;&quot;,//这是一个空行 &quot;using namespace std;&quot;, &quot;int $&#123;1:i&#125;;&quot;, &quot;$0&quot;, &quot;&quot;, &quot;int main()&quot;, &quot;&#123;&quot;, &quot; scanf(\\&quot;%d\\&quot;, &amp;$1);&quot;,//在上方写了占位符后，这里可以只写一个数字 &quot; return 0;&quot;, &quot;&#125;&quot;, ], &quot;description&quot;: &quot;一般性简单cpp模板&quot; &#125;,//逗号在有多个片段的时候有意义 &quot;Print to another_sample&quot;: &#123; ... &#125;&#125; @import &quot;D:\\Users\\uftx\\Documents\\hexo\\source_posts\\avatar.jpg&quot;","categories":[{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"}],"tags":[{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"}]},{"title":"中国游戏产业现状————思政课堂演讲稿","slug":"中国游戏产业反思","date":"2021-10-26T09:40:33.000Z","updated":"2024-04-20T18:58:06.464Z","comments":true,"path":"post/20211026174033.html","permalink":"http://example.com/post/20211026174033.html","excerpt":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿","text":"2021年，关于“如何看待当今游戏产业”在国庆期间所作演讲稿 谈谈中国游戏产业的监管和未来 中国的电子游戏产业是怎样的？ 中国的电子游戏产业为什么是这样的？ 中国的电子游戏产业在往哪个方向发展？ 我们如何看待它？我们能明白什么？我们如何改进它？ 注意： 如无特殊说明，主流游戏指代的是当今世界上的主流游戏形式，即以主机为、PC为主要发行渠道的各类大型电子游戏。 如无特别说明，游戏指的是在主机，PC，掌机，手机等各类平台运行的电子游戏。 中国的电子游戏产业是怎样的？ 中国游戏产业发达 我们有丰富的证据说明中国游戏市场的发达： 中国目前已经成为世界上最大的游戏市场，游戏用户高达6.6亿，实际销售收入两千七百多亿。是世界第一大游戏市场，有超过1/4的游戏用户都在中国。 中国腾讯是世界第二赚钱的游戏公司（2020），王者荣耀、英雄联盟、穿越火线、刺激战场都是堪称全民级游戏。 中国是电竞大国，数度在英雄联盟、DOTA2等领域捧回冠军。例如2018年，现象级的IG夺冠事件（英雄联盟S10），又如，已经成功举办9九届的Dota 2Ti赛事中，中国除2013年 Ti 3外，始终占据前三之一，在2012、2014、2016年更是夺得世界冠军。 中国游戏产业艺术属性、文化属性缺失 但是，中国游戏业的发达之下，掩盖的问题是，中国游戏缺乏艺术性，难以做出让中国人叫号的游戏；缺乏文化属性，难以做到对外输出中国影响。 自从《征途》之后，国内主流的游戏类型成了基于电脑的网络游戏，而大约十年前，国内主流又变成了手机游戏。以至于有些不太关心游戏的人甚至觉得现在没人玩电脑游戏了。 这并不是说网络游戏、手机游戏低人一等，相反，从商业的角度来说，它们是更先进、更发达的形式。但是我们也需要指出，只点“网络游戏”、“移动游戏”的科技树的后果是，国产游戏并没有完全发挥游戏作为文娱产品其艺术一面的功效。 这是因为，从本质上来是，单机游戏和网络游戏是两个不一样的东西。前者卖的是产品，后者卖的是服务。单机游戏作为产品，它在内容体验上是完整的、大致固定的。而网络游戏作为服务，为了让用户持续的玩下去，体验是不完整的、持续时间是不定的。而且，这意味着，如果我们想用游戏来阐述一个富有魅力、打动玩家的故事较为困难。 而且，由于网游是提供服务，吸引玩家充钱，而不是做出好玩的游戏然后吸引玩家交钱。因此网游的重心必然是在吸引充钱上，这也无形中降低了对剧情等内容的重视程度。 尽管有王者荣耀里有对历史原型人物的科普等相对正面的例子，但是整体上我们的游戏业并没有把弘扬中国文化这一块做好。例如，许多外国人对中国三国文化的认识来自于日本的《三国志》等游戏，对内，反映我国群众思想、喜好、生活的游戏也并不多见。 中国游戏长期与社会割裂 由于中国长期以来以PC和移动端为主的网络游戏占市场主流，加上社会对电子游戏存在的较大偏见，导致了社会认知中的游戏和实际上的游戏业是割裂的，带偏见的。 例如，许多人觉得现在没有什么电脑游戏了。 有的人觉得，玩游戏还要买简直不可理喻。 有人觉得游戏就是“电子鸦片”、洪水猛兽。 针对近期新闻出版署公布的未成年防沉迷规定，玩家们就改出了许多不同的梗图以作对“家长”们的嘲讽【此处应有图】 种种和实情相去甚远的偏见不仅使得游戏业的发展受到来自社会舆论方面的较大阻力，也使得监管层迫于舆论压力对行业动手。 中国的电子游戏市场为什么是这样的？ 这个问题可以谈很长， 我们可以批评中国不像美日有深厚的桌游史，因此没有继承游戏文化，才导致畸形发展。 可以批评是血狮为代表的发行商们寒了中国玩家的心，让投资者和玩家都不愿意购买中国单机游戏， 可以批评是以史玉柱的征途为代表的一系列强氪金网游压死了中国游戏商。 可以批评中国家长，他们总是“以孩子玩了怎么办”阻碍中国游戏脱离幼稚的主题和画风。 但是，我们认为中国游戏监管是中国游戏业成为当今形态的主要原因。（请注意，这并不是说监管是唯一原因，也不是说监管方是一切问题的根源） 下面，由三个重要政策的颁布浅窥监管对游戏业的影响。 游戏机禁令： 70年代，雅达利制造出世界上最早的游戏机，电子游戏产业逐渐萌芽。90年代，乘着改革开放的东风，游戏机和游戏文化传入了中国。由于当时政府管制不到位，大量企业依靠山寨外国游戏机（小霸王），盗版或仿制外国游戏起家。在对企业监管都不到位的环境里，对个人的监管就更不可能到位了。在当时，黑网吧、黑街机厅等遍地。不可否认的是，在这类场所，人员往来成分混杂，争吵斗殴不时发生。 2000年，光明日报两度刊文分别以《别让游戏机害了一代人—一位母亲的呼吁》和《观点：电脑游戏是瞄准孩子的“电子海洛因”》批评（黑）游戏机（厅）。文章认为，游戏机是毒害青少年的”电子海洛因“，不仅容易上瘾，而且会诱导逃学、夜不归宿、甚至抢劫等不良行为。这引起了孩子被游戏厅毒害的父母的共鸣，社会上引起轩然大波。六月，国家七部门联合发布《关于开展电子游戏经营场所专项治理的意见》（俗称游戏机禁令）。尽管该意见的对象是街机游戏机（而不是家用机），但是在具体的实行过程中，最终演变成了所有游戏机。 家用机（俗称游戏主机）在中国正规市场的消失，无疑是造成了主机游戏在中国的绝迹的直接原因。而世界的主流游戏形式依然是主机平台为主的。换言之，中国的玩家从此很难玩到大部分国外优质游戏，中国游戏开发商也几乎不会进行主机游戏开发。 这就导致了中国转向以PC和手机等非完全游戏设备上的游戏开发（由于有非游戏需求，不能被禁止）。而PC平台的开放性引发的盗版传播潮，又使得中国的游戏形式转为是以免费内购制联网游戏为主。 这一转向，使得付费单机游戏被中国彻底抛弃。中国单机游戏市场萎靡不振，与百花齐放的国外游戏市场形成鲜明对比。 如今，电子竞技在国内引发热议，不仅受众甚多，国际赛绩不俗，而且电竞专业、电竞酒店、电竞馆、电竞电视剧各类衍生品也层出不穷。某种程度上，也正是游戏机禁令的衍生物。 游戏版号制度 2004年，文化部建立网络游戏内容审查制度，在新华网的一篇采访中提到，审查的目的因为 一是网络游戏产品中存在色情、暴力、赌博、愚昧、迷信以及危害国家安全等不健康内容； 二是未经内容审查的境外网络游戏产品充斥我国网络游戏市场，市场绝大部分为境外产品，大约占８０％以上； 三是容易影响缺乏自制力的未成年人的身心健康，有的深陷其中、不能自拔并诱发一系列社会问题。 而违规内容简单的概括，有：反国辱国、违背社会公德、邪教、谣言、宣扬色情赌博暴力等。 这些规定有问题吗？似乎没有。但是，版号下发数量稀少，具体过审规则暧昧，尤其是在前几年下发还不是依据申报前后、不分企业大小排队的情况下。版号制度事实上极大的打击了中国中小游戏开发商。他们很难拿到版号，即使拿到版号，为了过审，也不得不大量删改内容。 这一制度，给有心做出中国好游戏的中小型开发商又套上一层枷锁，磨灭了独立游戏在国内存在的土壤，加剧了市场中马太效应的作用。 同时，由于文化讨论更容易触犯规则，一个版号吃多年的网络游戏比几年一换的单机游戏申报成本更低，游戏商们也更不愿意做剧情、做价值输出内容。更不凸显网络游戏作为文化产品，其文化和艺术性一面的作用。游戏们变得剧情上乏味而空洞。 最糟糕的是，缺乏正规渠道接触优秀电子游戏使得孩子们认识游戏的渠道极容易出问题——而这又恰恰很有可能导致孩子成绩下滑暴力等问题，因为一些国外认定18+甚至的血腥暴力以及色情游戏可以在国内轻易获取。 最近的精神鸦片事件 在2017年PUBG的大热，曾经以CS而为人熟知的Steam平台再次进入大众眼线。 Steam是美国Valve公司开发的游戏平台，由于并非中国企业，在Steam上架游戏并没有版号要求，因此在意识到steam上有广阔的国内和国际市场后，许多独立游戏开发者开始将尝试把自己的游戏上架Steam。于是，我们惊奇地发现，中国游戏产业并非烂泥扶不上墙，并不是没有做出好游戏的能力。 没有雄厚技术和资金的国内独立开发者们做出了包括《中国式家长》、《太吾绘卷》、《戴森球计划》、《烟火》、《暗影火炬城》等题材不同、玩法不同的好游戏，他们中的不少都曾经打入steam周销量榜前十（全球），引起国内外玩家热议，而《动物派对》登陆2021年（全球最大游戏展之一的）E3游戏展微软展台，《黑神话：悟空》得到了几乎整个中国游戏圈子的追捧，更是引来国外众多游戏开发者与玩家的热议…… 不止如此，就在今年七月末公布的《2021-2022年度国家文化出口重点企业和重点项目名单》中，不仅有58家游戏公司在列，还有包括《明日方舟》、《原神》、《贪吃蛇大作战》、《波西亚时光》等八款游戏。 这些在海内外都有巨大反响的游戏，证明了中国开发者完全有能力做出优秀的游戏。然而… 就在公布上述名单后不久，央媒经济参考报发文《“精神鸦片”竟长成数千亿产业》短短四个小时内，腾讯股价下跌约9%，心动网络下跌约13%，网易下跌约15%，中手游下跌约20%……各大厂商累计蒸发市值约三千亿。 尽管四个小时后，这篇被炮轰“来自二十年前”的文章就遭到删除。但是腾讯当天依然迅速推出双减双打政策进一步限制未成年人游玩。后面的事情大家都知道，30号，国家新闻出版署出台政策将未成年人的游玩时间杀到每周三个小时。而八月开始，八、九、十三个月游戏版号无原因的停发了。而上一次（2018年）大半年的停发，仅腾讯市值蒸发1500亿美元，最低时，仅有停发前的约六成。 当今游戏监管的不确定性和对游戏市场的影响力可见一斑。 如何看待中国游戏产业？ （当下：）游戏已经成为年青人的生活方式 在2020年，中国已经超越美国，成为世界第一游戏产品消费国，其中主力是18-22岁的青年人。不少人以前不玩游戏，但是却被身边的人带入了王者荣耀全民电竞“坑”，又或者开始了解原神是怎么回事。在游戏平台steam上，中国已经成为最大的购买来源群体。越来越多的外国游戏开始将中文、尤其是简体中文作为游戏标配，甚至有独立游戏开发者抱怨因为没有成本进行中国的本地化工作导致游戏遭到差评轰炸等问题。 而各类游戏的新闻在社交媒体上也都相当有话题度和二创活力。游戏内的一些术语例如白嫖、氪金、肝帝、开黑、PK、欧皇等词汇也早就超出游戏范畴，成为日常生活的一部分。 不仅如此，通过二创和衍生周边等，游戏还带动了网络文学、动漫、电影、电视剧、广告、电竞、网络直播和VR等产业的发展。 而在开发者一侧，越来越多的人开始对游戏制作感兴趣。各类小型团队活跃在taptap、steam等游戏平台上。甚至也不乏游戏科学这样从腾讯离职创业的团队。他们今年八月末的视频，截至10月12日依然有100多人看，斩获两千多万的播放量（仅B站）。 从这个角度来看，游戏产业和青年人联系紧密，是一个极其活跃的群体。 （未来：）游戏产业正期待变革 首先，我们需要指出的是，尽管我们前面写了许多监管的不好。但这绝不意味着游戏业是不需要监管的。游戏业是一种文化产业。无论中外、无论古今，都必须受到监管。这才是对游戏及其他任何文化产品负责任的做法。 而正如刚刚我们所说，游戏产业是一个广受当代青年、少年、孩子喜爱的的产业。无论我们承不承认游戏是所谓第九艺术，游戏作为一种新兴的、与国家未来们密切相关的行业，都需在正确的、合理的监管下健康发展。而这正是我们目前所缺乏的。 一方面，历史上的错误决策导致了如今腾讯网易形成垄断，在缺乏竞争的市场环境下，它们缺乏创新动力。大厂没有创新意愿等问题，进一步的就导致国内游戏业人才凋零、技术落后，削弱国产游戏竞争力。 另一方面，如今又一次趋严、趋保守的监管，对游戏业过于严苛，不仅甚至有可能抹杀现有的游戏出海热等繁荣状态，而且政策上的消极，也会加重社会上部分媒体、家长对游戏本就存在的偏见，使得“电子海洛因”的形象更深入人心。 作为一个庞大而年轻的产业，游戏业的发展离不开监管层对审核标准的进一步放开。越来越开放的的中国、日益热闹的游戏开发行业和广大的游戏玩家们，也呼唤着更规范而开放的监管层的出现。 而监管层呢，近年来也在有意放松，例如，2015年，游戏机禁令取消，我们能在正规渠道买到游戏机了。2020年，游戏适龄提示上线，有了些游戏分级的影子，甚至新闻出版署的未成年游玩限制新规出台，玩家们都疯传这样一种说法：新规意在堵住觉得游戏是坏东西的部分家长一口。而对于家长更开明的那些孩子而言，家长并不会介意帮助实名，因此不会受到影响。【此处需要图】 因此我们有理由相信，游戏产业监管正需要且正迎来一场变革，游戏监管一定会更加合理。使得游戏产业不仅有机会成为拉动经济增长的新力量，也成为我国文化输出的一大亮点。 （过去：）游戏（的监管史）是代际隔阂的当代写照 任何在我出生时已经有的科技都是稀松平常的世界本来秩序的一部分。任何在我15-35岁之间诞生的科技都是将会改变世界的革命性产物。任何在我35岁之后诞生的科技都是违反自然规律要遭天谴的。 以《银河系漫游指南》闻名的科幻小说作家道格拉斯·亚当斯曾经写下上述这个著名的“科技三定律”。这虽然夸大而滑稽，却深刻反映了许多问题，例如，世风日下、人心不古这两个词语是怎么来的。例如，为什么金庸的武侠小说从孩子们偷着看变成了老师的推荐数目，周杰伦从“话都念不清楚”的差劲流行歌手变成了当代流行音乐天王。 有个网民【未知】曾经辛辣的讽刺： 我们不需要知道电子游戏是什么，它会不会造成近视，它会不会上瘾, 我们只需要一个背锅侠，一个可以掩盖家庭教育失败、 学校教育失败、社会教育失败的东西， 现在它叫游戏， 十五年前它是早恋, 三十年前它是偶像, 三十五年前它是香港电影， 四十年前它是武侠小说 这指出了部分家长的甩锅心理，但是我们要说的，他们之所以甩锅给游戏，正是因为他们带着偏见的眼光中，游戏是不好的。当代游戏产业的许多不合理之处，我们骂莫名其妙的监管、贪婪无度的游戏公司、骂不明事理的熊娃家长……说到底，就是在骂那些觉得游戏是“违反自然遭天谴的”，骂那些觉得自己不懂的产业就带着原罪的人。试想：如果监管者觉得游戏是大毒草，游戏的审核又怎么能公平合理呢？如果游戏公司老板觉得游戏就是一个捞快钱的地方，我们的游戏又怎么可能会吸引到玩家的注意力呢？如果家长觉得游戏是电子海洛因，又怎么可能在孩子成绩下降后不怪罪呢？ 如果我们今天只谈游戏产业受到了歧视和偏见，也许有朝一日随着玩游戏的一代人长大，游戏不会再被污名化，但是却会有其他产业被污名化。(例如短视频?）。从这个角度来看，游戏产业不过是当代文化产业快速发展大格局下，被推出来背“世风日下”这口大锅的那个。这是游戏产业的悲哀，也是每一个新兴文化的悲哀。 当然，正如我们也能看到一些开明的家长，一些孩子高三了家长帮忙上号代打的新闻等等，所谓“科技三定律”其实并非“定”律。这是可以改变的。一方面，做为玩游戏的青年人，我们有义务为游戏（和其他的新媒体、新文化）正名，为之发声，让更多家长辈的人明白、理解，游戏其实并不特殊，它不过是当代的一种新娱乐方式而已。另一方面，作为反思，我们是不是也在不知不觉中犯了类似的错误呢？生为00后的我们，对10后的娱乐是否又认真了解过，而不是简简单单的一句“哼，小孩子玩的”带过呢？ 愿我们都能多一些理解，少一些理所当然和“世风日下、人心不古”。 【报告结束】","categories":[{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"}]},{"title":"古埃及旅游指南 || 三、古埃及的一些事物与文化","slug":"古埃及旅游指南：文化篇","date":"2021-01-18T11:17:30.000Z","updated":"2024-04-20T18:58:06.465Z","comments":true,"path":"post/20210118191730.html","permalink":"http://example.com/post/20210118191730.html","excerpt":"提要 ~~这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。~~这里目前是一个草稿","text":"提要 ~~这是一篇对神话篇、历史篇未涉及但是又有趣的一些内容补充，请注意你必须要先对历史、神话篇加以了解以免出现理解上的困难。~~这里目前是一个草稿 古埃及的墓穴和葬仪 在古埃及对国王和大多数社会阶层而言，在思想上进行统治的一个非常重要的方面就是丧葬祭仪。不朽的陵墓建筑和丧葬祭仪象征着国家和统治机构。有些坟墓周围埋有陪葬者。例如埃及第一王朝第三任国王哲尔，他的墓穴周围有300多个陪葬者，这也是埃及历史上唯一用活人陪葬的时期。第二王朝的国王不再采用这种仪式。 木乃伊 木乃伊虽然不是古埃及的专利，但是古埃及的木乃伊无疑是最有名的。埃及神话相信死者会再次苏生，所以想方设法的保护死者的躯体也就成了一件重要的事。 不仅是法老，一般人的死也会经历木乃伊化的过程，尽管不同年代、不同阶层有很多区别，但是粗略来说，古埃及人会把死者的内脏等清理干净、涂上油防腐、还要裹上亚麻布。然后和其他的陪葬品一同安葬。 木乃伊也不是人的专属，很多的动物，尤其是猫，不仅是神圣的女神巴斯特的象征，还能抓耗子保护谷物，还可爱。 也经常被做成猫乃伊。 石棺铭文 虽然君主的权威在不断增强，但古王国末期和第一中间期的混乱局面大大削弱了王权在人们心中的地位。王权不再像过去那么神圣，在宗教上的权威地位也大打折扣。从人们去往来生世界的某种更为民主化的形式，可以明显的看出这一点。包含在金字塔铭文中的咒语经文，不再是国王和王后所独享的特权，而是只要买得起，任何人都可以将其刻在棺柩上。这就是我们所说的“石棺铭文”。中王国时期，铭文的数量激增，为我们提供了比古王国更多更直接的历史资料。这一时期的语言成了古埃及时期的标准经典语言，即中古埃及语。预言书，道德故事，赞美诗等叙事体文学作品大放异彩，成为中王国时期重要的文化成就之一。这些作品中最著名的是《西努赫流亡记》和《遇难水手的故事》，在中王朝结束很久之后，这两个故事仍然为人们所传播 古埃及丧葬习俗（英文）： https://en.wikipedia.org/wiki/Ancient_Egyptian_funerary_practices 医药 如果单就文字的运用而言，有许多时候和一般所谓的文学不同的实用性文字，埃及人的实用性格在这类文献中有清楚的表现。首先是医药方面的作品，用现代的概念来说，有属于医理方面的手册，包括对疾病的判断，或者治疗疾病的方法，也有属于药方之类的作品，虽然其中有时不免有巫术之类的手段。在一卷有关外科手术的文献中，我们可以看到以下记载：若你检查一个头部受伤者，伤势深入头骨，但并没有伤口，你应该轻触他的伤处。如果你发觉他的头骨没有受损，没有穿洞，没有裂痕或破碎，你应该对他做如下的诊断：“此人头上有伤，伤口没有裂开，虽然伤势深入头骨。这个伤我可以治。”你应该在第一天时将伤处用新鲜的肉敷住，而后每天施以油脂，蜂蜜，绷带，直到他康复。在古代世界中，埃及的医学的确是相当著名，许多希腊时代的作品都提到埃及医学和药物对他们的影响。而埃及人制作木乃伊的习俗也很可能与埃及医学中外科医学的发达有某种关系。 数学和几何 埃及人在建造金字塔和神庙这类的建筑活动中显然必须依靠相当精确u的数学计算，否则不可能成功。不过埃及的数学基本是从实用着眼，只求能够解决实际的问题，而没有理论上的兴趣。我们目前有关埃及数学的了解主要来自中王国时代的两份草纸文书，以及一些较晚而零散文献。基本上，埃及数学以十进位，而他们只用单位分数，如1/2,1/3,1/4等等，唯2/3例外。因而3/4是以1/2加1/4来表示。而数学的基本运算是以加法和倍数为基础，例如13乘以17，埃及人的写法是： ![img](file:///C:/Users/uftx/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg) 答案是将左边取1+4+8=13，右边相应地取17+68+136=221，结果为13*17=221。除法也用相似的方法，只是倒过来。至于几何学，埃及人的水平也大致限于简单的面积和体积的计算，但显然这些已足够让埃及人得到实用的数据。 法老的胡须 毛发是容易藏污纳垢的地方，所以爱干净的古埃及人就想了聪明的办法：把原来的毛发剃掉，然后戴上假发和假胡须。就能美观又干净了【如下图】 一个小细节是，法老在世时的胡须是直的，逝去的法老的胡子则和神的一样是弯的。这是因为法老去世是被认为回归神明之列。 参考 古埃及练习曲，头发与假发（上），（繁体字） 知乎，法老的胡子有什么特殊的含义吗？ 努比亚人 努比亚人是埃及人的南方邻居，和埃及关系密切。埃及第25王朝就是努比亚人的王朝。而八爷担任的职务：守护者，职责最初就来自努比亚人的文化。 芦苇（莎草）、芦苇船、莎草纸 在埃及的绿洲边，常常能发现一种高大的草，这就是莎（suo）草，也被称做芦苇。（尽管生物学上来说芦苇和莎草是不同的）。有芦苇，就有水，有绿洲和肥沃的土地。因此古埃及人特别喜爱芦苇。 他们不仅用它做出了莎草纸、芦苇船，用芦苇的根茎作为神的贡品，对于死后天堂的描述也是一片长满芦苇肥沃的土地——芦苇原。 莎草纸，也许是世界上最早的一类纸，古埃及人从公元前3000年开始就用这种纸书写（这个时候，中国真处于尧舜禹的时代，再过三千年多年，东汉蔡伦才改进造纸术）。 不过，因为莎草只长在埃及地区，又不耐潮湿，在埃及以外的区域普及度并不高。所以在羊皮纸和更后来的中国纸的普及下莎草纸就逐渐失传了。不过，经过上个世纪的一个埃及工程师的研究，人类重新发明了莎草纸的制法。（尽管并没有什么使用价值就是了） 芦苇船，字面意思，就是用芦苇编成的船。在游戏中有两种小船，一种是士兵们坐的木制兵船，另一种则是平民们划的装满蔬果的芦苇船，如果用带火的箭头靠近船身，很快就会看到船被点燃。 参考： 维基百科，莎草纸：https://zh.wikipedia.org/wiki/%E8%8E%8E%E8%8D%89%E7%BA%B8 维基百科，纸莎草：https://zh.wikipedia.org/wiki/%E7%B4%99%E8%8E%8E%E8%8D%89 三桨座战船 游戏里出现频率最高的战船（兵营），古代希腊人和罗马人的一种战船，所谓三桨座的就是一边有三排桨。 参考： 刺客维基，三列桨座战船 三个桨的排布可参考维基百科下图【插入维基图片】 战象 大象皮糙肉厚，体型庞大，无论是实际战力还是对人的压迫力都极强。因此波斯帝国在和印度交战的过程中，学会了驯化大象进行战斗。之后，这一技巧又被与之交战亚历山大大帝学到。托勒密王朝最后从亚历山大人那里继承这一手段。此外，罗马人的老对手，迦太基人也点出了驯化非洲象作战的技能，并在布匿战争中被罗马人学会。这就是为什么我们能在特定的兵营里挑战罗马的战象。 埃及王冠 正如我们在历史篇中提到，埃及是由上下埃及两片构成。上下片无论是地形水土还是文化都有一定差别，因此，埃及王冠由上下埃及王冠合在一起构成的，表示法老同时统治上下埃及。 外圈是下埃及之冠，由于颜色，它也被叫做“红冠”。 内圈是上埃及之冠，由于颜色，它也被叫做“白冠”。 所以完整的王冠也就可以简单粗暴地叫做“红白双冠”。 同时，为了表示神的庇佑，在王冠前端还有上下埃及守护女神的象征，眼镜蛇（下埃及女神瓦吉特）和秃鹫（上埃及女神奈赫美特）。需要提醒的是，秃鹫女神奈赫美特不是母狮女神塞赫美特。 圣书体 圣书体顾名思义，是书“圣”的字体。这是一种用于给祭司们书写祭祀等神圣之事的字体。在游戏神庙的墙上就能看到。虽然随着古埃及文化的消亡，圣书体最终失传，但是它是世界上几乎所有字母系统（例如英语中的ABCD）的起源。 埃赫那顿事件（要不要放进游戏后篇呢） 埃赫那顿是新王国时期的十八王朝的一位法老。在他在位的年代，他干了一件惊世骇俗的事情：对宗教进行改革，否认拉、荷鲁斯、阿蒙等神的存在，认为世界上只有一个神，也就是太阳神阿顿，有人认为这是世界最早的一神论——要知道这个时候是公元前1000多年前！不仅如此，埃赫那顿还把都城由底比斯迁到新修的埃赫塔顿（这个名字也是为了纪念阿顿神） 不仅如此，他的王后也不同寻常。王后娜芙蒂蒂美貌惊人，而且很有能力，她和丈夫一同推进宗教改革、而且拥有一些以往只有法老自己独占的权利，甚至有埃及学家怀疑埃赫那顿的继位者斯门卡瑞就是娜芙蒂蒂化名。 尽管埃赫那顿统治了不短的时间，但是在他去世后，宗教改革成果还是迅速被不满的祭祀们破坏了。斯门卡瑞短暂的统治之后，法老之位传到了埃赫那顿的儿子图坦卡蒙手上。年幼的图坦卡蒙即位后，立即将名字由图坦卡顿（也就是“阿顿的人间化身”）改为图坦卡蒙（“阿蒙的人间化身”），他还把首都迁回底比斯、把父亲的墓改迁回传统的帝王谷、恢复祭司们的职位……而埃赫那顿、阿顿等名字也被刻意的从碑文上抹除，成为一段被刻意避讳和遗忘的历史。 图坦卡蒙的墓 在古埃及王室，近亲结婚现象非常普遍，即使到了八爷的托勒密时代也是如此。而图坦卡蒙，是埃赫那顿和他的姐妹（被埃及学家称为“年轻女士”）的孩子。近亲结婚的后果之一，就是严重的遗传病，根据科学研究，图坦卡蒙有包括脊椎侧弯和兔唇、骨组织坏死等种种疾病，年纪轻轻就需要拄拐杖，最后19岁就英年早逝。 图坦卡蒙之墓在上世纪20年代被英国的一行考古团队找到。保存得极其完好的图坦卡蒙墓不仅成为考古学的大发现，还引起全球轰动。而数位早期探险家的早逝，也引发“法老的诅咒”这一谣言，给古埃及文化戴上一层神秘魔幻的面纱。从那以后，的电影、小说、游戏在使用古埃及的文化形象。某种程度上来说，今天能玩到刺客信条起源，也离不开那次图坦卡蒙之墓被发掘的影响。 为什么游戏里图坦卡蒙和娜芙蒂蒂的死后世界入口在一个墓里呢？这是因为在2015年，科学家们发现图坦卡蒙之墓似乎是改建于在一个女性的墓，而这个女性，就极有可能是被祭司们试图抹杀存在的娜芙蒂蒂王后之墓。 参考： 维基百科-图坦卡蒙 古埃及练习曲，2015年度風雲人物──圖坦卡門","categories":[{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"}]},{"title":"较为优雅的静态博客之旅（二）：更换主题与域名","slug":"搭建博客/较为优雅的静态博客之旅（二）","date":"2021-01-18T11:17:30.000Z","updated":"2024-04-20T18:58:06.472Z","comments":true,"path":"/Hexo-2.html","permalink":"http://example.com/Hexo-2.html","excerpt":"前言 本文承接前文，以 NexT 主题为例，讲述如何更换主题并对其进行配置。","text":"前言 本文承接前文，以 NexT 主题为例，讲述如何更换主题并对其进行配置。 安装 Hexo 支持添加主题。不同的主题可以将博客渲染成各式各样的美观样式，还能对你的博客添加额外功能提供助力。NexT 是一个知名度极高并且至今仍在维护的主题，我们以它为例讲解如何安装主题。在此之前，你应该已经安装好 Hexo 并建立了自己的博客。 NexT 历史版本有多个库，我们将以最新版本进行讲解。 回到博客根目录，在此路径启动终端。输入 1npm install hexo-theme-next@latest 安装 NexT。传统的方式是将下载的主题放到 HexoSite-&gt;themes 文件夹下，但是这种方式对版本升级并不友好。因此我们使用 NPM 进行安装，安装后，NexT 主题的路径是 HexoSite\\node_modules\\hexo-theme-next 。以后，我们就可以使用 NPM 命令管理升级了。 安装完成后，打开 NexT 主题目录，可以看到 Hexo 根目录下和 NexT 主题的路径下都有名为 _config.yml 的配置文件。为了避免混淆，我们在后面称它们为 Hexo 配置文件和 NexT 配置文件。本节后续的主要工作主要都在其中进行。 这两个文件使用一种名为 YAML 的标记语言。Hexo 和 NexT 通过 YAML，以键值对（即先写一个设置项的名字，再写其被设置的值）的形式存储自定义设置。在这里我们不需要太在乎其语法，只需要知道形式是 key: value（中间空格不可省略），且缩进和大小写都很敏感即可。 启用主题和配置 Hexo Hexo 的设置 在之前 部署 一节我们实际上就设置过 Hexo 配置文件，现在我们更详细地对其进行配置。 文件的开头，可以写下网站的名字、侧栏的欢迎语以及作者等。如本站的配置为： 12345678# Sitetitle: &#x27;LeeKa 的酒馆&#x27;subtitle: &#x27;欢迎，旅人！坐下来享受一下暖烘烘的炉火吧。&#x27;description: &#x27;代码、音乐和游戏，一起来聊聊吧&#x27;keywords: sample keywaordauthor: LeeKa...... 我们现在启用主题。将查找 theme，将其值替换为 next： 1theme: next 此时我们 hexo s 启动本地服务，可以看到网页布局发生了改变。 其余 Hexo 原生配置可以查阅文档进行。接下来我们对 NexT 主题进行设置。 NexT 主题的设置 如果我们直接修改 NexT 配置文件，那么升级 NexT 时，这些自定义设置就会被覆盖而丢失。因此更好的做法是使用代替配置文件。这是 Hexo 官方支持的一种功能，具体来说，我们不修改 NexT 配置文件，而将这些配置写在 Hexo 配置文件中。这有点像 VSCode 中的默认设置和工作区设置的关系，后者会覆盖前者设置的值。这样就不会因为升级而丢失设置了，因为这些设置写在 NexT 主题文件之外。 更详细地来说，我们要这么做： 假设这是我们需要修改的配置： 1234567# NexT 配置文件# Schemes# scheme: Muse# scheme: Mistscheme: Pisces# scheme: Gemini 我们并不直接修改它而是： 123456789# Hexo 配置文件theme_config: # Schemes # scheme: Muse # scheme: Mist scheme: Pisces # scheme: Gemini # 所有的配置信息都在theme_config的基础上缩进了相同的空格数 下面是我建议进行配置的功能和对应的条目名： 选择喜欢的布局方案：scheme 设置你的头像：avatar 下 url。推荐将头像上传至图床，使用图床的链接。 设置你的其它网络账号的跳转链接：social 下按需设置 设置喜欢的代码高亮风格和复制按钮：codeblock 下的 theme 、 copy_button 中的 enable 下面是一些需要详细阐述的设置 评论 我使用 Disqus 支持的评论功能，优点是无需备案，缺点是评论者需要注册 Disqus 账号，且国内网络不友好。要使用此功能，需要先注册账号，并选择喜欢的 Shortname（推荐与网站保持一致）。你无需选择 What platform is your site on?，选择最下方的&quot;我的平台不在列表中跳过即可&quot;。 随后，回到配置文件中，在 comments 的 active 项中写为 disqus，并在下面的 disqus 中启用它。即 12345678910111213141516171819202122232425262728theme_config: # …………其它的设置 # Multiple Comment System Support comments: # Available values: tabs | buttons style: tabs # Choose a comment system to be displayed by default. # Available values: disqus | disqusjs | changyan | livere | gitalk | utterances active: disqus # Setting `true` means remembering the comment system selected by the visitor. storage: true # Lazyload all comment systems. lazyload: false # Modify texts or order for any naves, here are some examples. nav: disqus: text: Load Disqus order: -1 #gitalk: # order: -2 # Disqus # For more information: https://disqus.com disqus: enable: true shortname: # 填入你在 Disqus 填写的shortname count: true 站内搜索 安装对应插件（由 NexT 团队支持） 1npm install hexo-generator-searchdb 在 Hexo 配置文件的 NexT 的 代替配置文件 条目中： 1234567891011121314# Local search# Dependencies: https://github.com/next-theme/hexo-generator-searchdblocal_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: 1 # Unescape html strings to the readable one. unescape: false # Preload the search data when the page loads. preload: false 字数统计 安装对应插件（由 NexT 团队支持） 1npm install hexo-word-counter 在 Hexo 配置文件的 NexT 的 代替配置文件 条目中： 12symbols_count_time: separated_meta: true LaTeX 数学公式支持 如果我们需要在 Markdown 中写一些数学公式，那么一个简单的办法就是左右各用一个或者两个美元符号包裹 LaTeX 代码实现行内公式或者公式块。 LaTeX 数学公式语法这里不做讲解，搜索时注意它不是 LaTeX 语法即可。 但是 Hexo 自带的渲染器（渲染器即将 Markdown 转化为对应的网页代码的模块）对于 LaTeX 支持并不好。我们需要换用其它的渲染器。Hexo 有若干的渲染器，它们使用的渲染引擎大体上有两个：MathJax 和 Katex。简单来说，MathJax 支持的格式更全，但是渲染速度更慢；KaTeX 支持的格式更少但是速度更快。 鉴于 VSCode 的 Markdown 预览默认采用的就是 KaTeX，我倾向于使用 KaTeX ，这样在后续 VSCode 中预览时，所得到的渲染信息能够更加符合晚点实际渲染结果。于是我们可以选择的渲染器主要是 hexo-renderer-markdown-it-plus 和 hexo-renderer-markdown-it 。后者需要自行安装 markdown-it-katex 插件，不推荐，我们使用 markdown-it-plus。 在 Hexo 目录下终端运行下列命令 12npm un hexo-renderer-markednpm i hexo-renderer-markdown-it 这表示卸载 Hexo 原生的渲染器 hexo-renderer-marked 并安装新的渲染器 hexo-renderer-markdown-it。 在 Hexo 配置文件中，NexT 的代替配置文件条目下修改为 123katex: # See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex copy_tex: true 在不是 代替配置文件条目 的地方，添加 123456789101112131415# LaTeX fomulamarkdown_it_plus: highlight: true html: true xhtmlOut: true breaks: false langPrefix: linkify: true typographer: false quotes: plugins: - plugin: name: markdown-it-mark enable: false 运行 hexo clean 清理数据，hexo s 检查重新生成的渲染信息。 目前还是有不支持 equation 等格式的问题，怀疑是插件使用的版本较老。","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"静态博客","slug":"静态博客","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"}]},{"title":"较为优雅的静态博客之旅（一）：建站","slug":"搭建博客/较为优雅的静态博客之旅（一）","date":"2020-10-26T16:37:19.000Z","updated":"2024-04-20T18:58:06.470Z","comments":true,"path":"/Hexo-1.html","permalink":"http://example.com/Hexo-1.html","excerpt":"前言 本博客搭建于大一（2020）。当时，作为一个“萌新”，给自己的坎坎坷坷的博客搭建历程写下了些许文字，原名为《搭建个人博客 || 一、在本地搭好博客》。2023 年末，我回过头重新审查文章，重新编辑了一些说的不严谨的地方。 现在（2024 年 1 月），我自觉对使用博客有了一套自己的连贯的流程，故在原文基础上重新编辑完善如下。希望能给你一点帮助。🩷","text":"前言 本博客搭建于大一（2020）。当时，作为一个“萌新”，给自己的坎坎坷坷的博客搭建历程写下了些许文字，原名为《搭建个人博客 || 一、在本地搭好博客》。2023 年末，我回过头重新审查文章，重新编辑了一些说的不严谨的地方。 现在（2024 年 1 月），我自觉对使用博客有了一套自己的连贯的流程，故在原文基础上重新编辑完善如下。希望能给你一点帮助。🩷 介绍 基本情况：我们要做什么？ 本文的目的是记录——或者说教授——搭建一个 Hexo 静态博客，配置主题（此处是 NexT）进行美化，并建立一个我认为较为合理的博客写作工作流的过程。 本文预设的阅读对象是对本文提到的一系列工具、网站、平台（包括 Github）都不甚了解的单纯新大一，亦即曾经的自己。 基于上面的原因，我会花很长的篇幅阐述一些较为基础的概念，对于非预设对象以外的读者，可能会略显冗长。确实如此，我写起来也是这样的感受，然而，一想到大一配此博客时知其然而不知其所以然的情况，我认为进行详细的讲解依然是有必要的。因为很多东西东西并不仅仅是适用于此，而是可以扩展到更广泛的层面，并有益于学习成长的。不过，我会将每一部分需要做的操作写在最开头，这样，如果你已经理解了有关概念，就可以通过侧边栏直接跳到下一届了。 本博客与本博客教程的结果，是一个托管于 Github Pages，基于 Hexo 博客引擎，NexT 主题的静态博客网，可以使用包括 VSCode 在内的任意 Markdown 编辑器进行写作。 本文的第一版，主要参考对象是 @CodeSheep 的 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili。这篇视频存在一定谬误，并且时间已经比较久了（2019），但是总体上对小白是有益的，并且视频可能对一些操作展现得更加清晰。 但是可以不难理解，视频的信息传送速度必然是比文字低的。因此视频并不应该一直是你的主要学习方式。 动机：为什么要选择这种方案？ 为什么要搭建自己的博客？我认为有以下几点原因： 自己的网站，很酷！ 总结，学习，回忆：世界上的知识太多了，很难保证做过、学过的东西你就能永远记得，如果有个博客可以辅助你有朝一日重新上手，或者回忆自己的过往点滴，那是一件很好的事。即博客可以作为你的日志、笔记、日记。 招聘亮点：如果你在简历上写上博客地址，面试官会去看你写了些什么。 学习：搭建博客的过程本身也是一种学习，其中的很多东西并不仅仅是搭建博客才能用。 什么是静态博客？ 静态博客即使用静态网页搭起来的博客，而静态网页即网页事先已经生成好了。 基本上所有的网页都是由 HTML、CSS、JavaScript 组成。HTML 写清楚了网页的标题是什么，段落写了什么，哪些文字有指向哪儿的超链接，插入了什么图片视频等等；而 CSS 则将这些文字按合理的方式进行排版，组成丰富多样的美观界面；最后 JavaScript 则提供了一些交互和动态元素，例如，这个站点的一键返回顶部、一些博客网站会有的被鼠标吸引的粒子等等。换句话说，静态博客并不意味着博客毫无互动性。 但是，所有的这些互动性都是已经写好的，网站的浏览者无法改变。反之，例如同样是 B 站首页，不同的人登录后看到的消息通知、推送视频乃至个性化装扮都不尽相同。这是因为网页是 B 站的服务器根据登录的用户不同返回了不同的内容，直接改变了网页信息。同时，用户在网页上也可以直接和 B 站服务器打交道，改变 B 站服务器数据库中（自己的）数据。这就是动态网页。而静态站点，浏览者无法改变网站数据库的任何信息。 为什么使用静态博客而非动态博客？ 静态博客安全：你的数据不会因为各类漏洞被黑客劫持。实际上，所有的数据都有本地备份，因此你的数据更安全。 静态博客维护方便，维护一个动态博客很可能需要你有一定的数据库和网络基础，学习量大于静态博客。 静态博客廉价：很多网站都可以免费托管你的静态博客（即你实际上访问的托管网站的服务器），而动态网页需要你有服务器。 静态博客让你专注于文字本身：减少对网站的关注，就是增加对文字的关注，把重心放到博文——我们的初心上。 看看别人怎么说：静态博客的优点是什么 - V2EX。 什么是博客引擎（框架）？为什么使用 Hexo 搭建静态博客？ 我们前面提到了网站使用 HTML 等组成，但是我们使用的是更简单的一些格式来写作，例如 Markdown。因此我们需要一些工具将文章转换成对应的 HTML等。此外一些和写作不太相关但是又需要的功能，例如通过标签分类文章等等，也可以通过 Hexo 这样的博客引擎办到，这就让搭建博客变得轻松了。而说到 Hexo 的优势则在于： Hexo 用户众多：这既证明了 Hexo 是一个优秀的博客引擎，也代表你遇到问题更容易找到答案。 Hexo 命令简单，一般来说，你只需要记住三个命令就可以畅快地写作了。 Hexo 迁移方便，你可以使用 Markdown 写作文章，而 Markdown 是一个广受支持的写作格式，因此你的文章可以轻松迁移到其它博客引擎上。 我用的就是 Hexo。 什么是 Markdown，为什么要使用 Markdown？ 某种意义上来说 Markdown 和 HTML 差不多，都是标记语言。也就是说，你写了一篇文章，可以用一些符号标明哪里是一级标题，哪里是二级标题，哪里是引用的别人的话等等。例如 12345678910# 一级标题随便写一段话。第二段再写一段话，并且引用 Linus 的名言&gt; Fuck you, nVidia --Linus## 二级标题其它的话。 它的效果是： 三级标题 随便写一段话。 第二段再写一段话，并且引用 Linus 的名言 Fuck you, nVidia --Linus 四级标题 其它的话。 Markdown 格式简单：这可以从上面的例子看出来。具体学习此处不赘述，互联网上有很多教程，而且你可能只需要 5 分钟就能基本掌握 Markdown 的主要写法。 Markdown 用途广：从飞书云文档到 Notion 再到这个博客网站，很多地方都支持你使用 Markdown 进行写作。 Markdown 让你专注写作：正如前面所说，花在其它地方的时间越少，花在文字上的时间就越多。Markdown 让你可以不用太关注排版之内的问题，你可以把注意力集中到内容本身上。 Hexo 的运行环境：Node.js 和 Git 我在 Windows 10 和 Windows 11 上运行 Hexo。不过，你使用什么系统并不重要，重要的是运行 Hexo 需要先安装下面两个软件： Node.js：下载安装 LTS （长期技术支持）版本即可。安装程序只需要全部保持默认即可。同时，Node.js 会附带安装 NPM。 Git：下载最新版本并安装即可。 在你的终端（例如 PowerShell）等运行 node -v 和 git -v 查看 Node.js 的版本号和 git 的版本号。如果没有报错就说明安装成功了。 如果你仍然使用 Windows 10，非常建议你在应用商店下载 Windows Terminal 这个官方应用，它可以管理包括 PowerShell 和 CMD 在内的各种 Shell 。Shell 和终端严格来说不是一个概念，但是可以不做区分。 下面是一些对 Node.js 和 Git 的功能的介绍。 Node.js 和 NPM 官方定义中 Node.js 是一个开源、跨平台的 JavaScript 运行时环境，由 OpenJS 基金会维护和持有。这个话很抽象，这是因为你可能并不清楚什么叫“JavaScript 运行时环境”，也并不清楚这和 Hexo 有什么关系。我们可以（粗略地）理解：JavaScript 是一个编程语言，正如 C 语言一样，要 C 语言代码变成可以运行的程序需要有编译器，而要 JavaScript 代码能运行起来，我们就可以通过 Node.js。换言之，要运行 JS 就需要 Node.js 作为“环境”。这就是运行时环境的含义。而 Hexo 正是通过 JavaScript 编写的，因此其运行自然就需要 Node.js。 👉： 你可以在 GitHub 找到 hexojs/hexo 的源代码，界面右侧的 language 标明了其使用什么语言。其中 TypeScript 就是对类型检查更严格的 JavaScript。 浏览器也可以运行 JavaScript，但是很显然并没有那么适合去开发什么工具。 当你安装 Node.js 时，你还会自动安装一个叫 NPM 的软件，NPM 可以认为是 Node Package Manager 的缩写，即 Node.js 的（默认）包管理器。当开发者开始开发什么东西的时候，通常会依赖一些前人的代码成果，即所谓&quot;包&quot;。而这些包又有自己依赖的包，同时，被依赖的包也在不断的变化改进中，版本过高或者过低都未必有用……要解决这样问题，使用包管理器就很有用了。它不仅能从受维护的可靠渠道下载你需要的包的正确版本，同时还可以将其依赖的其它包一并下载下来并且版本符合需要，当你卸载包时，其依赖的包如果不需要了也会被卸载。而安装、卸载更新这些包都只需要你敲一行命令。 NPM 由 NPM 公司维护，你可以在他们的官网搜到你下载的那些包的信息。 默认情况下使用 NPM 下载很慢，这是因为 NPM 的源的服务器在海外。你可以给 NPM 设置代理，也可以更换 NPM 下载源（例如淘宝源）。如果你有代理，那么设置方法可以参考在终端中输入： 12npm config set proxy http://127.0.0.1:7890npm config set https-proxy http://127.0.0.1:7890 如果你由于各种原因无法使用代理，不仅可以换源为国内源，另一种解决办法是使用 cnpm，这是一个由阿里云推出的的 npm 客户端，可以说它和 npm 在下载方面的功能完全一致。使用 cnpm 的优点在于默认就是国内源进行下载，安装 cnmp 的具体方法可以自行搜索解决。由于我并没采用这种方法，此处就并不展开了。 👉： 当我们说从 NPM 源下载包时，实际上就是从 https://registry.npmjs.org/ 进行下载。当我们说换源时，实际上就是更改这个下载地址。 NPM 并不是唯一的包管理器，还有其它的很多包管理器，例如 Yarn。 Git 和 GitHub 即使没有通过 Git，你也很有可能听说过 GitHub 这个所谓&quot;程序员都会上&quot;的网站。Git 和 GitHub 并没有什么必然联系，但是 GitHub 中的 Git 确实就是指的软件 Git。下面我们通过一个简单的例子了解 Git 的作用。 假设你正在和朋友开发一个软件，你写好了一个功能 A 后，继续开发新的功能，这个时候，你不由得希望可以 保存现在的项目状态 以防止后面开发出现问题时，连原本的功能 A 也用不了了。此时，朋友告知你，他添加了新的功能 B 还优化了功能 A ，问你“我们要怎么把 这台电脑上的修改同步到那台电脑上？”，同步了两台电脑的改动后，你们一起开发功能 C，不料代码出了 bug ，debug 时，你不由得想知道，现在的代码和之前的代码究竟有什么区别？ 也就是说，Git 是一个开源的版本控制软件。正如 RPG 游戏中我们需要时不时存档，Git 可以在需要的时候存档文件，保证我们不会因为误操作而损失数据。同时，如果多个人一起开发，我们还可以区分究竟是谁改了哪一行文本。Git 既可以保证我们不会把好好的代码改坏，也可以轻松和别人合作修改同一个文件最后合并在一起，诸如此类的许多优点让它风靡全球。 如果我们需要和世界其它地方的人一起开发，那么我们就需要一个 仓库 存储代码，就好像通过网盘给别人分享文件一样。只不过这个 仓库 需要有一个版本控制软件，这样我们就可以查看它的历史版本，也可以一起协作修改，亦或者撤回曾经的修改。提供这种帮你在远端保管代码平台有很多，其中最有名的正是 GitHub，它使用 Git 来进行版本控制。 Git 和 GitHub 都是强大的工具，感到后悔或犹豫的时候就使用 Git 给代码 “存档” 吧。 关于 Git 和 GitHub 的介绍到此为止，我们现在关心的是：为什么 Hexo 的安装需要 Git ？ 为此我们需要简单介绍一下 Hexo 的工作流程。 前面提到，当我们写好文章，Hexo 就可以根据它们生成对应的 HTML 等网页文件。但是如果文件只是在本地，那么就没有人可以访问它。你需要将它们上传到一个服务器，并且服务器会将你给它的文件组合在一起形成网页，这样我们通过网址访问就能看到美观的网页了。好在你不需要花钱购买自己的服务器或云服务器，很多平台可以免费将你上传的文件显示成网页提供访问。例如 GitHub 提供的 GitHub Pages。GitHub 将用户设定的特定仓库里的文件视为你上传的网页文件，然后使用 GitHub Pages 将它们作为网页呈现出来这样，你的博客就算上线了。 所以简单来说，Hexo 需要使用 Git，是因为它使用将生成的网页传到显示网页的仓库中去。 使用 Git 仓库存储托管的静态网页是一种很常见的做法，并不是只有 GitHub 这么做（虽然 GitHub 确实应该是最大的服务商）。例如，国内就有 Gitee 等同样使用 Git 管理托管的代码的平台。我们会在后面托管时细谈。 安装 Hexo 并建立站点 在安装完成 Node.js 后，我们就可以用包管理器 NPM 安装 Hexo 了。只需要打开终端，输入 1npm install -g hexo-cli 这句话的意思是适用 NPM 全局安装 Hexo 的命令行接口（command line, cli）。即当我们输入（指定的）命令时，hexo-cli 可以调起 hexo 的对应功能。 推荐使用全局安装是因为可以不在乎输入命令时终端地址在哪。 打开终端，输入 hexo -v 就可以检查 Hexo 是否正常安装以及安装版本是多少了。 选择适合的地方建立文件夹，这个文件夹会存储博客的所有数据，因此建议使用清晰简洁的英文进行命名。 👉： 推荐为此文件夹创建快捷入口。例如 Windows 系统下，将此文件夹固定到 快速访问 或 开始菜单 中。 在这个空文件夹中打开终端，或者说将终端地址跳转到此文件夹，输入 1hexo init 即对此文件夹进行初始设置（initialization）。Hexo 会自动下载创建一些必要的文件。当命令执行完毕，博客的搭建数据就算创建完成了。我们可以通过下面的命令检查一下 1hexo server 这个命令会在本机启动一个服务程序，即把这台计算机自己看做服务器。这个时候我们可以在浏览器中通过访问网址 localhost：4000 访问 Hexo 这个&quot;远端&quot;的服务程序。 如果可以看到网页被加载出来，那么说明我们博客已经建立起来了。 将网站托管给远端服务器（Github Pages） 仅仅建立站点是不够的。因为我们希望我们可以 任意时候、任意地方、任意设备 都能访问我们的网站——就像任意一个正常的网站一样。而我们在上一步中启动的不过是一个本机局域网中服务器而已，既不能在其它设备上访问，也无法保证我们永不关机。而比起自己买一个服务器，更简单的方式是直接使用一些网站提供的免费静态网页托管服务。 在这里，我们推荐使用 GitHub 提供的 GitHub Pages。尽管存在其它的同类服务提供商，但是 GitHub 作为最大的代码托管网站，使用其服务更典型、主流。同时，Gitee 要求审核后再公开仓库的做法不仅麻烦，还让人不由得怀疑其后续是否存在其它更严格的各类手续要求。 当然，在国内存在一定的访问问题，这个需要自己想办法解决。 下面阐述其步骤： 首先，创建一个 GitHub 账号。 新建仓库（Repository）：每个 GitHub 账号有一个对应的 &lt;Github 用户名&gt;.github.io 域名，如果你希望部署到这个域名下，仓库名就同样设为 &lt;Github 用户名&gt;.github.io。或者你也可以任意取仓库名，这样你最终部署到域名将是 &lt;Github 用户名&gt;.github.io/&lt;你的仓库名&gt;。 回到博客目录启动终端，运行 npm install hexo-deployer-git 安装 Hexo-deployer-git。这是 Hexo 官方提供的部署工具，使用它可以一行命令把文件推送到远端。 打开博客根目录下的 _config.yml 文件（使用 VSCode 或任意其它编辑器均可），在最后粘贴并修改有关信息： 1234deploy: type: git repo: &lt;前面建立的仓库地址&gt; # 例如 https://github.com/foobar/foobar.github.io branch: [仓库分支] # 通常来说是main，也可以查看你的仓库进行确定 回到命令行，执行下列命令设定全局的 Git 用户名： 12git config --global user.email &quot;你的名字或者昵称&quot; git config --global user.name &quot;你的邮箱地址&quot; 我们提到 Git 是一个可以多人合作的版本控制软件，因此，Git 需要记录究竟是谁在提交，这样协作者（对于开源项目，可能是陌生人）就可以联系到你并直到如何称呼你。其中 --global 表示的是在此电脑上的所有 Git 仓库都默认使用这个设置。通常，我们只用一个用户名即可。 推荐将用户名和邮件地址与 GitHub 账号保持一致。因为 GitHub 使用你 Git 中设置的邮箱来确定是哪个用户进行了提交。 执行 hexo deploy（deploy 可以简写为 d）命令推送到 GitHub 仓库，你还需要根据提示输入 GitHub 用户名和密码。Git 设置的“用户名”仅仅是一个标记而已。如果想要写入仓库，GitHub 显然需要检查你的权限。因此你需要在这里输入密码。 每次都输入密码是一件麻烦事，你可以使用 令牌（Token） 或 SSH认证 来避免这件事。 当 hexo d 没有报错的成功执行完成，那么一切就算大功告成了。稍等片刻，GitHub 会通过 GitHub Action 服务将你传送的修改信息同步到网页。当看到分支下面的最后提交记录右侧显示绿色的对勾✔️时，就说明更改已经完成了。 请注意，hexo d 会直接覆盖仓库里的所有文件，因此不要在这个仓库的这个分支放入任何其它数据。 访问网页，查看你的崭新上线的博客！ 总结与下一步 总结一下，本节论述了一下操作。如何安装 Hexo 博客的两个前置软件：Node.js 和 Git，以及使用 NPM 安装 Hexo 和 Hexo 的部署插件，最后，使用命令在本地创建一个 Hexo 博客并将它通过 Git 推送到 GitHub。特别地，我们还介绍了一些加速 NPM 下载的方法。 尽管这些操作并不复杂，但是为了面向和大一的我一样完全没有任何知识的朋友，本文还较为详细的阐述了 Node.js 、NPM 、Git 、GitHub 等软件和网站作用，命令的含义等。因此篇幅拉得比较长。我认为这是有必要的：以本文原始参考对象为代表的众多博客文章和视频中，作者往往不愿或者不能对其中的细节进行阐述。当然，我们不应该寄希望于作者认为读者应该知道的知识总是为读者所知，一个合格的读者应该学会使用搜索引擎。但是，我们总是应该对小白留出更多的耐心，并传达出&quot;知其然且知其所以然&quot;的学习观念，我希望这篇文章做到了。 在下一节中，我们介绍如何简单地自定义博客，包括更换主题（以 NexT 为例），并对其进行详细地自定义。 拓展阅读 感谢与参考 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo_哔哩哔哩_bilibili，这是本文的最初参考对象。尽管本文并非&quot;无坑视频&quot;（他甚至没有介绍安装 Git，没有 Git 是无法初始化博客的），使用 Vim 的做法对初学者也不算友好，但是依然对本站的建立起到了很大的帮助。 文档 | Hexo：Hexo 的官方文档。尽管曾经备受吐槽，但是我认为现在【开始使用】部分的章节写得相当不错。如果嫌本文啰嗦，可以查阅 【开始使用】部分的《概述》、《建站》、《配置》和《命令》四个章节。此外，查阅官方文档绝大部分时候都会是最高效的问题解决方案。 你还可以查阅其它搜索引擎上的文章，不过它们很有可能充满谬误（因为作者是刚刚建站的小白）或者时间久远，需要自行甄别。 本站的建立还得到了 hawa130 的指导，欢迎访问他的博客：Hanwan Space。 你还可以就具体问题询问搜索引擎和通用聊天 AI（如 ChatGPT 等）的意见。","categories":[{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"静态博客","slug":"静态博客","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/categories/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/categories/GAMES101/"},{"name":"GAMES104","slug":"GAMES104","permalink":"http://example.com/categories/GAMES104/"},{"name":"All About Unity","slug":"All-About-Unity","permalink":"http://example.com/categories/All-About-Unity/"},{"name":"歌词翻译","slug":"歌词翻译","permalink":"http://example.com/categories/%E6%AD%8C%E8%AF%8D%E7%BF%BB%E8%AF%91/"},{"name":"Unity 与 C#","slug":"Unity-与-C","permalink":"http://example.com/categories/Unity-%E4%B8%8E-C/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/categories/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"多媒体数据处理实验","slug":"多媒体数据处理实验","permalink":"http://example.com/categories/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AE%9E%E9%AA%8C/"},{"name":"长期更新的笔记","slug":"长期更新的笔记","permalink":"http://example.com/categories/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%E7%9A%84%E7%AC%94%E8%AE%B0/"},{"name":"c++学习笔记","slug":"c-学习笔记","permalink":"http://example.com/categories/c-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"学做合格的开发","slug":"学做合格的开发","permalink":"http://example.com/categories/%E5%AD%A6%E5%81%9A%E5%90%88%E6%A0%BC%E7%9A%84%E5%BC%80%E5%8F%91/"},{"name":"VSCode 说明书","slug":"VSCode-说明书","permalink":"http://example.com/categories/VSCode-%E8%AF%B4%E6%98%8E%E4%B9%A6/"},{"name":"生活中的杂项堆叠","slug":"生活中的杂项堆叠","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E6%9D%82%E9%A1%B9%E5%A0%86%E5%8F%A0/"},{"name":"搭建博客","slug":"搭建博客","permalink":"http://example.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/categories/%E8%AF%AD%E6%91%98/"},{"name":"小文章","slug":"小文章","permalink":"http://example.com/categories/%E5%B0%8F%E6%96%87%E7%AB%A0/"},{"name":"刺客信条旅游指南","slug":"刺客信条旅游指南","permalink":"http://example.com/categories/%E5%88%BA%E5%AE%A2%E4%BF%A1%E6%9D%A1%E6%97%85%E6%B8%B8%E6%8C%87%E5%8D%97/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://example.com/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"密码学","slug":"密码学","permalink":"http://example.com/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"RSA","slug":"RSA","permalink":"http://example.com/tags/RSA/"},{"name":"高木变体","slug":"高木变体","permalink":"http://example.com/tags/%E9%AB%98%E6%9C%A8%E5%8F%98%E4%BD%93/"},{"name":"论文翻译","slug":"论文翻译","permalink":"http://example.com/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/"},{"name":"游戏,","slug":"游戏","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F/"},{"name":"碧蓝航线","slug":"碧蓝航线","permalink":"http://example.com/tags/%E7%A2%A7%E8%93%9D%E8%88%AA%E7%BA%BF/"},{"name":"Culture","slug":"Culture","permalink":"http://example.com/tags/Culture/"},{"name":"语言学","slug":"语言学","permalink":"http://example.com/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6/"},{"name":"CPP","slug":"CPP","permalink":"http://example.com/tags/CPP/"},{"name":"物理引擎","slug":"物理引擎","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/"},{"name":"2D","slug":"2D","permalink":"http://example.com/tags/2D/"},{"name":"维纳攻击","slug":"维纳攻击","permalink":"http://example.com/tags/%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB/"},{"name":"Android","slug":"Android","permalink":"http://example.com/tags/Android/"},{"name":"WSL","slug":"WSL","permalink":"http://example.com/tags/WSL/"},{"name":"WSA","slug":"WSA","permalink":"http://example.com/tags/WSA/"},{"name":"配置环境","slug":"配置环境","permalink":"http://example.com/tags/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Obsidian","slug":"Obsidian","permalink":"http://example.com/tags/Obsidian/"},{"name":"云服务器","slug":"云服务器","permalink":"http://example.com/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大作业","slug":"大作业","permalink":"http://example.com/tags/%E5%A4%A7%E4%BD%9C%E4%B8%9A/"},{"name":"python","slug":"python","permalink":"http://example.com/tags/python/"},{"name":"实验报告","slug":"实验报告","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"笔记","slug":"笔记","permalink":"http://example.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"GAMES","slug":"GAMES","permalink":"http://example.com/tags/GAMES/"},{"name":"GAMES101","slug":"GAMES101","permalink":"http://example.com/tags/GAMES101/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://example.com/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/"},{"name":"动画","slug":"动画","permalink":"http://example.com/tags/%E5%8A%A8%E7%94%BB/"},{"name":"粒子","slug":"粒子","permalink":"http://example.com/tags/%E7%B2%92%E5%AD%90/"},{"name":"刚体","slug":"刚体","permalink":"http://example.com/tags/%E5%88%9A%E4%BD%93/"},{"name":"流体","slug":"流体","permalink":"http://example.com/tags/%E6%B5%81%E4%BD%93/"},{"name":"计算机动画","slug":"计算机动画","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%A8%E7%94%BB/"},{"name":"关键帧","slug":"关键帧","permalink":"http://example.com/tags/%E5%85%B3%E9%94%AE%E5%B8%A7/"},{"name":"骨骼系统","slug":"骨骼系统","permalink":"http://example.com/tags/%E9%AA%A8%E9%AA%BC%E7%B3%BB%E7%BB%9F/"},{"name":"运动学","slug":"运动学","permalink":"http://example.com/tags/%E8%BF%90%E5%8A%A8%E5%AD%A6/"},{"name":"Rigging","slug":"Rigging","permalink":"http://example.com/tags/Rigging/"},{"name":"颜色","slug":"颜色","permalink":"http://example.com/tags/%E9%A2%9C%E8%89%B2/"},{"name":"色彩空间","slug":"色彩空间","permalink":"http://example.com/tags/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4/"},{"name":"相机","slug":"相机","permalink":"http://example.com/tags/%E7%9B%B8%E6%9C%BA/"},{"name":"光场","slug":"光场","permalink":"http://example.com/tags/%E5%85%89%E5%9C%BA/"},{"name":"透镜","slug":"透镜","permalink":"http://example.com/tags/%E9%80%8F%E9%95%9C/"},{"name":"渲染","slug":"渲染","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93/"},{"name":"光线传播","slug":"光线传播","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E4%BC%A0%E6%92%AD/"},{"name":"材质","slug":"材质","permalink":"http://example.com/tags/%E6%9D%90%E8%B4%A8/"},{"name":"程序化生成","slug":"程序化生成","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%94%9F%E6%88%90/"},{"name":"BRDF","slug":"BRDF","permalink":"http://example.com/tags/BRDF/"},{"name":"反射率","slug":"反射率","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84%E7%8E%87/"},{"name":"折射","slug":"折射","permalink":"http://example.com/tags/%E6%8A%98%E5%B0%84/"},{"name":"反射","slug":"反射","permalink":"http://example.com/tags/%E5%8F%8D%E5%B0%84/"},{"name":"微表面","slug":"微表面","permalink":"http://example.com/tags/%E5%BE%AE%E8%A1%A8%E9%9D%A2/"},{"name":"菲涅尔项","slug":"菲涅尔项","permalink":"http://example.com/tags/%E8%8F%B2%E6%B6%85%E5%B0%94%E9%A1%B9/"},{"name":"光线追踪","slug":"光线追踪","permalink":"http://example.com/tags/%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"辐射度量学","slug":"辐射度量学","permalink":"http://example.com/tags/%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"},{"name":"路径追踪","slug":"路径追踪","permalink":"http://example.com/tags/%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/"},{"name":"蒙特卡洛积分","slug":"蒙特卡洛积分","permalink":"http://example.com/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E7%A7%AF%E5%88%86/"},{"name":"渲染方程","slug":"渲染方程","permalink":"http://example.com/tags/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B/"},{"name":"全局光照","slug":"全局光照","permalink":"http://example.com/tags/%E5%85%A8%E5%B1%80%E5%85%89%E7%85%A7/"},{"name":"AABB 包围盒","slug":"AABB-包围盒","permalink":"http://example.com/tags/AABB-%E5%8C%85%E5%9B%B4%E7%9B%92/"},{"name":"均匀网格","slug":"均匀网格","permalink":"http://example.com/tags/%E5%9D%87%E5%8C%80%E7%BD%91%E6%A0%BC/"},{"name":"着色","slug":"着色","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2/"},{"name":"软阴影","slug":"软阴影","permalink":"http://example.com/tags/%E8%BD%AF%E9%98%B4%E5%BD%B1/"},{"name":"阴影映射","slug":"阴影映射","permalink":"http://example.com/tags/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"},{"name":"Whitted-Style 光线追踪","slug":"Whitted-Style-光线追踪","permalink":"http://example.com/tags/Whitted-Style-%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"},{"name":"求交点","slug":"求交点","permalink":"http://example.com/tags/%E6%B1%82%E4%BA%A4%E7%82%B9/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://example.com/tags/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/"},{"name":"B 样条","slug":"B-样条","permalink":"http://example.com/tags/B-%E6%A0%B7%E6%9D%A1/"},{"name":"网格简化","slug":"网格简化","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%AE%80%E5%8C%96/"},{"name":"网格细分","slug":"网格细分","permalink":"http://example.com/tags/%E7%BD%91%E6%A0%BC%E7%BB%86%E5%88%86/"},{"name":"Loop 细分","slug":"Loop-细分","permalink":"http://example.com/tags/Loop-%E7%BB%86%E5%88%86/"},{"name":"Catmull-Clark 细分","slug":"Catmull-Clark-细分","permalink":"http://example.com/tags/Catmull-Clark-%E7%BB%86%E5%88%86/"},{"name":"隐式几何","slug":"隐式几何","permalink":"http://example.com/tags/%E9%9A%90%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"显式几何","slug":"显式几何","permalink":"http://example.com/tags/%E6%98%BE%E5%BC%8F%E5%87%A0%E4%BD%95/"},{"name":"构造实体几何","slug":"构造实体几何","permalink":"http://example.com/tags/%E6%9E%84%E9%80%A0%E5%AE%9E%E4%BD%93%E5%87%A0%E4%BD%95/"},{"name":"距离函数","slug":"距离函数","permalink":"http://example.com/tags/%E8%B7%9D%E7%A6%BB%E5%87%BD%E6%95%B0/"},{"name":"纹理映射","slug":"纹理映射","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86%E6%98%A0%E5%B0%84/"},{"name":"重心坐标","slug":"重心坐标","permalink":"http://example.com/tags/%E9%87%8D%E5%BF%83%E5%9D%90%E6%A0%87/"},{"name":"Mipmap","slug":"Mipmap","permalink":"http://example.com/tags/Mipmap/"},{"name":"线性插值","slug":"线性插值","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E6%8F%92%E5%80%BC/"},{"name":"图形学","slug":"图形学","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"着色器","slug":"着色器","permalink":"http://example.com/tags/%E7%9D%80%E8%89%B2%E5%99%A8/"},{"name":"Blinn-Phong 着色模型","slug":"Blinn-Phong-着色模型","permalink":"http://example.com/tags/Blinn-Phong-%E7%9D%80%E8%89%B2%E6%A8%A1%E5%9E%8B/"},{"name":"纹理","slug":"纹理","permalink":"http://example.com/tags/%E7%BA%B9%E7%90%86/"},{"name":"uv 图","slug":"uv-图","permalink":"http://example.com/tags/uv-%E5%9B%BE/"},{"name":"图形管线","slug":"图形管线","permalink":"http://example.com/tags/%E5%9B%BE%E5%BD%A2%E7%AE%A1%E7%BA%BF/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://example.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"GMAES104","slug":"GMAES104","permalink":"http://example.com/tags/GMAES104/"},{"name":"导论","slug":"导论","permalink":"http://example.com/tags/%E5%AF%BC%E8%AE%BA/"},{"name":"光栅化","slug":"光栅化","permalink":"http://example.com/tags/%E5%85%89%E6%A0%85%E5%8C%96/"},{"name":"反走样","slug":"反走样","permalink":"http://example.com/tags/%E5%8F%8D%E8%B5%B0%E6%A0%B7/"},{"name":"深度检测","slug":"深度检测","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E6%A3%80%E6%B5%8B/"},{"name":"Z-Buffer 算法","slug":"Z-Buffer-算法","permalink":"http://example.com/tags/Z-Buffer-%E7%AE%97%E6%B3%95/"},{"name":"画家算法","slug":"画家算法","permalink":"http://example.com/tags/%E7%94%BB%E5%AE%B6%E7%AE%97%E6%B3%95/"},{"name":"采样","slug":"采样","permalink":"http://example.com/tags/%E9%87%87%E6%A0%B7/"},{"name":"Unity","slug":"Unity","permalink":"http://example.com/tags/Unity/"},{"name":"输入","slug":"输入","permalink":"http://example.com/tags/%E8%BE%93%E5%85%A5/"},{"name":"翻译","slug":"翻译","permalink":"http://example.com/tags/%E7%BF%BB%E8%AF%91/"},{"name":"歌词","slug":"歌词","permalink":"http://example.com/tags/%E6%AD%8C%E8%AF%8D/"},{"name":"音乐","slug":"音乐","permalink":"http://example.com/tags/%E9%9F%B3%E4%B9%90/"},{"name":"Owl City","slug":"Owl-City","permalink":"http://example.com/tags/Owl-City/"},{"name":"delegate","slug":"delegate","permalink":"http://example.com/tags/delegate/"},{"name":"C#","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"Event","slug":"Event","permalink":"http://example.com/tags/Event/"},{"name":"视频笔记","slug":"视频笔记","permalink":"http://example.com/tags/%E8%A7%86%E9%A2%91%E7%AC%94%E8%AE%B0/"},{"name":"向量数据库","slug":"向量数据库","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"哔哩哔哩","slug":"哔哩哔哩","permalink":"http://example.com/tags/%E5%93%94%E5%93%A9%E5%93%94%E5%93%A9/"},{"name":"Ele实验室","slug":"Ele实验室","permalink":"http://example.com/tags/Ele%E5%AE%9E%E9%AA%8C%E5%AE%A4/"},{"name":"索引","slug":"索引","permalink":"http://example.com/tags/%E7%B4%A2%E5%BC%95/"},{"name":"多媒体数据处理","slug":"多媒体数据处理","permalink":"http://example.com/tags/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"课程","slug":"课程","permalink":"http://example.com/tags/%E8%AF%BE%E7%A8%8B/"},{"name":"KNN 问题","slug":"KNN-问题","permalink":"http://example.com/tags/KNN-%E9%97%AE%E9%A2%98/"},{"name":"局部敏感哈希","slug":"局部敏感哈希","permalink":"http://example.com/tags/%E5%B1%80%E9%83%A8%E6%95%8F%E6%84%9F%E5%93%88%E5%B8%8C/"},{"name":"BOF","slug":"BOF","permalink":"http://example.com/tags/BOF/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"云计算","slug":"云计算","permalink":"http://example.com/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"《第一行代码》","slug":"《第一行代码》","permalink":"http://example.com/tags/%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%8B/"},{"name":"长期更新","slug":"长期更新","permalink":"http://example.com/tags/%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"name":"负基础","slug":"负基础","permalink":"http://example.com/tags/%E8%B4%9F%E5%9F%BA%E7%A1%80/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"基础语法","slug":"基础语法","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"数据分析","slug":"数据分析","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"},{"name":"数据编码","slug":"数据编码","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/"},{"name":"实习","slug":"实习","permalink":"http://example.com/tags/%E5%AE%9E%E4%B9%A0/"},{"name":"Seed 训练营","slug":"Seed-训练营","permalink":"http://example.com/tags/Seed-%E8%AE%AD%E7%BB%83%E8%90%A5/"},{"name":"Unreal","slug":"Unreal","permalink":"http://example.com/tags/Unreal/"},{"name":"杂录","slug":"杂录","permalink":"http://example.com/tags/%E6%9D%82%E5%BD%95/"},{"name":"存在困难","slug":"存在困难","permalink":"http://example.com/tags/%E5%AD%98%E5%9C%A8%E5%9B%B0%E9%9A%BE/"},{"name":"MVP变换","slug":"MVP变换","permalink":"http://example.com/tags/MVP%E5%8F%98%E6%8D%A2/"},{"name":"视图变换","slug":"视图变换","permalink":"http://example.com/tags/%E8%A7%86%E5%9B%BE%E5%8F%98%E6%8D%A2/"},{"name":"投影变换","slug":"投影变换","permalink":"http://example.com/tags/%E6%8A%95%E5%BD%B1%E5%8F%98%E6%8D%A2/"},{"name":"基本线性变换","slug":"基本线性变换","permalink":"http://example.com/tags/%E5%9F%BA%E6%9C%AC%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2/"},{"name":"仿射变换","slug":"仿射变换","permalink":"http://example.com/tags/%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2/"},{"name":"齐次矩阵","slug":"齐次矩阵","permalink":"http://example.com/tags/%E9%BD%90%E6%AC%A1%E7%9F%A9%E9%98%B5/"},{"name":"线性代数","slug":"线性代数","permalink":"http://example.com/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"向量","slug":"向量","permalink":"http://example.com/tags/%E5%90%91%E9%87%8F/"},{"name":"矩阵","slug":"矩阵","permalink":"http://example.com/tags/%E7%9F%A9%E9%98%B5/"},{"name":"Code","slug":"Code","permalink":"http://example.com/tags/Code/"},{"name":"VSCode","slug":"VSCode","permalink":"http://example.com/tags/VSCode/"},{"name":"软件使用技巧","slug":"软件使用技巧","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生产力","slug":"生产力","permalink":"http://example.com/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"},{"name":"博客","slug":"博客","permalink":"http://example.com/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"日常","slug":"日常","permalink":"http://example.com/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Music","slug":"Music","permalink":"http://example.com/tags/Music/"},{"name":"ILLENIUM","slug":"ILLENIUM","permalink":"http://example.com/tags/ILLENIUM/"},{"name":"批处理脚本","slug":"批处理脚本","permalink":"http://example.com/tags/%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"},{"name":"Hexo","slug":"Hexo","permalink":"http://example.com/tags/Hexo/"},{"name":"电影","slug":"电影","permalink":"http://example.com/tags/%E7%94%B5%E5%BD%B1/"},{"name":"天国王朝","slug":"天国王朝","permalink":"http://example.com/tags/%E5%A4%A9%E5%9B%BD%E7%8E%8B%E6%9C%9D/"},{"name":"语摘","slug":"语摘","permalink":"http://example.com/tags/%E8%AF%AD%E6%91%98/"},{"name":"非技术","slug":"非技术","permalink":"http://example.com/tags/%E9%9D%9E%E6%8A%80%E6%9C%AF/"},{"name":"Game","slug":"Game","permalink":"http://example.com/tags/Game/"},{"name":"OverThoughts","slug":"OverThoughts","permalink":"http://example.com/tags/OverThoughts/"},{"name":"静态博客","slug":"静态博客","permalink":"http://example.com/tags/%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"}]}