---
title: 多媒体实验2：PCA主成分分析
tags:
  - 课程
  - 多媒体数据处理
  - 实验报告
  - 数据分析
categories: 课程报告
date: 2023-04-10T22:47:38.000Z
---

## 前言

PCA（Principal Component Analysis）是一种常用的数据分析方法。 <!-- more -->

## 从数据压缩说起

正如本课的课名所指出的,本课探究的是计算机对多媒体数据的处理分析过程。这个过程中，我们将人类看得懂的各类信息（声、图、文、语言等）输入计算机，期望计算机能对"信息"进行分析，进而发现"知识"，从中学习或者获得智能。把信息在人类载体（上述声、图、文、语言等）和机器载体（比特）之间变换的过程，就是编码和解码。数据压缩，就是在编码的过程中将庞杂的信息转化为更简短和信息，进而方便处理。

> 例如，对信息 111444444999995，我们可以记为 1#3 4#6 9#5 5#1 从而起到压缩的作用

在这个过程中可以注意到，不是所有的信息都具有相同的价值。压缩数据时，我们希望保留那么有价值的数据，而舍弃那些几乎没有关联的数据。这就带来了如何判断一个数据是否可以被舍弃的问题。

> 例如人的视觉和听觉中，对高频细节不敏感，可以在变换过程中滤除高频系数，保留低频系数，从而减少数据量。减少处理的难度。一个有名的例子是傅里叶变换。

我们首先定义数据的表示方式，我们记一条数据为一个向量，它的每一维都是一个类别的数据。我们希望对它进行处理，使得向量的维度尽可能的少，同时信息丢失尽可能的少。这个过程被称之为"数据降维"。

> 如果一个电商平台提供了浏览量和购买量两个数据，二者肯定不等价，但是浏览量高的店铺成交量往往更高。所以我们可以考虑舍弃其中一个数据，这样我们依然可以较好的衡量一个店铺的经营状况。

对此，我们可以采用 PCA。

## PCA的思路--------重新发现

### 空间变换

我们已经知道 PCA 的目标是数据降维。接下来我们看看是如何做的。开始之前，我们先规定，一条数据是一个向量，多条数据排列就形成了一个矩阵。我们以矩阵为基本单位进行讨论。

以二维空间为例，如果对一个数据集，其点大致分布在直线 y=x 附近。我们可以想到，采用以 y=x 为轴而非 x、y 为轴的话，表示会更加简单。我们忽略 y=-x 方向上的量，把点投影到 y=x 上，此时仍可以基本保持原来的形状，同时，原来二维的数据被降维到了一维。

在这个过程中，我们进行了数据降维。本质上是把一个二维空间给变换到了一个一维空间。在线代中我们已经明白可以采取矩阵乘法进行变换。问题的关键是：我们已知需要变换到 K 维空间。如何选择此 K 维空间的基呢？即如何确定变换矩阵？

> 具体来说，我们可以认为两个矩阵相乘的意义是将右边矩阵中的每一列列向量变换到左边矩阵中每一行行向量为基所表示的空间中去。

我们的目标是变换后尽量保留最多的原始信息。对此，一种直观的看法是：希望投影后值尽可能分散。

### 方差与协方差

高中阶段我们就已经知道，数学上使用**方差**来表达分散程度的概念。方差可以被如下表示：

$$Var(a)=\frac{1}{m}\sum_{i=1}^m{(a_i-\mu)^2}$$

预先对矩阵进行处理使得均值为 0 ，则有

$$Var(a)=\frac{1}{m}\sum_{i=1}^m{a_i^2}$$

多个维度中，我们希望尽可能多的表示原始信息，所以维度之间不应该存在相关性，否则它们的信息就会有重复。我们使用**协方差**衡量相关性。

$$Cov(a,b)=\frac{1}{m}\sum_{i=1}^m{a_ib_i}$$

相互之间协方差为 0 时，相关性最弱。所以我们需要**选择相互之间协方差为 0 且字段方差尽可能大的一组向量作为基底**。

在数学上，有：设 `m` 个 n 维数据记录排列成 $n\times m$ 的矩阵X，而

 $$C=\frac{1}{m}XX^\mathsf{T}$$

则 C 是一个对称矩阵。其对角线分别个各个字段的方差，而第 i 行 j 列和 j 行 i 列元素相同，表示 i 和 j 两个字段的协方差。

由前面的分析可知，我们使 C 非对角线为 0（协方差为 0 ），对角线由上到下递减。那么我们选取 X （而非 C ）的前 K 行，就得到了我们需要的变换矩阵。我们对 C 操作的这个过程被叫做**矩阵的对角化**。

现在问题变成了：如何使协方差矩阵对角化？

### 特征值

一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量，设这n个特征向量为 $e_1,e_2,\cdots,e_n$ ，我们将其按列组成矩阵 E。对特征向量矩阵 E 和协方差矩阵 C，有：

$$ E^\mathsf{T}CE =\Lambda =\begin{pmatrix} \lambda_1 & & & \ & \lambda_2 & & \ & & \ddots & \ & & & \lambda_n \end{pmatrix} $$ 进而我们需要的矩阵 P 有：

$$P=E^\mathsf{T}$$

P 是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是 C 的一个特征向量。如果设P按照 $\Lambda$ 中特征值的从大到小，将特征向量从上到下排列，则用 P 的前 K 行组成的矩阵乘以原始数据矩阵 X ，就得到了我们需要的降维后的数据矩阵 Y 。

### 总结

总结 PCA 的思路。

目的：我们需要数据压缩，为此，将数据进行降维，删去那些没有带来额外信息或者带来信息极少的维度，即**数据降维**。

投影：我们将 M 维数据尽可能分散地投影到 K 维空间上。因为越聚集就代表投影以后（该方向）丢失的信息越多，得到的数据的信息越趋同。着我们尽可能让每个点的信息都被记录下来就需要分散。

> 例如:
>
> 1. 在纸上画出一个立体图像的时候，我们会选用一个倾斜的角度展现三个面，而不是三视图中的一个面；
> 2. 三维空间的直线投影到二维应该最好是投影成直线而不是一个点。

我们使用方差来衡量一个方向的数据分散程度，使用协方差来保证每个方向都是正交（相关性低）的。

我们使用特征值向量矩阵选取协方差矩阵中方差最大的 K 个正交方向（主成分），再把原始数据变换刚刚求出的 K 维空间中去即可。

## PCA的具体步骤

我们可以把上述过程总结为下述步骤：

设有 m 条 n 维数据，我们将其排成 n 行 m 列（ n*m ）的矩阵 X，按一下步骤对齐进行 PCA：

1. 将X的每个属性字段进行零均值化，即减去这一列的平均值（如果我们排成 m 行 n 列，也可以是减去行的均值）。
2. 求出协方差矩阵 $C=\frac{1}{m}XX^\mathsf{T}$
3. 求出协方差矩阵的特征值及对应的特征向量
4. 将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 k 行组成矩阵 P
5. 对 X 左乘矩阵 P，有 $Y=PX$ 即为降维到k维后的数据。

## PCA的python实现

我们可以使用 numpy 进行矩阵计算；使用 pandas 读取 ASC 文件中的数据 此外，`scikit-learn` 库中的 PCA 模块可以直接实现 PCA，我们可以使用它验证我们的代码。 具体来说，我们使用到了 numpy 的以下方法：

- np.mean() :求解行/列均值用于零均值化
- np.dot(): 点积运算
- instance.shape:获取行数、列数等数据
- np.linalg.eig()：特征值

## 源代码

```python
import numpy as np
import pandas


def PCA(x, k):
    # n维n列
    # m条m行
    # m*n的矩阵

    # 1\. 形成样本矩阵，样本零均值化
    # 压缩0轴（行），得到1轴（列）的均值 mean
    mean = np.mean(x, axis=0)
    x -= mean

    # 2\. 计算样本矩阵的协方差矩阵
    x_col = x.shape[1]
    cov = np.dot(x.T, x)/x.shape[0]

    # 3\. 对协方差矩阵进行特征值分解
    eig_vals, eig_vecs = np.linalg.eig(cov)

    # 对应特征值与特征向量
    eig_pairs = []
    for i in range(0, x_col):
        eig_val_i = np.abs(eig_vals[i])
        eig_vec_i = eig_vecs[:, i]
        eig_pairs.append((eig_val_i, eig_vec_i))

    # 选取最大的p个特征值对应的特征向量组成投影矩阵
    eig_pairs.sort(reverse=True)
    feature = []
    for i in range(0, k):
        feature.append(np.array(eig_pairs[i][1]))

    # 4\. 对原始样本矩阵进行投影，得到降维后的新样本矩阵
    reduced_data = np.dot(x, np.transpose(feature))

    return reduced_data


FILEPATH = "D:\DocumentsSet\ColorHistogram.asc"
data = pandas.read_csv(FILEPATH, sep=' ', header=None, index_col=0).values

result = PCA(data, 5)
print(result)
```

## 参考资料

- [CodingLabs - PCA的数学原理](https://blog.codinglabs.org/articles/pca-tutorial.html)
